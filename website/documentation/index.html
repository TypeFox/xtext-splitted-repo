<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Eclipse Xtend</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- Le styles -->
	<link href="../bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<style type="text/css">
		body {
			padding-top: 20px;
		}
		
		section {
			padding-top: 40px;
		}
		
		div#maincontainer>section {
			padding-top: 90px;
		}
	</style>
	<link href="../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">
	<link href="../bootstrap/../google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../bootstrap/../google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="../bootstrap/../google-code-prettify/lang-xtend.js"></script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
		
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le fav and touch icons -->
	<link rel="shortcut icon" href="../bootstrap/ico/favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../bootstrap/ico/apple-touch-icon-144-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../bootstrap/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../bootstrap/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="../bootstrap/ico/apple-touch-icon-57-precomposed.png">
</head>

<body data-spy="scroll" data-target=".subnav" data-offset="50"  onload="prettyPrint()">
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="http://www.xtend-lang.org">Xtend</a>
				<ul class="nav">
					<li><a href="#Introduction">	Introduction
					</a></li>
					<li><a href="#Installation">	Installation
					</a></li>
					<li><a href="#GettingStarted">	Getting Started
					</a></li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">	Static Typing and Java Interoperability
						 <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#localTypeInference">	Type Inference
							</a></li>
							<li><a href="#conversionRules">	Conversion Rules
							</a></li>
							<li><a href="#javaInteroperability">	Interoperability with Java
							</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">	Classes and Members
						 <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#packageDecl">	Package Declaration
							</a></li>
							<li><a href="#imports">	Imports
							</a></li>
							<li><a href="#Xtend_ClassDeclaration">	Class Declaration
							</a></li>
							<li><a href="#constructors">	Constructors
							</a></li>
							<li><a href="#fields">	Fields
							</a></li>
							<li><a href="#methods">	Methods
							</a></li>
							<li><a href="#Annotations">	Annotations
							</a></li>
							<li><a href="#extensionMethods">	Extension Methods
							</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">	Expressions
						 <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#Xtend_Expressions_Literals">	Literals
							</a></li>
							<li><a href="#typeCasts">	Type Casts
							</a></li>
							<li><a href="#operators">	Infix Operators and Operator Overloading
							</a></li>
							<li><a href="#blocks">	Blocks
							</a></li>
							<li><a href="#variableDeclaration">	Variable Declarations
							</a></li>
							<li><a href="#featureCalls">	Field Access and Method Invocation
							</a></li>
							<li><a href="#constructorCall">	Constructor Call
							</a></li>
							<li><a href="#lambdas">	Lambda Expressions
							</a></li>
							<li><a href="#ifExpression">	If Expression
							</a></li>
							<li><a href="#switchExpression">	Switch Expression
							</a></li>
							<li><a href="#forLoop">	For Loop
							</a></li>
							<li><a href="#whileExpression">	While Loop
							</a></li>
							<li><a href="#doWhileExpression">	Do-While Loop
							</a></li>
							<li><a href="#Xtend_Expressions_Return">	Return Expression
							</a></li>
							<li><a href="#Xtend_Expressions_Throw">	Throwing Exceptions
							</a></li>
							<li><a href="#Xtend_Expressions_TryCatch">	Try, Catch, Finally
							</a></li>
							<li><a href="#templates">	Template Expressions
							</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">	Processed Annotations
						 <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#propertyAnnotation">	@Property
							</a></li>
							<li><a href="#dataAnnotation">	@Data
							</a></li>
						</ul>
					</li>
				</ul>
				<ul class="nav pull-right">
					<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
				</ul>	
			</div>
		</div>
	</div>
	<div id="maincontainer" class="container">
		<!-- chapter -->
		<section id="Introduction">
		<div class="page-header">
			<h1>
					Introduction
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					Xtend is a statically-typed programming language which translates to comprehensible Java source code. 
					Syntactically and semantically Xtend has its roots in the Java programming language but improves on many aspects:   
				</p>
				<p>
					<ul>
						<li>	<strong>	<a href="#extensionMethods">	Extension methods
								</a>
							</strong> - enhance closed types with new functionality
						</li>
						<li>	<strong>	<a href="#lambdas">	Lambda Expressions
								</a>
							</strong> - concise syntax for anonymous function literals
						</li>
						<li>	<strong>	<a href="#operators">	Operator overloading
								</a>
							</strong> - make your libraries even more expressive
						</li>
						<li>	<strong>	<a href="#switchExpression">	Powerful switch expressions
								</a>
							</strong> - type based switching with implicit casts
						</li>
						<li>	<strong>	<a href="#polymorphicDispatch">	Multiple dispatch
								</a>
							</strong> - a.k.a. polymorphic method invocation
						</li>
						<li>	<strong>	<a href="#templates">	Template expressions
								</a>
							</strong> - with intelligent white space handling
						</li>
						<li>	<strong>	<a href="#Xtend_Expressions">	No statements
								</a>
							</strong> - everything is an expression
						</li>
						<li>	<strong>	<a href="#propertyAccess">	Properties
								</a>
							</strong> - shorthands for accessing and defining getters and setter
						</li>
						<li>	<strong>	Local type inference
							</strong> - you rarely need to write down type signatures anymore
						</li>
						<li>	<strong>	Full support for Java Generics
							</strong> - including all conformance and conversion rules
						</li>
						<li>	<strong>	Translates to Java
							</strong> not bytecode - understand what is going on and use your code for platforms 
							    such as Android or GWT
						</li>
					</ul>
				</p>
				<p>
					The language is not aiming at replacing Java all together. Its 
					<a href="#library">	library
					</a> is just a thin layer on top of the 
					Java Development Kit (JDK) and unlike other JVM languages there are 
					<a href="#javaInteroperability">	zero interoperability
					</a> issues:
					Everything you write in Xtend interacts with Java exactly as if it were written in Java in the first place.
					At the same time Xtend is just much more concise, readable and expressive. 
				</p>
				<p>
					Of course, you can call Xtend methods from Java, too, in a completely transparent way. Furthermore, Xtend provides a modern 
					Eclipse-based IDE closely integrated with Eclipse&apos;s Java Development Tools (JDT), including features like call-hierarchies, rename refactoring, 
					debugging and many more.
				</p>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="Installation">
		<div class="page-header">
			<h1>
					Installation
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					Xtend requires Eclipse 3.5 or higher and a Java SDK 5 or higher. The easiest way to install the
					SDK is via 
					<a href="http://marketplace.eclipse.org/content/eclipse-xtend">Eclipse Marketplace</a>. 
					But there is also a complete Eclipse distribution 
					<a href="http://www.eclipse.org/xtend/index.html#download">available for download
					at http://xtend-lang.org</a>.
				</p>
				<p>
					If you do not want to use the recommended Eclipse plug-in, you can compile Xtend code using the 
					Maven plug-in.
				</p>
				<!--  section -->
				<section id="MavenSupport">
				<h2>	Maven Support
				</h2>
				<p>
					The 
					<a href="#library">	runtime library
					</a> as well as a plug-in to run the compiler in a Maven build can be be obtained from
					the following Maven repository: 
					<a href="http://build.eclipse.org/common/xtend/maven/">http://build.eclipse.org/common/xtend/maven/</a>.
				</p>
				<p>
					Here is the XML for the repository:
					<pre class="prettyprint lang-xtend linenums">
&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;xtend&lt;/id&gt;
    &lt;url&gt;http://build.eclipse.org/common/xtend/maven/&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
  &lt;pluginRepository&gt;
    &lt;id&gt;xtend&lt;/id&gt;
    &lt;url&gt;http://build.eclipse.org/common/xtend/maven/&lt;/url&gt;
  &lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</pre>
				</p>
				<p>
					Here is the XML for the dependency to the library:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.xtend&lt;/groupId&gt;
  &lt;artifactId&gt;org.eclipse.xtend.lib&lt;/artifactId&gt;
  &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
				</p>
				<p>
					And this is the XML for the plug-in:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
&lt;plugin&gt;
  &lt;groupId&gt;org.eclipse.xtend&lt;/groupId&gt;
  &lt;artifactId&gt;xtend-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.3.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;goals&gt;
        &lt;goal&gt;compile&lt;/goal&gt;
        &lt;!-- &lt;goal&gt;testCompile&lt;/goal&gt; --&gt;
      &lt;/goals&gt;
      &lt;!-- optionally you can configure a different target folder --&gt;
      &lt;!--
      &lt;configuration&gt;
        &lt;outputDirectory&gt;xtend-gen&lt;/outputDirectory&gt;
      &lt;/configuration&gt;
      --&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</pre>
				</p>
				<p>
					As you see the 
					<strong>	outputDirectory
					</strong> can be specified to match the default of the Eclipse plug-in (
					<strong>	xtend-gen
					</strong>). Of course you can also change the configuration
					in Eclipse to match the Maven default (
					<strong>	generated-sources
					</strong>). To do so right-click on the project and select 
					<strong>	Properties
					</strong> or if you prefer a global setting choose 
					<strong>	Eclipse-&gt;Preferences
					</strong>.
					In the category 
					<strong>	Xtend/Compiler
					</strong> enter the directory name (see screenshot). It is interpreted as a relative path to the parent of the source folder, which includes the to-be-compiled Xtend file.
				</p>
				<p>
					<div class="thumbnail">
						<img src="images/configure-compiler-in-eclipse.png" alt="">
					</div>
				</p>
				<!-- subsection -->
				<section id="library">
				<h3>	The Runtime Library
				</h3>
				<p>
					The compiler requires a small runtime library on the classpath, which mainly provides useful extensions
					to existing classes and interfaces from the JDK. The class 
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/InputOutput.html">
						<abbr title="org.eclipse.xtext.xbase.lib.InputOutput">InputOutput</abbr>
					</a>
					
					providing the method 
					<code>&lt;T&gt; T println(T obj)</code> being one of them. 
				</p>
				<p>
					The only surprising fact in the generated Java code may be the library class. Many 
					features of Xtend are not built into the language itself but provided via the library
					<strong>	org.eclipse.xtend.lib
					</strong>. The library is available from a 
					<a href="#MavenSupport">	Maven repository
					</a> and via p2
					update site (in case you do Eclipse plug-in development).
				</p>
				<p>
					The library provides means to create collections in a readable way:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val myList = newArrayList(1, 2, 3)
val mySet = newHashSet(4, 5, 6)
val myMap = newHashMap(1 -&gt; &apos;one&apos;, 2 -&gt; &apos;two&apos;, 3 -&gt; &apos;three&apos;)</pre>
				</p>
				<p>
					It also extends the collection types with a lot of very useful functions.
					One example is the ubiquitous 
					<code>map</code> function:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val listOfNames = listOfPersons.map[ name ]</pre>
				</p>
				<p>
					Many operators to concat collections or to do arithmetics with types like 
					<code>BigDecimal</code> are also available.
				</p>
				<p>
					You might want to have a look at the 
					<a href="http://xtend-lang.org/api/2.3.0/index.html">JavaDoc API</a> to see what is
					available.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="GettingStarted">
		<div class="page-header">
			<h1>
					Getting Started
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					The first thing you want to see in any language is a "Hello World" example. 
					In Xtend, that reads as
					<pre class="prettyprint lang-xtend linenums">
class HelloWorld {
  def static void main(String[] args) {
    println("Hello World")
  }
}</pre>
				</p>
				<p>
					You see that Xtend looks a lot like Java. At a first glance the main difference seems to be the 
					<code>def</code>
					keyword for declaring a method. Also like in Java it is mandatory to define a class and a main method as the entry point for an application. 
					Admittedly &apos;hello world&apos; programs are not a particular strength of Xtend. The real expressiveness is unleashed when you do real stuff
					as you will learn in a moment.
				</p>
				<p>
					An Xtend class resides in a plain Java project. As soon as the SDK is installed, Eclipse will automatically 
					translate it to Java code. By default you will find it in a source folder 
					<strong>	xtend-gen
					</strong>, which is of course configurable.
					The hello world example is translated to the following Java code:
					<pre class="prettyprint lang-java linenums">
// Generated Java Source Code
import org.eclipse.xtext.xbase.lib.InputOutput;

public class HelloWorld {
  public static void main(final String[] args) {
    InputOutput.&lt;String&gt;println("Hello World");
  }
}</pre>
				</p>
				<p>
					You can put an Xtend class in source folders of any Java project within Eclipse (or any Maven project). Eclipse will complain
					about the missing library if it is not on the classpath and provide a quick fix to add it.
				</p>
				<p>
					The next thing you might want to do is materializing one of the example projects into your workspace.
					To do so right click anywhere in the 
					<strong>	Navigator
					</strong> view in Eclipse and select 
					<strong>	New -&gt; Example...
					</strong>.
				</p>
				<p>
					In the upcoming dialog you will find two examples for Xtend:
				</p>
				<p>
					<ul>
						<li>	<strong>	Xtend Introductory Examples
							</strong> contains a couple of example code snippets illustrating certain
							  aspects and strengths of Xtend. 
							  It for instance shows how to build an API which allows for writing code like this:
							<pre class="prettyprint lang-xtend linenums">
assertEquals(42.km/h, (40_000.m + 2.km) / 60.min)</pre>
							
							  Also the 
							<a href="#moviesExample">	the movies example
							</a> explained in detail in 
							<a href="#moviesExample">	the next section
							</a>
							  is included there.
						</li>
						<li>	<strong>	Xtend Solutions For Euler
							</strong> contains solutions to a lot of the problems you will find at 
							<a href="http://projecteuler.net/">Project Euler's website</a>.
							   These examples are leveraging the whole expressive power of Xtend. For instance 
							<a href="http://projecteuler.net/problem=1">Euler Problem 1</a> can be solved
							   with the following expression :
							<pre class="prettyprint lang-xtend linenums">
(1..999).filter[ i | i % 3 == 0 || i % 5 == 0].reduce[i1, i2 | i1 + i2]</pre>
							
						</li>
					</ul>
				</p>
				<!--  section -->
				<section id="moviesExample">
				<h2>	The Movies Example
				</h2>
				<p>
					The movies example is included in the example project 
					<strong>	Xtend Introductory Examples
					</strong> (src/examples6/Movies.xtend) and is about reading
					a file with data about movies in and doing some analysis on it.
				</p>
				<!-- subsection -->
				<section id="Section2_0">
				<h3>	The Data
				</h3>
				<p>
					The movie database is a plain text file (data.csv) with data sets describing movies.
					Here is an example data set:
					<pre class="prettyprint lang-xtend linenums">
Naked Lunch  1991  6.9  16578  Biography  Comedy  Drama  Fantasy</pre>
				</p>
				<p>
					The values are separated by two spaces. The columns are :
					<ol>
						<li>	title
						</li>
						<li>	year
						</li>
						<li>	rating
						</li>
						<li>	numberOfVotes
						</li>
						<li>	categories
						</li>
					</ol>
					
					 
					Let us define a data type 
					<code>Movie</code> representing a data set:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@Data class Movie {
  String title
  int year
  double rating
  long numberOfVotes
  Set&lt;String&gt; categories 
}</pre>
				</p>
				<p>
					It is a plain class with a typed field for each column in the data sets. The 
					<a href="#dataAnnotation">	@Data
					</a>
					annotation will turn this class into a value object, that is it will get 
					<ul>
						<li>	a getter-method for each field,
						</li>
						<li>	a 
							<code>hashCode()</code>/
							<code>equals()</code> implementation,
						</li>
						<li>	implementation of 
							<code>Object.toString(),</code>
						</li>
						<li>	a constructor accepting values for all fields in the declared order.
						</li>
					</ul>
				</p>
				<!-- subsection -->
				<section id="Section2_1">
				<h3>	Parsing The Data
				</h3>
				<p>
					Let us now add another class to the same file (any number of 
					<a href="#Xtend_Classes_Members">	classes
					</a> per file is allowed) and initialize a field
					called movies with a list of movies. For the initialization we read in the text file and turn the data sets into 
					<code>Movie</code>s:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
import java.io.FileReader
import java.util.Set
import static extension com.google.common.io.CharStreams.*

class Movies {
  
  val movies = new FileReader(&apos;data.csv&apos;).readLines.map[ line |
    val segments = line.split(&apos;  &apos;).iterator
    return new Movie(
      segments.next, 
      Integer::parseInt(segments.next), 
      Double::parseDouble(segments.next), 
      Long::parseLong(segments.next), 
      segments.toSet
    )
  ]
}</pre>
				</p>
				<p>
					A 
					<a href="#fields">	field&apos;s type
					</a> can be inferred from the expression on the right hand-side. 
					That is called local type inference and is supported everyhwere in Xtend.
					We want the field to be final, so we declare it as a value using the keyword 
					<code>val</code>.
				</p>
				<p>
					The initialization on the right hand side first creates a fresh instance of 
					<code>java.io.FileReader</code>.
					Then the method 
					<code>readLines()</code> is invoked on that instance. But if you have a look at 
					<code>FileReader</code> you will not find
					such a method, because 
					<code>readLines()</code> is in fact a static method from Google Guava&apos;s 
					<code>CharStream</code> which was imported 
					as an 
					<a href="#extensionImports">	extension
					</a> which allows us to use this readable syntax.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
import static extension com.google.common.io.CharStreams.*</pre>
				</p>
				<p>
					<code>CharStream.readLines(Reader)</code> returns a 
					<code>List&lt;String&gt;</code> on which we call another extension method called 
					<code>map</code>.
					That one is defined in the 
					<a href="#library">	runtime library
					</a> (
					<code>ListExtensions.map(...)</code> and is always imported and
					therefore automatically available on all lists. The 
					<code>map</code> extension expects a function as a parameter.
					Map basically invokes that function for each value in the list and returns another list containing the results of the function incovations.
				</p>
				<p>
					Function objects are created using 
					<a href="#lambdas">	lambda expression
					</a> (the code in squared brackets).
					Within the lambda we process a single line from the text file and turn it into a movie by splitting the string using the
					separator (two whitespaces) and calling iterator on the result. As you might know 
					<code>java.lang.String.split(String)</code>
					returns a string array (
					<code>String[]</code>), which Xtend 
					<a href="#conversionRules">	auto-convertes to a list
					</a> when we 
					call 
					<code>Iterable.iterator()</code> on it.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val segments = line.split(&apos;  &apos;).iterator</pre>
				</p>
				<p>
					Now we use the iterator to create an instance of 
					<code>Movie</code>.
					The data type conversion (e.g. 
					<code>String</code> to 
					<code>int</code>) is done by calling 
					<a href="#staticAccess">	static methods
					</a> from the wrapper types. 
					The rest of the iterable is turned into a set using the extension method 
					<code>Iterators.toSet(Iterator&lt;T&gt;)</code>
					and contains all the categories the movie is associated with.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
return new Movie (
  segments.next, 
  Integer::parseInt(segments.next), 
  Double::parseDouble(segments.next), 
  Long::parseLong(segments.next), 
  segments.toSet
)</pre>
				</p>
				<!-- subsection -->
				<section id="Section2_2">
				<h3>	Answering Some Questions
				</h3>
				<p>
					Now that we have turned the text file into a 
					<code>List&lt;Movie&gt;</code>, we are ready to execute some queries against it.
					We use 
					<strong>	JUnit
					</strong> to make the individual analysis executable.
				</p>
				<!-- subsection -->
				<section id="Section3_3">
				<h4>	Question 1 : What Is The Number Of Action Movies?
				</h4>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@Test def numberOfActionMovies() {
  assertEquals(828, 
    movies.filter[categories.contains(&apos;Action&apos;)].size)
}</pre>
				</p>
				<p>
					First the movies are 
					<code>filter</code>ed. The lambda expression checks whether the current movie&apos;s categories contain 
					the entry 
					<code>&apos;Action&apos;</code>. Note that unlike the lambda we used to turn the lines in the file into movies, we 
					have not declared a parameter name this time. 
					We could have written 
					<pre class="prettyprint lang-xtend linenums">
movies.filter[ movie | movie.categories.contains(&apos;Action&apos;)].size</pre>
					
					but since we left out the name and the vertical bar the variable is automatically named 
					<code>it</code> which
					(like 
					<code>this</code>) is an 
					<a href="#implicitVariables">	implicit variable
					</a>. That is why we can write either
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
movies.filter[ it.categories.contains(&apos;Action&apos;)].size</pre>
					
					or 
					<pre class="prettyprint lang-xtend linenums">
movies.filter[categories.contains(&apos;Action&apos;)].size</pre>
				</p>
				<p>
					Eventually we call 
					<code>size</code> on the resulting iterable which also is an extension method defined in 
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/IterableExtensions.html">
						<abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr>
					</a>
					.
				</p>
				<!-- subsection -->
				<section id="Section3_4">
				<h4>	Question 2 : What Is The Year The Best Movie From The 80ies Was Released?
				</h4>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@Test def void yearOfBestMovieFrom80ies() {
  assertEquals(1989, 
    movies.filter[(1980..1989).contains(year)].sortBy[rating].last.year)
}</pre>
				</p>
				<p>
					Here we 
					<code>filter</code> for all movies whose year is included in the range from 1980 to 1989 (the 80ies).
					The 
					<code>..</code> operator is again an extension defined in 
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/IntegerExtensions.html">
						<abbr title="org.eclipse.xtext.xbase.lib.IntegerExtensions">IntegerExtensions</abbr>
					</a>
					 and returns an instance of 
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/IntegerRange.html">
						<abbr title="org.eclipse.xtext.xbase.lib.IntegerRange">IntegerRange</abbr>
					</a>
					.
					Operator overloading is explained in 
					<a href="#operators">	section
					</a>.
				</p>
				<p>
					The resulting iterable is sorted (
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/IterableExtensions.html">
						<abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr>
					</a>
					<code>.sortBy</code>) by the 
					<code>rating</code> of the movies. 
					Since it is sorted in ascending order, we take the last movie from the list and return its 
					<code>year</code>. 
				</p>
				<p>
					We could have sorted descending and take the head of the list as well:
					<pre class="prettyprint lang-xtend linenums">
movies.filter[(1980..1989).contains(year)].sortBy[-rating].head.year</pre>
				</p>
				<p>
					Note that first sorting and then taking the last or first is slightly more expensive than needed. We could
					have used the method 
					<code>reduce</code> instead to find the best movie which would be more efficient. Maybe
					you want to try it on your own?
				</p>
				<p>
					The calls to 
					<code>movie.year</code> as well as 
					<code>movie.categories</code> in the previous example in fact access the corresponding 
					<a href="#propertyAccess">	getter methods
					</a>.
				</p>
				<!-- subsection -->
				<section id="Section3_5">
				<h4>	Question 3 : What Is The The Sum Of All Votes Of The Top Two Movies?
				</h4>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@Test def void sumOfVotesOfTop2() {
  val long sum = movies.sortBy[-rating].take(2).map[numberOfVotes].reduce[a, b| a + b]
  assertEquals(47_229L, sum)
}</pre>
				</p>
				<p>
					First the movies are sorted by rating, then we take the best two. Next the list of movies is turned into a list of their 
					<code>numberOfVotes</code> using the 
					<code>map</code> function. 
					Now we have a 
					<code>List&lt;Long&gt;</code> which can be reduced to a single 
					<code>Integer</code> by adding the values.
				</p>
				<p>
					You could also use 
					<code>reduce</code> instead of 
					<code>map</code> and 
					<code>reduce</code>. Do you know how?
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="types">
		<div class="page-header">
			<h1>
					Static Typing and Java Interoperability
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					Xtend, like Java, is a statically typed language. In fact it completely supports Java&apos;s type system, including the primitive types 
					as 
					<code>int</code> or 
					<code>boolean</code>, arrays and of course all classes, interfaces, enums and annotations that reside on the 
					classpath.  
				</p>
				<p>
					Java Generics are fully supported as well: You can define type parameters on methods and classes and pass type arguments to
					generic types just as you are used to from Java. The type system and its conformance and casting rules are implemented as
					defined in  
					<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html">the Java Language Specification</a>.
				</p>
				<!--  section -->
				<section id="localTypeInference">
				<h2>	Type Inference
				</h2>
				<p>
					One of the problems with Java is that you are forced to write type signatures over
					and over again. That is why so many people do not like static typing. 
					But this is in fact not a problem of static typing but simply a problem with Java. Although Xtend is typed
					just like Java, you rarely have to write types down because they can be computed from the context.
				</p>
				</section>
				<!--  section -->
				<section id="conversionRules">
				<h2>	Conversion Rules
				</h2>
				<p>
					In addition to Java&apos;s autoboxing to convert primitives to their corresponding wrapper types (e.g. 
					<code>int</code>
					is automatically converted to 
					<code>Integer</code> when needed), there are additional conversion rules.
				</p>
				<p>
					Arrays are automatically converted to 
					<code>java.util.List&lt;ComponentType&gt;</code> and vice versa. That is you can
					write the following:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def toList(String[] array) {
  val List&lt;String&gt; asList = array
  return asList
}</pre>
				</p>
				<p>
					Another very useful conversion applies to lambda expressions. A lambda expression
					usually is of one of the types listed in 
					<code>org.eclipse.xtext.xbase.lib.Functions</code>
					or 
					<code>org.eclipse.xtext.xbase.lib.Predicates</code>. However if the expected type is an interface with a single method
					declaration, a lambda expression is automatically converted to that
					type. This allows to use lambda expressions with many existing Java libraries. See 
					<a href="#closureTypes"></a>
					for more details.
				</p>
				</section>
				<!--  section -->
				<section id="javaInteroperability">
				<h2>	Interoperability with Java
				</h2>
				<p>
					Resembling and supporting every aspect of Java&apos;s type system ensures that there is no impedance mismatch between Java and Xtend.
					This means that Xtend and Java are 100% interoperable. There are no exceptional cases. You do not have
					to think in two worlds. You can call Xtend code from Java and vice versa without any surprises or hassles.
				</p>
				<p>
					As a bonus if you know Java&apos;s type system (specifically generics), you already know the most complicated part
					of Xtend.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="Xtend_Classes_Members">
		<div class="page-header">
			<h1>
					Classes and Members
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					At a first glance an Xtend file pretty much looks like a Java file. It starts with a package 
					declaration followed by an import section and a class definition.
					The class in fact is directly translated to a Java class in the corresponding Java package.
					A class can have constructors, fields and methods. 
				</p>
				<p>
					Here is an example:
					<pre class="prettyprint lang-xtend linenums">
package com.acme

import java.util.List

class MyClass {
  String name
  
  new(String name) {
    this.name = name
  }
  
  def String first(List&lt;String&gt; elements) {
    elements.get(0)
  }
}</pre>
				</p>
				<!--  section -->
				<section id="packageDecl">
				<h2>	Package Declaration
				</h2>
				<p>
					Package declarations look like in Java. There are two small differences: 
					<ul>
						<li>	An identifier can be escaped with a 
							<code>^</code> character in case it conflicts with a keyword.
						</li>
						<li>	The terminating semicolon is optional.
						</li>
					</ul>
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
package com.acme</pre>
				</p>
				</section>
				<!--  section -->
				<section id="imports">
				<h2>	Imports
				</h2>
				<p>
					The ordinary imports of type names are equivalent to the imports known from Java. 
					Again one can escape any names conflicting with keywords using a 
					<code>^</code>. In contrast to Java, the 
					terminating semicolon is optional. Xtend also features static imports but 
					allows only a wildcard 
					<code>*</code> at the end, i.e. you currently cannot import single members using a static 
					import. Non-static wildcard imports are deprecated for the benefit of better tooling. 
				</p>
				<p>
					As in Java all classes from the 
					<code>java.lang</code> package are implicitly imported.
					<pre class="prettyprint lang-xtend linenums">
import java.math.BigDecimal
import static java.util.Collections.*</pre>
				</p>
				<p>
					Static methods of helper classes can also be imported as 
					<strong>	extensions
					</strong>. See the section on 
					<a href="#extensionMethods">	extension methods
					</a> for details.
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_ClassDeclaration">
				<h2>	Class Declaration
				</h2>
				<p>
					The class declaration reuses a lot of Java&apos;s syntax but still is a bit different in some aspects:
					Java&apos;s default "package private" visibility does not exist in Xtend. As an Xtend class is compiled to
					a top-level Java class and Java does not allow 
					<code>private</code> or 
					<code>protected</code> top-level
					classes any Xtend class is 
					<code>public</code>. It is possible to write 
					<code>public</code> explicitly. 
				</p>
				<p>
					Since version 2.3, multiple class declaration per file are supported. Each of these classes
					is compiled to a separate top-level Java class.
				</p>
				<p>
					Abstract classes are defined using the 
					<code>abstract</code> modifier as in Java. See also 
					<a href="#abstractMethods"></a> 
					on abstract methods.
				</p>
				<p>
					Xtend&apos;s approach to inheritance is conceptionally the same as in Java. Single inheritance of 
					classes as well as implementing multiple interfaces is supported. 
					Xtend classes can of course extend other Xtend classes, and even Java classes can inherit from Xtend classes. 
				</p>
				<p>
					The most simple class looks like this:
					<pre class="prettyprint lang-xtend linenums">
class MyClass {
}</pre>
				</p>
				<p>
					A more advanced generic class declaration in Xtend:
					<pre class="prettyprint lang-xtend linenums">
class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, 
                   Cloneable, java.io.Serializable {
  ...
}</pre>
				</p>
				</section>
				<!--  section -->
				<section id="constructors">
				<h2>	Constructors
				</h2>
				<p>
					An Xtend class can define one or more constructors. Unlike Java you do not have to repeat the name of the class over and over again,
					but use keyword 
					<strong>	new
					</strong> to declare a constructor.
					Constructors can also delegate to other constructors using 
					<code>this(args...)</code> in their first
					line. 
					<pre class="prettyprint lang-xtend linenums">
class MyClass extends AnotherClass {
  new(String s) {
    super(s)
  }
  
  new() {
    this("default")
  }
}</pre>
				</p>
				<p>
					The same rules with regard to inheritance apply as in Java, i.e. if the super class does not define a 
					no-argument constructor, you have to explicitly call one using 
					<code>super(args...)</code> as the first 
					expression in the body of the constructor.
				</p>
				<p>
					The default visibility of constructors is 
					<code>public</code> but you can also specify 
					<code>protected</code>
					or 
					<code>private</code>.
				</p>
				</section>
				<!--  section -->
				<section id="fields">
				<h2>	Fields
				</h2>
				<p>
					A field can have an initializer. Final fields are declared using 
					<code>val</code>, while 
					<code>var</code> introduces a non-final field and can be ommitted. Yet, if an initializer expression
					is present, the type of a field can be skipped after 
					<code>val</code> and 
					<code>var</code>.
					Fields marked as 
					<code>static</code> will be compiled to static Java fields.  
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
class MyClass {
  int count = 1
  static boolean debug = false
  var name = &apos;Foo&apos;          // type String is inferred 
  val UNIVERSAL_ANSWER = 42 // final field with inferred type int
  ...
}</pre>
				</p>
				<p>
					The default visibility is 
					<code>private</code>. You can also declare it explicitly as 
					being 
					<code>public</code>, 
					<code>protected</code>, or 
					<code>private</code>. 
				</p>
				<p>
					A specialty of Xtend are fields that provide 
					<strong>	extension methods
					</strong> which are covered in 
					<a href="#extensionMethods">	their own section
					</a>.
				</p>
				</section>
				<!--  section -->
				<section id="methods">
				<h2>	Methods
				</h2>
				<p>
					Xtend methods are declared within a class and are translated to a corresponding Java method with 
					exactly the same signature. The only exceptions are dispatch methods, which are explained 
					<a href="#polymorphicDispatch">	in section
					</a>. 
					<pre class="prettyprint lang-xtend linenums">
def String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre>
				</p>
				<p>
					The default visibility of a plain method is 
					<code>public</code>. You can explicitly declare it as
					being 
					<code>public</code>, 
					<code>protected</code>, or 
					<code>private</code>.
				</p>
				<p>
					Xtend supports the 
					<code>static</code> modifier for methods:
					<pre class="prettyprint lang-xtend linenums">
def static createInstance() {
  new MyClass(&apos;foo&apos;)
}</pre>
				</p>
				<p>
					As in Java 5, Xtend allows vararg parameters:
					<pre class="prettyprint lang-xtend linenums">
def printAll(String... strings) {
  strings.forEach[s | println(s)]
}</pre>
				</p>
				<!-- subsection -->
				<section id="abstractMethods">
				<h3>	Abstract Methods
				</h3>
				<p>
					An abstract method in Xtend just does not define a body and must be declared within an 
					<code>abstract</code>
					class. Also specifying the return type is mandatory since it cannot be inferred. 
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
abstract class MyAbstractClass() {
	def String abstractMethod() // no body
}</pre>
				</p>
				<!-- subsection -->
				<section id="Section2_6">
				<h3>	Overriding Methods
				</h3>
				<p>
					Methods can override other methods from the super class or implemented interface methods using the
					keyword 
					<code>override</code>. If a method overrides a method from a super type, the 
					<code>override</code> keyword is mandatory and replaces the keyword 
					<code>def</code>. As in Java 
					<code>final</code> methods cannot be overridden by subclasses.
				</p>
				<p>
					Example:
					<pre class="prettyprint lang-xtend linenums">
override String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre>
				</p>
				<!-- subsection -->
				<section id="declaredExceptions">
				<h3>	Declared Exceptions
				</h3>
				<p>
					Xtend does not force you to catch or redeclare checked exceptions. Nevertheless, you can still declare 
					the exceptions thrown in a method&apos;s body using the same 
					<code>throws</code> clause as in Java.
				</p>
				<p>
					If you do not declare checked exceptions in your method but they are possibly thrown in your code, the
					compiler will rethrow the checked exception silently (using the sneaky-throw technique introduced by 
					<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>). 
					  
					<pre class="prettyprint lang-xtend linenums">
/*
 * throws an Exception
 */
def void throwException() throws Exception {
   throw new Exception
}

/*
 * throws an Exception without declaring it
 */
def void sneakyThrowException() {
   throw new Exception
}</pre>
				</p>
				<!-- subsection -->
				<section id="inferredReturnTypes">
				<h3>	Inferred Return Types
				</h3>
				<p>
					If the return type of a method can be inferred from its body it does not have to be declared.
				</p>
				<p>
					That is the method
					<pre class="prettyprint lang-xtend linenums">
def String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre>
				</p>
				<p>
					could be declared like this:
					<pre class="prettyprint lang-xtend linenums">
def first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre>
				</p>
				<p>
					This does not work for abstract method declarations as well as if the return type of a method 
					depends on a recursive call of the same method.
				</p>
				<!-- subsection -->
				<section id="genericMethods">
				<h3>	Generic Methods
				</h3>
				<p>
					You can specify type parameters just like in Java. To generalize the method from the previous section,
					you would declare it like this:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def &lt;T&gt; first(List&lt;T&gt; elements) {
  elements.get(0)
}</pre>
				</p>
				<p>
					Also bounds and the like are supported and share the same syntax as defined in the 
					<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.4.4">the Java Language Specification</a>
				</p>
				<!-- subsection -->
				<section id="polymorphicDispatch">
				<h3>	Dispatch Methods
				</h3>
				<p>
					Generally, method binding works just like method binding in Java. Method calls are bound 
					based on the static types of arguments. Sometimes this is not what you want. Especially in the 
					context of 
					<a href="#extensionMethods">	extension methods
					</a> you would like to have polymorphic behavior.
				</p>
				<p>
					A dispatch method is marked using the keyword 
					<code>dispatch</code>.
					<pre class="prettyprint lang-xtend linenums">
def dispatch printType(Number x) { 
  "it&apos;s a number" 
}

def dispatch printType(Integer x) { 
  "it&apos;s an int" 
}</pre>
				</p>
				<p>
					For a set of visible dispatch methods in the current type hierarchy sharing the same name and the same
					number of arguments, the compiler infers a synthetic method (the dispatcher) using the common super type of all declared arguments.
					The actual dispatch methods are reduced in visibility and renamed (prepending an underscore) so that client code always binds to
					the dispatcher method.
				</p>
				<p>
					For the two dispatch methods in the example above the following Java code would be generated:
					<pre class="prettyprint lang-java linenums">
protected String _printType(final Number x) {
  return "it\&apos;s a number";
}

protected String _printType(final Integer x) {
  return "it\&apos;s an int";
}

public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre>
				</p>
				<p>
					Note that the 
					<code>instanceof</code> cascade is ordered such that more specific types come first.
				</p>
				<p>
					The default visibility of the underscore methods is 
					<code>protected</code>. If all dispatch methods
					explicitly declare the same visibility, this will be the visibility of the inferred dispatcher, too.
					Otherwise it is 
					<code>public</code>.
					 
					The comparison of the type parameters goes from left to right. That is in the following example, the second
					method declaration is considered more specific since its first parameter type is the most specific:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def dispatch printTypes(Number x, Integer y) { 
  "it&apos;s some number and an int" 
}

def dispatch printTypes(Integer x, Number y) { 
  "it&apos;s an int and a number" 
}</pre>
				</p>
				<p>
					generates the following Java code :
					<pre class="prettyprint lang-java linenums">
public String printTypes(final Number x, final Number y) {
  if (x instanceof Integer
       && y != null) {
    return _printTypes((Integer)x, y);
  } else if (x != null
       && y instanceof Integer) {
    return _printTypes(x, (Integer)y);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x, y).toString());
  }
}</pre>
				</p>
				<p>
					As you can see a 
					<code>null</code> reference is never a match. If you want to fetch 
					<code>null</code> 
					you can declare a dispatch case using the type 
					<code>java.lang.Void</code>.
					<pre class="prettyprint lang-xtend linenums">
def dispatch printType(Number x) { 
  "it&apos;s some number" 
}

def dispatch printType(Integer x) { 
  "it&apos;s an int" 
}

def dispatch printType(Void x) { 
  "it&apos;s null" 
}</pre>
				</p>
				<p>
					This compiles to the following Java code:
					<pre class="prettyprint lang-java linenums">
public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else if (x == null) {
    return _printType((Void)null);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre>
				</p>
				<!-- subsection -->
				<section id="Section3_7">
				<h4>	Dispatch Methods and Inheritance
				</h4>
				<p>
					Any visible Java methods from super types conforming to the compiled form of a dispatch method are
					also included in the dispatch. Conforming means they have the right number of arguments and have 
					the same name (starting with an underscore).
				</p>
				<p>
					For example, consider the following Java class :
					<pre class="prettyprint lang-java linenums">
public abstract class AbstractLabelProvider {
   protected String _label(Object o) {
      // some generic implementation
   }
}</pre>
				</p>
				<p>
					and the following Xtend class which extends the Java class :
					<pre class="prettyprint lang-xtend linenums">
class MyLabelProvider extends AbstractLabelProvider {
   def dispatch label(Entity it)  {
     name
   }
     
   def dispatch label(Method it) { 
     name+"("+params.join(",")+"):"+type
   }
   
   def dispatch label(Field it) { 
     name+type
   }
}</pre>
				</p>
				<p>
					The resulting dispatch method in the generated Java class 
					<code>MyLabelProvider</code> would then look like this:
					<pre class="prettyprint lang-java linenums">
public String label(final Object it) {
  if (it instanceof Entity) {
    return _label((Entity)it);
  } else if (it instanceof Field) {
    return _label((Field)it);
  } else if (it instanceof Method) {
    return _label((Method)it);
  } else if (it != null) {
    return super._label(it);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(it).toString());
  }
}</pre>
				</p>
				<!-- subsection -->
				<section id="Section3_8">
				<h4>	Static Dispatch Methods
				</h4>
				<p>
					Also static dispatch methods are supported. But you cannot mix static and non-static
					dispatch methods.
				</p>
				</section>
				<!--  section -->
				<section id="Annotations">
				<h2>	Annotations
				</h2>
				<p>
					The syntax and semantics for annotations is exactly like defined in the 
					<a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java Language Specification</a>. 
					Annotations are available on classes, fields, methods and parameters. Here is an example:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@TypeAnnotation("some value")
class MyClass {
  @FieldAnnotation(children = {@MyAnno(true), @MyAnno(false)})
  String myField
  
  @MethodAnnotation(children = {@MyAnno(true), @MyAnno})
  def String myMethod(@ParameterAnnotation String param) {
    //...
  }
}</pre>
				</p>
				<p>
					Certain annotations defined in the library have a special effect on how the code is translated to Java.
					These annotations are explained in 
					<a href="#processedAnnotations">	section
					</a>.
				</p>
				</section>
				<!--  section -->
				<section id="extensionMethods">
				<h2>	Extension Methods
				</h2>
				<p>
					Extension methods allow to add new methods to existing types without modifying them. 
					This feature is actually where Xtend got its name from. They are based on a simple syntactic trick: 
					Instead of passing the first argument of an extension method inside the parentheses of a call, the 
					method is called on the argument parameter as if it was one of its members.
					<pre class="prettyprint lang-xtend linenums">
"hello".toFirstUpper() // calls toFirstUper("hello")</pre>
				</p>
				<p>
					Method calls in extension syntax often result in more readable code, as they are chained rather than nested. 
					Another benefit of extensions is that you can add methods which are specific to a certain context
					(read layer) only. You might for instance not want to put UI-specific methods and dependencies to your
					domain model classes. Therefore such functionality is often defined in static methods or methods in
					some "service class". That works, but the code is less readable and object-oriented if you call methods
					like this. In Java for instance you often see code like this:
				</p>
				<p>
					<pre class="prettyprint lang-java linenums">
persistenceManager.save(myObject);</pre>
				</p>
				<p>
					With extension methods you can write
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
myObject.save</pre>
				</p>
				<p>
					There are different ways to make methods available as extensions, which are described in the following.
				</p>
				<!-- subsection -->
				<section id="libraryExtensions">
				<h3>	Extensions From The Library
				</h3>
				<p>
					The 
					<a href="#library">	library
					</a> puts a lot of very useful extension methods on existing types from the Java
					SDK without any further ado.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
"hello".toFirstUpper // calls StringExtensions.toFirstUpper(String)
listOfStrings.map[toUpperCase] // calls ListExtensions.&lt;T, R&gt;map(List&lt;T&gt; list, Function&lt;? super T, ? extends R&gt; mapFunction)</pre>
				</p>
				<p>
					Have a look at the JavaDoc to see what is there:
				</p>
				<p>
					<ul>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/ObjectExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.ObjectExtensions">ObjectExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/IterableExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/MapExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.MapExtensions">MapExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/ListExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.ListExtensions">ListExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/CollectionExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.CollectionExtensions">CollectionExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/BooleanExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.BooleanExtensions">BooleanExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/IntegerExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.IntegerExtensions">IntegerExtensions</abbr>
							</a>
						</li>
						<li>	<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/FunctionExtensions.html">
								<abbr title="org.eclipse.xtext.xbase.lib.FunctionExtensions">FunctionExtensions</abbr>
							</a>
						</li>
					</ul>
				</p>
				<!-- subsection -->
				<section id="Section2_9">
				<h3>	Local Extension Methods
				</h3>
				<p>
					All visible non-static methods of the current class and its super types are automatically available as extensions. For example
					<pre class="prettyprint lang-xtend linenums">
class MyClass {
  def doSomething(Object obj) {
    // do something with obj
  }
  
  def extensionCall(Object obj) {
    obj.doSomething()  // calls this.doSomething(obj)
  }
}</pre>
				</p>
				<p>
					Local static methods have to be made available through an import like any other static method.
				</p>
				<!-- subsection -->
				<section id="extensionImports">
				<h3>	Extension Imports
				</h3>
				<p>
					In Java, you would usually write a helper class with static methods to decorate an existing
					class with additional behavior. In order to integrate such static helper classes, Xtend allows to put
					the keyword 
					<code>extension</code> after the 
					<code>static</code> keyword of a 
					<a href="#imports">	static import
					</a>
					thus making all imported static functions available as extensions methods.
				</p>
				<p>
					The following import declaration 
					<pre class="prettyprint lang-xtend linenums">
import static extension java.util.Collections.*</pre>
				</p>
				<p>
					allows to use its methods like this:
					<pre class="prettyprint lang-xtend linenums">
new MyClass().singletonList() 
  // calls Collections.singletonList(new MyClass())</pre>
				</p>
				<!-- subsection -->
				<section id="Extension_Fields">
				<h3>	Extension Fields
				</h3>
				<p>
					By adding the 
					<code>extension</code> keyword to a field declaration, its instance methods become extension methods.
				</p>
				<p>
					Imagine you want to have some layer specific functionality on a class 
					<code>Person</code>. Let us say you are in a servlet-like class
					and want to persist a 
					<code>Person</code> using some persistence mechanism. Let us assume 
					<code>Person</code> implements
					a common interface 
					<code>Entity</code>.
					 
					You could have the following interface
					<pre class="prettyprint lang-java linenums">
interface EntityPersistence {
  public save(Entity e);
  public update(Entity e);
  public delete(Entity e);
}</pre>
				</p>
				<p>
					And if you have obtained an instance of that type (through a factory or dependency injection or what ever) like this:
					<pre class="prettyprint lang-xtend linenums">
class MyServlet {
  extension EntityPersitence ep = Factory.get(typeof(EntityPersistence))
  ...
  
}</pre>
				</p>
				<p>
					You are able to save, update and delete any entity like this:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val Person person = ...
person.save  // calls ep.save(person)
person.name = &apos;Horst&apos;
person.update  // calls ep.update(person)
person.delete  // calls ep.delete(person)</pre>
				</p>
				<p>
					Using the 
					<code>extension</code> modifier on fields has a significant advantage over 
					static 
					<a href="#extensionImports">	extension imports
					</a>: Your code is not bound to the actual implementation of the extension method.
					You can simply exchange the component that provides the referenced extension with another implementation from outside,
					by providing a different instance. No matter whether you do so via a factory, dependency injection or simply
					using a setter.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="Xtend_Expressions">
		<div class="page-header">
			<h1>
					Expressions
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					Xtend does not have statements. Instead, everything is an expression and has a return value. That
					allows to compose your code in interesting ways. For example, you can have a
					<code>try catch</code> expression on the right hand side of an assignment: 
					<pre class="prettyprint lang-xtend linenums">
val data = try {
    fileContentsToString(&apos;data.txt&apos;)
  } catch (IOException e) {
  &apos;dummy data&apos;
  }</pre>
				</p>
				<p>
					If 
					<code>fileContentsToString()</code> throws an 
					<code>IOException</code>, it is caught and the string 
					<code>&apos;dummy data&apos;</code> is assigned to the value 
					<code>data</code>.
					 
					Expressions can appear as 
					<a href="#fields">	initializers of fields
					</a>, the body of constructors
					or methods and as values in annotations. A method body can either be a 
					<a href="#blocks">	block expression
					</a> 
					or a 
					<a href="#templates">	template expression
					</a>.
				</p>
				<!--  section -->
				<section id="Xtend_Expressions_Literals">
				<h2>	Literals
				</h2>
				<p>
					A literal denotes a fixed unchangeable value. Literals for 
					<a href="#stringLiterals">	strings
					</a>, 
					<a href="#numberLiterals">	numbers
					</a>, 
					<a href="#booleanLiteral">	booleans
					</a>,
					<code>null</code> and 
					<a href="#typeLiteral">	Java types
					</a> are supported.
				</p>
				<!-- subsection -->
				<section id="stringLiterals">
				<h3>	String Literals
				</h3>
				<p>
					A string literal is of type 
					<code>java.lang.String</code> (just like in Java).
					String literals are enclosed in a pair of single quotes or double quotes. We mostly use single quotes
					because the signal-to-noise ration is a bit better, but generally you should use the terminals which are
					least likely occure in the actual string. Special characters can be quoted with a backslash or defined using
					Java&apos;s unicode notation. Contrary to Java, strings can span multiple lines.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
&apos;Hello World !&apos;
"Hello World !"
&apos;Hello "World" !&apos;
"Hello \"World\" !"
&apos;\u00a1Hola el mundo!&apos;
"Hello 

  World !"</pre>
				</p>
				<!-- subsection -->
				<section id="numberLiterals">
				<h3>	Number Literals
				</h3>
				<p>
					Xtend supports roughly the same number literals as Java with a few differences.   
					First, there are no signed number literals. If you put a minus operator in front of an number 
					literal it is taken as a 
					<a href="#operators">	unary operator
					</a> with one argument (the positive number 
					literal). Second, as in Java 7, you can separate digits using 
					<code>_</code> for better readability
					of large numbers.
					 
					An integer literal creates an 
					<code>int</code>, a 
					<code>long</code> (suffix 
					<code>L</code>) or a
					<a href="http://xtend-lang.org/api/2.3.0/java/math/BigInteger.html">
						<abbr title="java.math.BigInteger">BigInteger</abbr>
					</a>
					 (suffix 
					<code>BI</code>). There are no octal numbers
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
42
1_234_567_890 
0xbeef    // hexadecimal
077       // decimal 77 (*NOT* octal)
-1  // an expression consisting of the unary - operator and an integer literal  
42L
0xbeef#L // hexadecimal, mind the &apos;#&apos;
0xbeef_beef_beef_beef_beef#BI // BigInteger</pre>
				</p>
				<p>
					A floating-point literal creates a 
					<code>double</code> (suffix 
					<code>D</code> or none), a 
					<code>float</code> 
					(suffix 
					<code>F</code>) or a 
					<a href="http://xtend-lang.org/api/2.3.0/java/math/BigDecimal.html">
						<abbr title="java.math.BigDecimal">BigDecimal</abbr>
					</a>
					 (suffix 
					<code>BD</code>). If you use a 
					<code>.</code> you have to 
					specify both, the integer and the fractional part of the mantissa. There are only decimal floating-point 
					literals.  
					<pre class="prettyprint lang-xtend linenums">
42d     // double
0.42e2  // implicit double
0.42e2f // float
4.2f    // float
0.123_456_789_123_456_789_123_456_789e2000bd // BigDecimal</pre>
				</p>
				<!-- subsection -->
				<section id="booleanLiteral">
				<h3>	Boolean Literals
				</h3>
				<p>
					There are two boolean literals, 
					<code>true</code> and 
					<code>false</code> which correspond to their 
					Java counterpart of type 
					<code>boolean</code>. 
				</p>
				<!-- subsection -->
				<section id="nullLiteral">
				<h3>	Null Literal
				</h3>
				<p>
					The null pointer literal 
					<code>null</code> has exactly the same semantics as in Java.
				</p>
				<!-- subsection -->
				<section id="typeLiteral">
				<h3>	Type Literals
				</h3>
				<p>
					Type literals are specified using the keyword 
					<code>typeof</code> :
					<pre class="prettyprint lang-xtend linenums">
typeof(java.lang.String) // yields java.lang.String.class</pre>
				</p>
				</section>
				<!--  section -->
				<section id="typeCasts">
				<h2>	Type Casts
				</h2>
				<p>
					A type cast behaves exactly like casts in Java, but has a slightly more readable syntax.
					Type casts bind stronger than any other operator but weaker than feature calls.
				</p>
				<p>
					The conformance rules for casts are defined in the 
					<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5">Java Language Specification</a>.
					Here are some examples:
					<pre class="prettyprint lang-xtend linenums">
something as MyClass
42 as Integer</pre>
				</p>
				<p>
					Although casts are supported you might want to use a 
					<a href="#switchExpression">	switch with a type guard
					</a> or a 
					<a href="#polymorphicDispatch">	dispatch method
					</a> as a better and safer alternative.
				</p>
				</section>
				<!--  section -->
				<section id="operators">
				<h2>	Infix Operators and Operator Overloading
				</h2>
				<p>
					There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
					to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
					operators for any type just by implementing the corresponding method signature. As an example, the 
					<a href="#library">	Xtend runtime library
					</a> contains a class 
					<code>BigDecimalExtensions</code> that defines operators for 
					<code>BigDecimals</code> which allows the following code:
					<pre class="prettyprint lang-xtend linenums">
val x = 2.71BD
val y = 3.14BD
val sum = x + y    // calls BigDecimalExtension.operator_plus(x,y)</pre>
				</p>
				<p>
					This is the complete list of all available operators and their corresponding method signatures:
				</p>
				<p>
					<table class="table table-bordered table-condensed">
					<tr><td>	<code>e1 += e2</code>
					</td>
					<td>	<code>e1.operator_add(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 || e2</code>
					</td>
					<td>	<code>e1.operator_or(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 && e2</code>
					</td>
					<td>	<code>e1.operator_and(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 == e2</code>
					</td>
					<td>	<code>e1.operator_equals(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 != e2</code>
					</td>
					<td>	<code>e1.operator_notEquals(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 &lt; e2</code>
					</td>
					<td>	<code>e1.operator_lessThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &gt; e2</code>
					</td>
					<td>	<code>e1.operator_greaterThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &lt;= e2</code>
					</td>
					<td>	<code>e1.operator_lessEqualsThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &gt;= e2</code>
					</td>
					<td>	<code>e1.operator_greaterEqualsThan(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 -&gt; e2</code>
					</td>
					<td>	<code>e1.operator_mappedTo(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 .. e2</code>
					</td>
					<td>	<code>e1.operator_upTo(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 =&gt; e2</code>
					</td>
					<td>	<code>e1.operator_doubleArrow(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &lt;&lt; e2</code>
					</td>
					<td>	<code>e1.operator_doubleLessThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &gt;&gt; e2</code>
					</td>
					<td>	<code>e1.operator_doubleGreaterThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &lt;&lt;&lt; e2</code>
					</td>
					<td>	<code>e1.operator_tripleLessThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &gt;&gt;&gt; e2</code>
					</td>
					<td>	<code>e1.operator_tripleGreaterThan(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &lt;&gt; e2</code>
					</td>
					<td>	<code>e1.operator_diamond(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 ?: e2</code>
					</td>
					<td>	<code>e1.operator_elvis(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 &lt;=&gt; e2</code>
					</td>
					<td>	<code>e1.operator_spaceship(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 + e2</code>
					</td>
					<td>	<code>e1.operator_plus(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 - e2</code>
					</td>
					<td>	<code>e1.operator_minus(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>e1 * e2</code>
					</td>
					<td>	<code>e1.operator_multiply(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 / e2</code>
					</td>
					<td>	<code>e1.operator_divide(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 % e2</code>
					</td>
					<td>	<code>e1.operator_modulo(e2)</code>
					</td>
					</tr>
					<tr><td>	<code>e1 ** e2</code>
					</td>
					<td>	<code>e1.operator_power(e2)</code>
					</td>
					</tr>
					<tr><td></td>
					<td></td>
					</tr>
					<tr><td>	<code>! e1</code>
					</td>
					<td>	<code>e1.operator_not()</code>
					</td>
					</tr>
					<tr><td>	<code>- e1</code>
					</td>
					<td>	<code>e1.operator_minus()</code>
					</td>
					</tr>
					</table>
					
					    
					The table above also defines the operator precedence in ascending order. The blank lines separate 
					precedence levels. The assignment operator 
					<code>+=</code> is right-to-left associative in the same way 
					as the plain assignment operator 
					<code>=</code> is. That is a = b = c is executed as a = (b = c), all
					other operators are left-to-right associative. Parenthesis can be used to adjust the default 
					precedence and associativity. 
				</p>
				<!-- subsection -->
				<section id="Section2_10">
				<h3>	Short-Circuit Boolean Operators
				</h3>
				<p>
					If the operators 
					<code>||</code> and 
					<code>&&</code> are bound to the library methods 
					<code>BooleanExtensions.operator_and(boolean l, boolean r)</code> resp. 
					<code>BooleanExtensions.operator_or(boolean l, boolean r)</code> the operation is evaluated in short circuit mode.
					That means that the right hand operand might not be evaluated at all in the following cases: 
					<ol>
						<li>	in the case of 
							<code>||</code> the operand on the right hand side is not evaluated if the left 
							    operand evaluates to 
							<code>true</code>.
						</li>
						<li>	in the case of 
							<code>&&</code> the operand on the right hand side is not evaluated if the left 
							    operand evaluates to 
							<code>false</code>.
						</li>
					</ol>
				</p>
				<p>
					Still you can overload these operators for your types or even override it for booleans, in which case
					both operands are always evaluated and the defined method is invoked, i.e. no short-circuit execution is happening.
				</p>
				<!-- subsection -->
				<section id="Section2_11">
				<h3>	Examples
				</h3>
				<p>
					<pre class="prettyprint lang-xtend linenums">
my.property = 23
myList += 23
x &gt; 23 && y &lt; 23
x && y || z
1 + 3 * 5 * (- 23)
!(x)</pre>
				</p>
				<!-- subsection -->
				<section id="assignments">
				<h3>	Assignments
				</h3>
				<p>
					<a href="#variableDeclaration">	Local variables
					</a> can be reassigned using the 
					<code>=</code> operator. 
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
var greeting = &apos;Hello&apos;
if (isInformal)
  greeting = &apos;Hi&apos;</pre>
				</p>
				<p>
					Of course, also non-final fields can be set using an assignment: 
					<pre class="prettyprint lang-xtend linenums">
myObj.myField = &apos;foo&apos;</pre>
				</p>
				<!-- subsection -->
				<section id="propertyAssignments">
				<h4>	Setting Properties
				</h4>
				<p>
					The lack of properties in Java leads to a lot of syntactic noise when working with data objects.
					As Xtend is designed to integrate with existing Java APIs it respects the Java Beans convention,
					hence you can call a setter using an assignment:
				</p>
				<p>
					<pre class="prettyprint lang-java linenums">
myObj.myProperty = &apos;foo&apos; // calls myObj.setMyProperty("foo")</pre>
				</p>
				<p>
					The setter is only used if the field is not accessible from the given context. That is why the 
					<a href="#propertyAnnotation">	@Property annotation
					</a> would rename the local field to 
					<code>_myProperty</code>.
				</p>
				<p>
					The return type of an assignment is the type of the right hand side, in case it is a simple assignment.
					If it is translated to a setter method it yields whatever the setter method returns.
				</p>
				</section>
				<!--  section -->
				<section id="blocks">
				<h2>	Blocks
				</h2>
				<p>
					The block expression allows to have imperative code sequences. It consists of a sequence of 
					expressions, and returns the value of the last expression. The return type of a block is also the 
					type of the last expression. Empty blocks return 
					<code>null</code>. 
					<a href="#variableDeclaration">	Variable declarations
					</a> are only allowed within blocks and cannot be used as 
					a block&apos;s last expression.
				</p>
				<p>
					A block expression is surrounded by curly braces and contains at least one expression. It can 
					optionally be terminated by a semicolon. 
				</p>
				<p>
					Here are two examples:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
{
  doSideEffect("foo")
  result
}</pre>
					
					<pre class="prettyprint lang-xtend linenums">
{
  var x = greeting
  if (x.equals("Hello ")) {
    x + "World!" 
  } else {
    x
  }
}</pre>
				</p>
				</section>
				<!--  section -->
				<section id="variableDeclaration">
				<h2>	Variable Declarations
				</h2>
				<p>
					Variable declarations are only allowed within 
					<a href="#blocks">	blocks
					</a>. They are visible in any 
					subsequent expressions in the block. 
				</p>
				<p>
					A variable declaration starting with the keyword 
					<code>val</code> denotes a value, which
					is essentially a final (i.e. unsettable) variable. In some cases, one needs to update the value of 
					a reference. In such situations the variable needs to be declared with the keyword 
					<code>var</code>, 
					which stands for &apos;variable&apos;.
				</p>
				<p>
					A typical example for using 
					<code>var</code> is a counter in a loop:
					<pre class="prettyprint lang-xtend linenums">
{
  val max = 100
  var i = 0
  while (i &lt; max) {
    println("Hi there!")
    i = i + 1
  }
}</pre>
				</p>
				<p>
					Shadowing variables from outer scopes is not allowed, the only exception is the 
					<a href="#implicitVariables">	implicit variable
					</a><code>it</code>.
				</p>
				<p>
					Variables declared outside a lambda expression using the 
					<code>var</code> keyword are not accessible from within a
					lambda expressions.
				</p>
				<!-- subsection -->
				<section id="Section2_12">
				<h3>	Typing
				</h3>
				<p>
					The type of the variable itself can either be explicitly declared or be inferred from the right hand side
					expression. Here is an example for an explicitly declared type:
					<pre class="prettyprint lang-xtend linenums">
var List&lt;String&gt; msg = new ArrayList</pre>
				</p>
				<p>
					In such cases, the type of the right hand expression must conform to the type 
					of the expression on the left side. 
				</p>
				<p>
					Alternatively the type can be left out and will be inferred from the initialization expression:  
					<pre class="prettyprint lang-xtend linenums">
var msg = new ArrayList&lt;String&gt; // -&gt; msg is of type ArrayList&lt;String&gt;</pre>
				</p>
				</section>
				<!--  section -->
				<section id="featureCalls">
				<h2>	Field Access and Method Invocation
				</h2>
				<p>
					A simple name can refer to a local field, variable or parameter. In addition
					it can point to a method with zero arguments, since empty parenthesis are optional. 
				</p>
				<!-- subsection -->
				<section id="propertyAccess">
				<h3>	Property Access
				</h3>
				<p>
					If there is no field with the given name and also no method with the name and zero parameters
					accessible, a simple name binds to a corresponding Java-Bean getter method if available :
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
myObj.myProperty // myObj.getMyProperty()  (.. in case myObj.myProperty is not visible.)</pre>
				</p>
				<!-- subsection -->
				<section id="implicitVariables">
				<h3>	Implicit Variables 
					<strong>	this
					</strong> and 
					<strong>	it
					</strong>
				</h3>
				<p>
					Like in Java an instance of the class is bound to 
					<code>this</code>. Which allows for either qualifying
					field access or method invocations like in:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
this.myField</pre>
				</p>
				<p>
					or omit the receiver:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
myField</pre>
				</p>
				<p>
					You can use the variable name 
					<code>it</code> to get the same behavior for any variable or parameter:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val it = new Person
name = &apos;Horst&apos; // translates to &apos;it.setName("Horst");&apos;</pre>
				</p>
				<p>
					Another speciality of the variable 
					<code>it</code> is that it can be shadowed. This is especially useful
					when used together with 
					<a href="#lambdas">	lambda expressions
					</a>.
				</p>
				<p>
					As 
					<code>this</code> is bound to the surrounding object in Java, 
					<code>it</code> can be used
					in finer-grained constructs such as 
					<a href="#lambdas">	lambda expressions
					</a>. That is why 
					<code>it.myProperty</code> has 
					higher precedence than 
					<code>this.myProperty</code>.
				</p>
				<!-- subsection -->
				<section id="staticAccess">
				<h3>	Static Access
				</h3>
				<p>
					For accessing a static field or method you have to use the double colon 
					<code>::</code> like in this example:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
MyClass::myField
MyClass::myMethod(&apos;foo&apos;)</pre>
				</p>
				<p>
					Alternatively you could import the method using a 
					<a href="#imports">	static import
					</a>.
				</p>
				<!-- subsection -->
				<section id="nullSafeFeatureCalls">
				<h3>	Null-Safe Feature Call
				</h3>
				<p>
					Checking for 
					<code>null</code> references can make code very unreadable. In many situations it is ok for an 
					expression to return 
					<code>null</code> if a receiver was 
					<code>null</code>. Xtend supports the safe navigation 
					operator 
					<code>?.</code> to make such code better readable.
				</p>
				<p>
					Instead of writing 
					<pre class="prettyprint lang-java linenums">
if (myRef != null) myRef.doStuff()</pre>
				</p>
				<p>
					one can write
					<pre class="prettyprint lang-xtend linenums">
myRef?.doStuff</pre>
				</p>
				</section>
				<!--  section -->
				<section id="constructorCall">
				<h2>	Constructor Call
				</h2>
				<p>
					Constructor calls have the same syntax as in Java. The only difference is that empty parenthesis
					are optional:
					<pre class="prettyprint lang-xtend linenums">
new String() == new String
new ArrayList&lt;BigDecimal&gt;() == new ArrayList&lt;BigDecimal&gt;</pre>
				</p>
				</section>
				<!--  section -->
				<section id="lambdas">
				<h2>	Lambda Expressions
				</h2>
				<p>
					A lambda expression is basically a piece of code, which is wrapped in an object to pass it around. As
					a Java developer it is best to think of a lambda expression as an anonymous class, i.e. 
					like in the following Java code :
				</p>
				<p>
					<pre class="prettyprint lang-java linenums">
// Java Code!
final JTextField textField = new JTextField();
textField.addActionListener(new ActionListener() {
  @Override
  public void actionPerformed(ActionEvent e) {
    textField.setText("Something happened!");
  }
});</pre>
				</p>
				<p>
					This kind of anonymous classes can be found everywhere in Java code and have always been the poor-man&apos;s replacement
					for lambda expressions in Java. 
				</p>
				<p>
					Xtend not only supports lambda expressions, but offers an extremely dense syntax for it. That is the
					code above can be written in Xtend like this:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val textField = new JTextField
textField.addActionListener([ ActionEvent e |
  textField.text = "Something happened!"
])</pre>
				</p>
				<p>
					As you might have guessed, a lambda expression is surrounded by square brackets (inspired from Smalltalk).
					Also a lambda expression like a method declares parameters. The lambda above has one parameter called 
					<code>e</code> which is of
					type 
					<code>ActionEvent</code>. You do not have to specify the type explicitly because it can be inferred from
					the context:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
textField.addActionListener([ e |
  textField.text = "Something happened!"
])</pre>
				</p>
				<p>
					Also as lambdas with one parameter are a common case, there is a special short hand for them,
					which is to leave the declaration including the vertical bar out. The name of the single variable will be 
					<a href="#implicitVariables">	it
					</a>
					in that case:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
textField.addActionListener([
  textField.text = "Something happened!"
])</pre>
				</p>
				<p>
					A lambda expression with zero arguments is written like this (note the bar after the opening bracket):
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val Runnable runnable = [|
  println("Hello I&apos;m executed!")
]</pre>
				</p>
				<p>
					When a method call&apos;s last parameter is a lambda it can be passed right after the parameters.
					For instance if you want to sort some strings by their length, you could write :
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
Collections::sort(someStrings) [ a, b |
  a.length - b.length
]</pre>
				</p>
				<p>
					which is just the same as writing
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
Collections::sort(someStrings, [ a, b |
  a.length - b.length
])</pre>
				</p>
				<p>
					Since you can leave out empty parenthesis methods wich get a lambda as the single argument you can reduce
					the code above further more:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
textField.addActionListener[
  textField.text = "Something happened!"
]</pre>
				</p>
				<p>
					A lambda expression also captures the current scope, so that any final variables and parameters visible at construction time can be referred to 
					in the closure&apos;s expression. That is exactly what we did with the variable 
					<code>textField</code>.
				</p>
				<!-- subsection -->
				<section id="closureTypes">
				<h3>	Typing
				</h3>
				<p>
					Closures are expressions which produce 
					<strong>	Function
					</strong> objects. The type of a lambda expression generally depends on the target
					type, as seen in the previous examples. That is, the lambda expression can coerce to any interface which has declared only 
					one method (in addition to the ones inherited from 
					<code>java.lang.Object</code>). This allows for using lambda expressions in many existing Java
					APIs directly.
				</p>
				<p>
					However, if you write a lambda expression without having any target type expectation, like in the following
					assignment:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val toUpperCaseFunction = [String s | s.toUpperCase] // inferred type is (String)=&gt;String</pre>
				</p>
				<p>
					The type will be one of the types found in 
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/Functions.html">
						<abbr title="org.eclipse.xtext.xbase.lib.Functions">Functions</abbr>
					</a>
					 or 
					<a href="http://xtend-lang.org/api/2.3.0/org/eclipse/xtext/xbase/lib/Procedures.html">
						<abbr title="org.eclipse.xtext.xbase.lib.Procedures">Procedures</abbr>
					</a>
					.
					It is a procedure if the return type is 
					<code>void</code>, otherwise it is a function.
				</p>
				<p>
					Xtend supports a shorthand syntax for function types. Instead of writing 
					<code>Function1&lt;? super String,? extends String&gt;</code>
					which is what you will find in the generated Java code, you can simply write 
					<code>(String)=&gt;String</code>.
				</p>
				<p>
					Example:
					<pre class="prettyprint lang-xtend linenums">
val (String)=&gt;String stringToStringFunction = [toUpperCase]
// or
val Function1&lt;? super String,? extends String&gt; same = [toUpperCase]
// or
val stringToStringFunction2 = [String s | s.toUpperCase] // inferred type is (String)=&gt;String</pre>
				</p>
				<p>
					Checked exceptions that are thrown in the body of a closure but not declared in the implemented method of the target type are rethrown using the 
					<a href="#declaredExceptions">	sneaky-throw technique
					</a>.
					Of course you can always 
					<a href="#Xtend_Expressions_TryCatch">	catch and handle
					</a> them.
				</p>
				</section>
				<!--  section -->
				<section id="ifExpression">
				<h2>	If Expression
				</h2>
				<p>
					An if expression is used to choose two different values based on a predicate.
				</p>
				<p>
					An expression 
					<pre class="prettyprint lang-xtend linenums">
if (p) e1 else e2</pre>
					 
					results in either the value 
					<code>e1</code> or 
					<code>e2</code> depending on whether the predicate 
					<code>p</code> evaluates 
					to 
					<code>true</code> or 
					<code>false</code>. The else part is optional which is a shorthand for 
					<code>else null</code>. That means 
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
if (foo) x</pre>
				</p>
				<p>
					is a short hand for
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
if (foo) x else null</pre>
				</p>
				<p>
					The type of an if expression is the common super type of the return types 
					<code>T1</code> and 
					<code>T2</code> 
					of the two expression 
					<code>e1</code> and 
					<code>e2</code>.
				</p>
				<p>
					While the if expression has the syntax of Java&apos;s if statement it behaves more like Java&apos;s ternary operator 
					(
					<code>predicate ? thenPart : elsePart</code>), because it is an expression and returns a value.
					Consequently, you can use if expressions deeply nested within expressions:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val name = if (firstName != null) firstName + &apos; &apos; + lastName else lastName</pre>
				</p>
				</section>
				<!--  section -->
				<section id="switchExpression">
				<h2>	Switch Expression
				</h2>
				<p>
					The switch expression is very different from Java&apos;s switch statement. First, there is no fall through which means 
					only one 
					<code>case</code> is evaluated at most. Second, the use of 
					<code>switch</code> is not limited 
					to certain values but can be used for any object reference instead. 
					<code>Object.equals()</code> is used to
					compare the value in the case with the one you are switching over.
					 
					Given the following example:
					 
					<pre class="prettyprint lang-xtend linenums">
switch myString {
  case myString.length&gt;5 : "a long string."
  case &apos;some&apos; : "It&apos;s some string."
  default : "It&apos;s another short string."
}</pre>
				</p>
				<p>
					the main expression 
					<code>numberAsText</code> is evaluated first and then compared to each case sequentially.
					If the case expression is of type 
					<code>boolean</code>, the case matches if the expression evaluates
					to 
					<code>true</code>. If it is not of type 
					<code>boolean</code> it is compared to the value from the main
					expression using 
					<code>Object.equals(Object)</code>.
				</p>
				<p>
					If a case is a match, that is it evaluates to 
					<code>true</code> or the result equals the one we are switching
					over, the case expression after the colon is evaluated and is the result of the whole expression.
				</p>
				<!-- subsection -->
				<section id="Section2_13">
				<h3>	Type guards
				</h3>
				<p>
					Instead of or in addition to the case guard you can specify a 
					<strong>	type guard
					</strong>. The case only matches if the 
					switch value conforms to this type. A case with both a type guard and a predicate only matches if both match.
					If the switch value is a variable, this variable is automatically casted to the given type withnin the
					predicate and the case&apos;s body.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def length(Object x) {
  switch x {
    String case x.length &gt; 0 : x.length // length is defined for String 
    List&lt;?&gt; : x.size    // size is defined for List
    default : -1
  }
}</pre>
				</p>
				<p>
					Switches with type guards are a safe and much more readable alternative to instance of / casting orgies you 
					might know from Java.
				</p>
				</section>
				<!--  section -->
				<section id="forLoop">
				<h2>	For Loop
				</h2>
				<p>
					The for loop 
					<pre class="prettyprint lang-xtend linenums">
for (T1 variable : arrayOrIterable) expression</pre>
					 
					is used to execute a certain expression for each element of an array or an instance of 
					<code>java.lang.Iterable</code>. The local 
					<code>variable</code> is final, hence canot be updated. 
				</p>
				<p>
					The return type of a for loop is 
					<code>void</code>. The type of the local variable can be left out. 
					In that case it is inferred from the type of the array or 
					<code>java.lang.Iterable</code> returned by the 
					iterable expression.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
for (String s : myStrings) {
  doSideEffect(s)
}

for (s : myStrings)
  doSideEffect(s)</pre>
				</p>
				</section>
				<!--  section -->
				<section id="whileExpression">
				<h2>	While Loop
				</h2>
				<p>
					A while loop 
					<pre class="prettyprint lang-xtend linenums">
while (predicate) expression</pre>
					 
					is used to execute a certain expression unless the predicate is evaluated to 
					<code>false</code>. 
					The return type of a while loop is 
					<code>void</code>.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
while (true) {
  doSideEffect("foo")
}

while ((i=i+1) &lt; max) 
  doSideEffect("foo")</pre>
				</p>
				</section>
				<!--  section -->
				<section id="doWhileExpression">
				<h2>	Do-While Loop
				</h2>
				<p>
					A do-while loop 
					<pre class="prettyprint lang-xtend linenums">
do expression while (predicate)</pre>
					 
					is used to execute a certain expression unless the predicate is evaluated to 
					<code>false</code>. 
					The difference to the 
					<a href="#whileExpression">	while loop
					</a> is that the execution starts by executing 
					the block once before evaluating the predicate for the first time. The return type of a do-while 
					loop is 
					<code>void</code>.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
do {
  doSideEffect("foo");
} while (true)


do doSideEffect("foo") while ((i=i+1)&lt;max)</pre>
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_Expressions_Return">
				<h2>	Return Expression
				</h2>
				<p>
					A method or lambda expression automatically returns the value of its expression.
					If it is a 
					<a href="#blocks">	block expression
					</a> this is the value of the last expression in it.
					However, sometimes you want to return early or make it explicit.
				</p>
				<p>
					The syntax is just like in Java:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
listOfStrings.map(e| {
  if (e==null) 
    return "NULL"
  e.toUpperCase
})</pre>
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_Expressions_Throw">
				<h2>	Throwing Exceptions
				</h2>
				<p>
					Throwing 
					<code>java.lang.Throwable</code>s up the call stack has the same semantics and syntax 
					as in Java.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
{
  ...
  if (myList.isEmpty)
    throw new IllegalArgumentException("the list must not be empty")
  ...
}</pre>
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_Expressions_TryCatch">
				<h2>	Try, Catch, Finally
				</h2>
				<p>
					The try-catch-finally expression is used to handle exceptional situations.
					Checked exceptions are treated like runtime exceptions. You can but do not have to catch them as they
					will be silently rethrown (see the 
					<a href="#declaredExceptions">	section on declared exceptions
					</a>). The syntax 
					again is like Java.
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
try {
  throw new RuntimeException()
} catch (NullPointerException e) {
  // handle e
} finally {
  // do stuff
}</pre>
				</p>
				<p>
					For try-catch it is again beneficial that it is an expression, because you can write code like the following
					and do not have to rely on non-final variables:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
val name = try {
    person.name
  } catch (NullPointerException e) {
    "no name"
  }</pre>
				</p>
				</section>
				<!--  section -->
				<section id="templates">
				<h2>	Template Expressions
				</h2>
				<p>
					Templates allow for readable string concatenation. Templates are surrounded by triple single quotes (
					<code>&apos;&apos;&apos;</code>). 
					A template expression can span multiple lines and expressions can be nested which are evaluated and their 
					<code>toString()</code> 
					representation is automatcially inserted at that position.
				</p>
				<p>
					The terminals for interpolated expression are so called guillemets 
					<code>&laquo;expression&raquo;</code>. They read nicely and are not often used
					in text so you seldomly need to escape them. These escaping conflicts are the reason why
					template languages often use longer character sequences like e.g. 
					<code>&lt;%= expression %&gt;</code> in JSP, for the price of worst readability. 
					The downside with the guillemets in Xtend is that you will have to have a consistent encoding. Always use UTF-8 and you are good.
				</p>
				<p>
					If you use the Eclipse plug-in - which is recommended - the guillemets will be inserted on content assist
					within a template. They are additionally bound to 
					<strong>	CTRL+SHIFT+&lt;
					</strong> and 
					<strong>	CTRL+SHIFT+
					</strong> for 
					<code>&laquo;</code> and 
					<code>&raquo;</code> respectively.
					On a Mac they are bound to 
					<strong>	alt+q
					</strong> (
					<code>&laquo;</code>) and 
					<strong>	alt+Q
					</strong> (
					<code>&raquo;</code>).
				</p>
				<p>
					Let us have a look at an example of how a typical method with a template expressions looks like:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def someHTML(String content) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;content&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre>
				</p>
				<p>
					As you can see, template expressions can be used as the direct body of a method.
					If an interpolation expression evaluates to 
					<code>null</code> an empty string is added.
				</p>
				<p>
					Template expressions can occur everywhere. 
					Here is an example showing it in conjunction with the powerful 
					<a href="#switchExpression">	switch expression
					</a>:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def toText(Node n) {
  switch n {
    Contents : n.text

    A : &apos;&apos;&apos;&lt;a href="&laquo;n.href&raquo;"&gt;&laquo;n.applyContents&raquo;&lt;/a&gt;&apos;&apos;&apos;

    default : &apos;&apos;&apos;
        &lt;&laquo;n.tagName&raquo;&gt;
          &laquo;n.applyContents&raquo;
        &lt;/&laquo;n.tagName&raquo;&gt;
    &apos;&apos;&apos;
  }
}</pre>
				</p>
				<!-- subsection -->
				<section id="templateIF">
				<h3>	Conditions in Templates
				</h3>
				<p>
					There is a special 
					<code>IF</code> to be used within templates:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def someHTML(Paragraph p) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;IF p.headLine != null&raquo;
      	&lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
      &laquo;ENDIF&raquo;
      &lt;p&gt;
        &laquo;p.text&raquo;
      &lt;/p&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre>
				</p>
				<!-- subsection -->
				<section id="templateFOREACH">
				<h3>	Loops in Templates
				</h3>
				<p>
					Also a 
					<code>FOR</code> statement is available:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def someHTML(List&lt;Paragraph&gt; paragraphs) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs&raquo;
        &laquo;IF p.headLine != null&raquo;
      	  &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre>
				</p>
				<p>
					The for statement optionally allows to specify what to prepend (
					<code>BEFORE</code>), put in-between (
					<code>SEPARATOR</code>), and what to
					put at the end (
					<code>AFTER</code>) of all iterations. 
					<code>BEFORE</code> and 
					<code>AFTER</code>
					are only executed if there is at least one iteration. (
					<code>SEPARATOR</code>) is only added between
					iterations, that it is executed if there are at least two iterations.
				</p>
				<p>
					Here is an example:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
def someHTML(List&lt;Paragraph&gt; paragraphs) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs BEFORE &apos;&lt;div&gt;&apos; SEPARATOR &apos;&lt;/div&gt;&lt;div&apos; AFTER &apos;&lt;/div&gt;&apos;&raquo;
        &laquo;IF p.headLine != null&raquo;
      	  &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre>
				</p>
				<!-- subsection -->
				<section id="templateType">
				<h3>	Typing
				</h3>
				<p>
					The template expression is of type 
					<a href="http://xtend-lang.org/api/2.3.0/java/lang/CharSequence.html">
						<abbr title="java.lang.CharSequence">CharSequence</abbr>
					</a>
					. It is automatically converted
					to 
					<a href="http://xtend-lang.org/api/2.3.0/java/lang/String.html">
						<abbr title="java.lang.String">String</abbr>
					</a>
					 if that is the expected target type.
				</p>
				<!-- subsection -->
				<section id="WhitespaceHandling">
				<h3>	White Space Handling
				</h3>
				<p>
					One of the key features of templates is the smart handling of white space in the template output. 
					The white space is not written into the output data structure as is but preprocessed. This allows 
					for readable templates as well as nicely formatted output. The following three rules are applied 
					when the template is evaluated:
				</p>
				<p>
					<ol>
						<li>	
							    Indentation in the template that is relative to a control structure will not be propagated 
							    to the output string. A control structure is a 
							<code>FOR</code>-loop or a condition 
							    (
							<code>IF</code>) as well as the opening and closing marks of the rich string itself.
							    
							    The indentation is considered to be relative to such a control structure if the previous 
							    line ends with a control structure followed by optional white space. The amount of white 
							    space is not taken into account but the delta to the other lines.
						</li>
						<li>	
							    Lines that do not contain any static text which is not white space but do contain control 
							    structures or invocations of other templates which evaluate to an empty string, will not 
							    appear in the output.
						</li>
						<li>	
							    Any newlines in appended strings (no matter they are created with template expressions or not) will
								be prepended with the current indentation when inserted.
						</li>
					</ol>
				</p>
				<p>
					Although this algorithm sounds a bit complicated at first it behaves very intuitively. In addition the
					syntax coloring in Eclipse communicates this behavior.
				</p>
				<p>
					<div class="thumbnail">
						<img src="images/Xtend_template_coloring.png" alt="">
					</div>
				</p>
				<p>
					The behavior is best described with a set of examples. The following table assumes a data structure 
					of nested nodes.
				</p>
				<p>
					<table class="table table-bordered table-condensed">
					<tr><td>	
						<pre class="prettyprint lang-xtend linenums">
class Template {
  def print(Node n) &apos;&apos;&apos;
    node &laquo;n.name&raquo; {}
  &apos;&apos;&apos;
}</pre>
						
					</td>
					<td>	
						<pre class="prettyprint lang-xtend linenums">
node NodeName {}</pre>
						
					</td>
					</tr>
					</table>
				</p>
				<p>
					The indentation before 
					<code>node &laquo;n.name&raquo;</code> will be skipped as it is relative to the opening mark of
					the rich string and thereby not considered to be relevant for the output but only for readability 
					of the template itself.
				</p>
				<p>
					<table class="table table-bordered table-condensed">
					<tr><td>	
						<pre class="prettyprint lang-xtend linenums">
class Template {
  def print(Node n) &apos;&apos;&apos;
    node &laquo;n.name&raquo; {
      &laquo;IF hasChildren&raquo;
        &laquo;n.children.map[print]&raquo;
      &laquo;ENDIF&raquo;
    }
  &apos;&apos;&apos;
}</pre>
						
					</td>
					<td>	
						<pre class="prettyprint lang-xtend linenums">
node Parent{
  node FirstChild {
  }
  node SecondChild {
    node Leaf {
    }
  }
}</pre>
						
					</td>
					</tr>
					</table>
				</p>
				<p>
					As in the previous example, there is no indentation on the root level for the same reason.
					The first nesting level has only one indentation level in the output. This is derived from
					the indentation of the 
					<code>IF hasChildren</code> condition in the template which is nested in
					the node. The additional nesting of the recursive invocation 
					<code>children.map[print]</code> is not
					visible in the output as it is relative the the surrounding control structure. The line with
					<code>IF</code> and 
					<code>ENDIF</code> contain only control structures thus they are skipped in 
					the output. Note the additional indentation of the node 
					<strong>	Leaf
					</strong> which happens due to the first rule:
					Indentation is propagated to called templates.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="processedAnnotations">
		<div class="page-header">
			<h1>
					Processed Annotations
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
					Xtend comes with annotations that help to steer the compilation process.
					These annotations reside in the 
					<code>org.eclipse.xtend.lib</code> plug-in/jar which must be on the classpath
					of the project containing the Xtend files. 
				</p>
				<!--  section -->
				<section id="propertyAnnotation">
				<h2>	@Property
				</h2>
				<p>
					For fields that are annotated as 
					<code>@Property</code>, the Xtend compiler will generate a Java field, a
					getter and, if the field is non-final, a setter method. The name of the Java field will be prefixed with 
					an 
					<code>_</code> and have the visibility of the Xtend field. The accessors methods are always 
					<code>public</code>. 
					Thus, an Xtend field
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@Property String name</pre>
				</p>
				<p>
					will compile to the Java code
				</p>
				<p>
					<pre class="prettyprint lang-java linenums">
private String _name;

public String getName() {
  return this._name;
}

public void setName(final String name) {
  this._name = name;
}</pre>
				</p>
				</section>
				<!--  section -->
				<section id="dataAnnotation">
				<h2>	@Data
				</h2>
				<p>
					The annotation 
					<code>@Data</code>, will turn an annotated class into a value object class. A class annotated with 
					<code>@Data</code> 
					has the following effect:
				</p>
				<p>
					<ul>
						<li>	all fields are flagged final,
						</li>
						<li>	getter methods will be generated (if not existent),
						</li>
						<li>	a constructor taking paramaters for all non-initialized fields will be generated (if not existent),
						</li>
						<li>	equals(Object) / hashCode() methods will be generated (if not existent),
						</li>
						<li>	a toString() method will be generated (if not existent).
						</li>
					</ul>
				</p>
				<p>
					Example:
				</p>
				<p>
					<pre class="prettyprint lang-xtend linenums">
@Data class Person {
  String firstName
  String lastName
}</pre>
				</p>
				</section>
			</div>
		</div>
		</section>
	</div>
			<!-- Le javascript
			================================================== -->
			<!-- Placed at the end of the document so the pages load faster -->

			<script src="../bootstrap/js/jquery.min.js"></script>
			<script src="../bootstrap/js/bootstrap.min.js"></script>
		</body>
	</html>
