<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Eclipse Xtend</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- Le styles -->
	<link href="../bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<style type="text/css">
		body {
			padding-top: 20px;
		}
		
		section {
			padding-top: 40px;
		}
		
		div#maincontainer>section {
			padding-top: 90px;
		}
	</style>
	<link href="../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">
	<link href="../bootstrap/../google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../bootstrap/../google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="../bootstrap/../google-code-prettify/lang-xtend.js"></script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
		
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le fav and touch icons -->
	<link rel="shortcut icon" href="../bootstrap/ico/favicon.ico">
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../bootstrap/ico/apple-touch-icon-144-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../bootstrap/ico/apple-touch-icon-114-precomposed.png">
	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../bootstrap/ico/apple-touch-icon-72-precomposed.png">
	<link rel="apple-touch-icon-precomposed" href="../bootstrap/ico/apple-touch-icon-57-precomposed.png">
</head>

<body data-spy="scroll" data-target=".subnav" data-offset="50"  onload="prettyPrint()">
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>
				<a class="brand" href="http://www.xtend-lang.org">Xtend</a>
				<ul class="nav">
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">Introduction <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#Installation">Installation</a></li>
							<li><a href="#GettingStarted">Getting Started</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">Static Typing and Java Interoperability <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#localTypeInference">Type Inference</a></li>
							<li><a href="#conversionRules">Conversion Rules</a></li>
							<li><a href="#javaInteroperability">Interoperability with Java</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">Classes and Members <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#packageDecl">Package Declaration</a></li>
							<li><a href="#imports">Imports</a></li>
							<li><a href="#Xtend_ClassDeclaration">Class Declaration</a></li>
							<li><a href="#constructors">Constructors</a></li>
							<li><a href="#fields">Fields</a></li>
							<li><a href="#methods">Methods</a></li>
							<li><a href="#Annotations">Annotations</a></li>
							<li><a href="#extensionMethods">Extension Methods</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">Expressions <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#Xtend_Expressions_Literals">Literals</a></li>
							<li><a href="#typeCasts">Type Casts</a></li>
							<li><a href="#operators">Infix Operators and Operator Overloading</a></li>
							<li><a href="#blocks">Blocks</a></li>
							<li><a href="#variableDeclaration">Variable Declarations</a></li>
							<li><a href="#featureCalls">Field Access and Method Invocation</a></li>
							<li><a href="#constructorCall">Constructor Call</a></li>
							<li><a href="#lambdas">Lambda Expressions</a></li>
							<li><a href="#ifExpression">If Expression</a></li>
							<li><a href="#switchExpression">Switch Expression</a></li>
							<li><a href="#forLoop">For Loop</a></li>
							<li><a href="#whileExpression">While Loop</a></li>
							<li><a href="#doWhileExpression">Do-While Loop</a></li>
							<li><a href="#Xtend_Expressions_Return">Return Expression</a></li>
							<li><a href="#Xtend_Expressions_Throw">Throwing Exceptions</a></li>
							<li><a href="#Xtend_Expressions_TryCatch">Try, Catch, Finally</a></li>
							<li><a href="#templates">Template Expressions</a></li>
						</ul>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown">Processed Annotations <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li><a href="#propertyAnnotation">@Property</a></li>
							<li><a href="#dataAnnotation">@Data</a></li>
						</ul>
					</li>
				</ul>
				<ul class="nav pull-right">
					<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
				</ul>	
			</div>
		</div>
	</div>
	<div id="maincontainer" class="container">
		<!-- chapter -->
		<section id="Introduction">
		<div class="page-header">
			<h1>
				Introduction
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
				Xtend is a statically-typed programming language which translates to comprehensible Java source code. 
				Syntactically and semantically Xtend has its roots in the Java programming language but improves on many aspects:   <ul>
					<li><strong><a href="#extensionMethods">Extension methods</a></strong> - enhance closed types with new functionality</li>
					<li><strong><a href="#lambdas">Lambda Expressions</a></strong> - concise syntax for anonymous function literals</li>
					<li><strong><a href="#operators">Operator overloading</a></strong> - make your libraries even more expressive</li>
					<li><strong><a href="#switchExpression">Powerful switch expressions</a></strong> - type based switching with implicit casts</li>
					<li><strong><a href="#polymorphicDispatch">Multiple dispatch</a></strong> - a.k.a. polymorphic method invocation</li>
					<li><strong><a href="#templates">Template expressions</a></strong> - with intelligent white space handling</li>
					<li><strong><a href="#Xtend_Expressions">No statements</a></strong> - everything is an expression</li>
					<li><strong><a href="#propertyAccess">Properties</a></strong> - shorthands for accessing and defining getters and setter</li>
					<li><strong>Local type inference</strong> - you rarely need to write down type signatures anymore</li>
					<li><strong>Full support for Java Generics</strong> - including all conformance and conversion rules</li>
					<li><strong>Translates to Java</strong> not bytecode - understand what is going on and use your code for platforms 
					    such as Android or GWT</li>
				</ul>
				The language is not aiming at replacing Java all together. Its <a href="#library">library</a> is just a thin layer on top of the 
				Java Development Kit (JDK) and unlike with other JVM languages there are <a href="#javaInteroperability">zero interoperability</a> issues :
				Everything you write in Xtend interacts with Java exactly as if it were written in Java in the first place.
				At the same time Xtend just much more concise, readable and expressive. Of course, you can call Xtend methods from Java, too, in a completely transparent way. Furthermore, Xtend provides a modern 
				Eclipse-based IDE closely integrated with Eclipse&apos;s Java Development Tools (JDT), including features like call-hierarchies, rename refactoring, 
				debugging and many more.
				</p>
				<!--  section -->
				<section id="Installation">
				<h2>Installation</h2>
				<p>
				Xtend requires Eclipse 3.5 or higher and a Java SDK 5 or higher. The easiest way to install the
				SDK is via <a href="http://marketplace.eclipse.org/content/eclipse-xtend">Eclipse Marketplace</a>. 
				But there&apos;s also a complete Eclipse distribution <a href="http://www.eclipse.org/xtend/index.html#download">available for download
				at http://xtend-lang.org</a>.If you don&apos;t want to use the recommended Eclipse Plug-in, you can compile Xtend code using the 
				<a href="#MavenSupport">Maven plug-in</a>.
				</p>
				<!-- subsection -->
				<section id="MavenSupport">
				<h3>Maven Support</h3>
				<p>
				The <a href="#library">runtime library</a> as well as a plug-in to run the compiler in a Maven build can be be obtained from
				the following maven repository: <a href="http://build.eclipse.org/common/xtend/maven/">http://build.eclipse.org/common/xtend/maven/</a>.Here&apos;s the XML for the repository:
				</p><pre class="prettyprint lang-xtend">
&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;xtend&lt;/id&gt;
    &lt;url&gt;http://build.eclipse.org/common/xtend/maven/&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
  &lt;pluginRepository&gt;
    &lt;id&gt;xtend&lt;/id&gt;
    &lt;url&gt;http://build.eclipse.org/common/xtend/maven/&lt;/url&gt;
  &lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</pre><p>
				Here&apos;s the XML for the dependency to the library:</p><pre class="prettyprint lang-xtend">
&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.xtend&lt;/groupId&gt;
  &lt;artifactId&gt;org.eclipse.xtend.lib&lt;/artifactId&gt;
  &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
				And this is the XML for the plug-in:</p><pre class="prettyprint lang-xtend">
&lt;plugin&gt;
  &lt;groupId&gt;org.eclipse.xtend&lt;/groupId&gt;
  &lt;artifactId&gt;xtend-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.3.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;goals&gt;
        &lt;goal&gt;compile&lt;/goal&gt;
        &lt;!-- &lt;goal&gt;testCompile&lt;/goal&gt; --&gt;
      &lt;/goals&gt;
      &lt;!-- optionally you can configure a different target folder --&gt;
      &lt;!--
      &lt;configuration&gt;
        &lt;outputDirectory&gt;xtend-gen&lt;/outputDirectory&gt;
      &lt;/configuration&gt;
      --&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</pre><p>
				As you see the <strong>outputDirectory</strong> can be specified to match the default of the Eclipse plug-in (<strong>xtend-gen</strong>). Of course you can also change the configuration
				in Eclipse to match the Maven default (<strong>generated-sources</strong>). To do so right-click on the project and select <strong>Properties</strong> or if you prefer a global setting choose <strong>Eclipse-&gt;Preferences</strong>.
				In the category <strong>Xtend/Compiler</strong> enter the directory name (see screenshot). It&apos;s interpreted as a relative path to the parent of the source folder, which includes the to-be-compiled Xtend file.<div class="thumbnail">
					<img src="images/configure-compiler-in-eclipse.png" alt="">
				</div>
				</p>
				<!-- subsection -->
				<section id="library">
				<h3>The Runtime Library</h3>
				<p>
				The compiler requires a small runtime library on the classpath, which mainly provides useful extensions
				to existing classes and interfaces from the JDK. The class <code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.InputOutput</code>
				providing the method <code>&lt;T&gt; T println(T obj)</code> being one of them. The only surprising fact in the generated Java code may be the library class . Many 
				features of Xtend are not built into the language itself but provided via the library
				<strong>org.eclipse.xtend.lib</strong>. The library is available from a <a href="#MavenSupport">Maven repository</a> and via p2
				update site (in case you do Eclipse Plug-In development).The library provides means to create collections in a readable way:</p><pre class="prettyprint lang-xtend">
val myList = newArrayList(1, 2, 3)
val mySet = newHashSet(4, 5, 6)
val myMap = newHashMap(1 -&gt; &apos;one&apos;, 2 -&gt; &apos;two&apos;, 3 -&gt; &apos;three&apos;)</pre><p>
				It also extends the collection types with a lot of very useful functions.
				One example is the ubiquitous <code>map</code> function:</p><pre class="prettyprint lang-xtend">
val listOfNames = listOfPersons.map[ name ]</pre><p>
				Many operators to concat collections or to do arithmetics with types like <code>BigDecimal</code> are also available.You might want to have a look at the <a href="http://xtend-lang.org/api/2.3.0/index.html">JavaDoc API</a> to see what&apos;s
				available.
				</p>
				</section>
				<!--  section -->
				<section id="GettingStarted">
				<h2>Getting Started</h2>
				<p>
				The first thing you want to see in any language is the ubiquitous "Hello World" example. 
				In Xtend, that reads as
				</p><pre class="prettyprint lang-xtend">
class HelloWorld {
  def static void main(String[] args) {
    println("Hello World")
  }
}</pre><p>
				You see that Xtend looks a lot like Java. At a first glance the main difference seems to be the <code>def</code>
				keyword for declaring a method. Also like in Java it&apos;s mandatory to define a class and a main method as the entry point for an application. 
				Admittedly &apos;hello world&apos; programs are not a particular strength of Xtend. The real expressiveness unleashes as soon as you do real stuff
				as you will learn in a moment.An Xtend class resides in a plain Java project. As soon as the SDK is installed, Eclipse will automatically 
				translate it to Java code. By default you&apos;ll find it in a source folder <strong>xtend-gen</strong>, which is of course configurable.
				The hello world example is translated to the following Java code:
				</p><pre class="prettyprint lang-java">
// Generated Java Source Code
import org.eclipse.xtext.xbase.lib.InputOutput;

public class HelloWorld {
  public static void main(final String[] args) {
    InputOutput.&lt;String&gt;println("Hello World");
  }
}</pre><p>
				You can put an Xtend class in source folders of any Java project within Eclipse (or any Maven project). Eclipse will complain
				about the missing library if it&apos;s not on the classpath and provide a quick fix to add it.The next thing you might want to do is materializing one of the example projects into your workspace.
				To do so right click anywhere in the <strong>Navigator</strong> view in Eclipse and select <strong>New -&gt; Example...</strong>.In the upcoming dialog you&apos;ll find two examples for Xtend:<ul>
					<li><strong>Xtend Introductory Examples</strong> contains a couple of example code snippets illustrating certain
					  aspects and strengths of Xtend. 
					  It for instance shows how to build a builder API or an API which allows for writing code like this:
					  <pre class="prettyprint lang-xtend">
assertEquals(42.km/h, (40_000.m + 2.km) / 60.min)</pre>
					
					  Also the <a href="#moviesExample">the movies example</a> explained in detail in <a href="#moviesExample">the next section</a>
					  is included here.</li>
					<li><strong>Xtend Solutions For Euler</strong> contains solutions to a lot of the problems you&apos;ll find at <a href="http://projecteuler.net/">Project Euler's website</a>.
					   These examples are leveraging the whole expressive power of Xtend. For instance <a href="http://projecteuler.net/problem=1">Euler Problem 1</a> can be solved
					   with the following expression :
					   <pre class="prettyprint lang-xtend">
(1..999).filter[ i | i % 3 == 0 || i % 5 == 0].reduce[i1, i2 | i1 + i2]</pre>
					
					   </li>
				</ul>
				</p>
				<!-- subsection -->
				<section id="moviesExample">
				<h3>The Movies Example (src/examples6/Movies.xtend)</h3>
				<p>
				The movies example is included in the example project <strong>Xtend Introductory Examples</strong> and is about reading
				a file with data about movies in and doing some analysis on it.
				</p>
				<!-- subsection -->
				<section id="Section3_0">
				<h4>The Data</h4>
				<p>
				The movie database is a plain text file (data.csv) with data sets describing movies.
				Here&apos;s an example data set:
				</p><pre class="prettyprint lang-xtend">
Naked Lunch  1991  6.9  16578  Biography  Comedy  Drama  Fantasy</pre><p>
				The values are separated by two spaces. The columns are :
				<ol>
					<li>title</li>
					<li>year</li>
					<li>rating</li>
					<li>numberOfVotes</li>
					<li>categories</li>
				</ol>
				
				 
				Let&apos;s define a data type <code>Movie</code> representing a data set:</p><pre class="prettyprint lang-xtend">
@Data class Movie {
  String title
  int year
  double rating
  long numberOfVotes
  Set&lt;String&gt; categories 
}</pre><p>
				It&apos;s a plain class with a typed field for each column in the data sets. The <a href="#dataAnnotation">@Data</a>
				annotation will turn this class into a value object, that is it will get 
				<ul>
					<li>a getter-method for each field,</li>
					<li>a <code>hashCode()</code>/<code>equals()</code> implementation,</li>
					<li>implementation of <code>Object.toString(),</code></li>
					<li>a constructor accepting values for all fields in the declared order.</li>
				</ul>
				</p>
				<!-- subsection -->
				<section id="Section3_1">
				<h4>Parsing The Data</h4>
				<p>
				Let&apos;s now add another class to the same file (any number of <a href="#Xtend_Classes_Members">classes</a> per file is allowed) and initialize a field
				called movies with a list of movies. For the initialization we read in the text file and turn the data sets into <code>Movie</code>s:</p><pre class="prettyprint lang-xtend">
import java.io.FileReader
import java.util.Set
import static extension com.google.common.io.CharStreams.*

class Movies {
  
  val movies = new FileReader(&apos;data.csv&apos;).readLines.map[ line |
    val segments = line.split(&apos;  &apos;).iterator
    return new Movie(
      segments.next, 
      Integer::parseInt(segments.next), 
      Double::parseDouble(segments.next), 
      Long::parseLong(segments.next), 
      segments.toSet
    )
  ]
}</pre><p>
				A <a href="#fields">field&apos;s type</a> can be inferred from the expression on the right hand-side. 
				That&apos;s called local type inference and is supported everyhwere in Xtend.
				We want the field to be final, so we declare it as a value using the keyword <code>val</code>.The initialization on the right hand side first creates a fresh instance of <code>java.io.FileReader</code>.
				Then the method <code>readLines()</code> is invoked on that instance. But if you have a look at <code>FileReader</code> you won&apos;t find
				such a method, because <code>readLines()</code> is in fact a static method from Google Guava&apos;s <code>CharStream</code> which was imported 
				as an <a href="#extensionImports">extension</a>, which allows us to use this readable syntax.</p><pre class="prettyprint lang-xtend">
import static extension com.google.common.io.CharStreams.*</pre><p>
				<code>CharStream.readLines(Reader)</code> returns a <code>List&lt;String&gt;</code> on which we call another extension method called <code>map</code>.
				That one is defined in the <a href="#library">runtime library</a> (<code>ListExtensions.map(...)</code> and is always imported and
				therefore automatically available on all lists. The <code>map</code> extension expects a function as a parameter.
				Map basically invokes that function for each value in the list and returns another list containing the results of the function incovations.Function objects are created using <a href="#lambdas">lambda expression</a> (the code in squared brackets).
				Within the lambda we process a single line from the text file and turn it into a movie by splitting the string using the
				separator (two whitespaces) and calling iterator on the result. As you might know <code>java.lang.String.split(String)</code>
				returns a string array (<code>String[]</code>), which Xtend <a href="#conversionRules">auto-convertes to a list</a> when we 
				call <code>Iterable.iterator()</code> on it.</p><pre class="prettyprint lang-xtend">
val segments = line.split(&apos;  &apos;).iterator</pre><p>
				Now we use the iterator to create an instance of <code>Movie</code>.
				The data type conversion (e.g. <code>String</code> to <code>int</code>) is done by calling <a href="#staticAccess">static methods</a> from the wrapper types. 
				The rest of the iterable is turned into a set using the extension method <code>Iterators.toSet(Iterator&lt;T&gt;)</code>
				and contains all the categories the movie is associated with.</p><pre class="prettyprint lang-xtend">
return new Movie (
  segments.next, 
  Integer::parseInt(segments.next), 
  Double::parseDouble(segments.next), 
  Long::parseLong(segments.next), 
  segments.toSet
)</pre><p>
				</p>
				<!-- subsection -->
				<section id="Section3_2">
				<h4>Answering som Questions</h4>
				<p>
				Now that we&apos;ve the text file turned into a <code>List&lt;Movie&gt;</code>, we are ready to execute some queries against it.
				We use <strong>Junit</strong> to make the individual analysis executable.
				</p>
				<!-- subsection -->
				<section id="Section4_3">
				<h5>What&apos;s The Number Of Action Movies?</h5>
				<p>
				</p><pre class="prettyprint lang-xtend">
@Test def numberOfActionMovies() {
  assertEquals(828, 
    movies.filter[categories.contains(&apos;Action&apos;)].size)
}</pre><p>
				First the movies are <code>filter</code>ed. The lambda expression checks whether the current movie&apos;s categories contains 
				the entry <code>&apos;Action&apos;</code>. Note that unlike the lambda we used to turn the lines in the file into movies, we 
				haven&apos;t declared a parameter name this time. 
				We could have written 
				</p><pre class="prettyprint lang-xtend">
movies.filter[ movie | movie.categories.contains(&apos;Action&apos;)].size</pre><p>
				
				but since we left out the name and the vertical bar the variable is automatically named <code>it</code> which
				(like <code>this</code>) is an <a href="#implicitVariables">implicit variable</a>. That&apos;s why we can write either</p><pre class="prettyprint lang-xtend">
movies.filter[ it.categories.contains(&apos;Action&apos;)].size</pre><p>
				
				or 
				</p><pre class="prettyprint lang-xtend">
movies.filter[categories.contains(&apos;Action&apos;)].size</pre><p>
				.Lastly we call <code>size</code> on the resulting iterable, which also is an extension method defined in 
				<code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.IterableExtensions</code>.
				</p>
				<!-- subsection -->
				<section id="Section4_4">
				<h5>Question 2: What&apos;s The Year The Best Movie From The 80ies Was Released?</h5>
				<p>
				</p><pre class="prettyprint lang-xtend">
@Test def void yearOfBestMovieFrom80ies() {
  assertEquals(1989, 
    movies.filter[(1980..1989).contains(year)].sortBy[rating].last.year)
}</pre><p>
				Here we <code>filter</code> all movies where the year is not included in the range from 1980 to 1989 (the 80ies).
				The <code>..</code> operator again is an extension defined in <code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.IntegerExtensions</code> and returns an instanceof <code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.IntegerRange</code>.
				Operator overloading is explained in <a href="#operators">section</a>.The resulting iterable is sorted (<code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.IterableExtensions</code><code>.sortBy</code>) by the <code>rating</code> of the movies. 
				Since it&apos;s sorted in ascending order, we take the last movie from the list and return its <code>year</code>. We could have sorted descending and take the head of the list as well:
				</p><pre class="prettyprint lang-xtend">
movies.filter[(1980..1989).contains(year)].sortBy[-rating].head.year</pre><p>
				Note that first sorting and then taking the last or first is slightly more expnsive than needed. We could
				have used the method <code>reduce</code> instead to find the best movie, which would be more efficient. Maybe
				you want to try it on your own?The calls to <code>movie.year</code> as well as <code>movie.categories</code> in the previous example in fact access the corresponding 
				<a href="#propertyAccess">getter methods</a>.
				</p>
				<!-- subsection -->
				<section id="Section4_5">
				<h5>Question 3: What&apos;s The The Sum Of All Votes Of The Top Two Movies?</h5>
				<p>
				</p><pre class="prettyprint lang-xtend">
@Test def void sumOfVotesOfTop2() {
  val long sum = movies.sortBy[-rating].take(2).map[numberOfVotes].reduce[a, b| a + b]
  assertEquals(47_229L, sum)
}</pre><p>
				First the movies are sorted by rating, then we take the best two. Next the list of movies is turned into a list of their <code>numberOfVotes</code> using the <code>map</code> function. 
				Now we have a <code>List&lt;Long&gt;</code> which can be reduced to a single <code>Integer</code> by adding the values.You could also use <code>reduce</code> instead of <code>map</code> and <code>reduce</code>. Do you know how?
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="types">
		<div class="page-header">
			<h1>
				Static Typing and Java Interoperability
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
				Xtend, like Java, is a statically typed language. In fact it completely supports Java&apos;s type system, including the primitive types 
				as <code>int</code> or <code>boolean</code>, arrays and of course all classes, interfaces, enums and annotations that reside on the 
				classpath.  Java Generics are fully supported as well: You can define type parameters on methods and classes and pass type arguments to
				generic types just as you are used to from Java. The type system and its conformance and casting rules are implemented after 
				<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html">the Java Language Specification</a>.
				</p>
				<!--  section -->
				<section id="localTypeInference">
				<h2>Type Inference</h2>
				<p>
				One of the problems with Java is, that you are forced to write type signatures over
				and over again. That&apos;s why so many people don&apos;t like static typing. 
				This is in fact not a problem of static typing but simply a problem with Java. Although Xtend is typed
				just like Java, you rarely have to write types down because they can be computed from the context.
				</p>
				</section>
				<!--  section -->
				<section id="conversionRules">
				<h2>Conversion Rules</h2>
				<p>
				In addition to Java&apos;s autoboxing to convert primitives to their corresponding wrapper types (e.g. <code>int</code>
				is automatically converted to <code>Integer</code> when needed), there are additional conversion rules.Arrays are automatically converted to <code>java.util.List&lt;ComponentType&gt;</code> and vice versa. That is you can
				write the following:</p><pre class="prettyprint lang-xtend">
def toList(String[] array) {
  val List&lt;String&gt; asList = array
  return asList
}</pre><p>
				Another very useful conversion applies to lambda expressions. As explained in the previous section, a lambda expression
				usually is of one of the types listed in <code>org.eclipse.xtext.xbase.lib.Functions</code>
				or <code>org.eclipse.xtext.xbase.lib.Predicates</code>. However if the expected type is an interface which has just method
				declaration, a lambda expression is automatically converted to that
				type. This allows to use lambda expressions with many existing Java libraries. See section <a href="#closureTypes"></a>
				for more details.
				</p>
				</section>
				<!--  section -->
				<section id="javaInteroperability">
				<h2>Interoperability with Java</h2>
				<p>
				Resembling and supporting every aspect of Java&apos;s type system, ensures that there is no impedeance mismatch between Java and Xtend.
				This means that Xtend and Java are 100% interoperable and that there are no special cases and no thinking
				in two worlds is neccessary. You can call Xtend code from Java and vice versa without any surprises or hassles.As a bonus if you know Java&apos;s type system (specifically generics), you already know the most complicated part
				of Xtend.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="Xtend_Classes_Members">
		<div class="page-header">
			<h1>
				Classes and Members
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
				At a first glance an Xtend file pretty much looks like a Java file. It starts with a package 
				declaration followed by an import section and a class definition.
				The class in fact is directly translated to a Java class in the corresponding Java package.
				A class can have constructors, fields and methods. Here is an example:
				</p><pre class="prettyprint lang-xtend">
package com.acme

import java.util.List

class MyClass {
  String name
  
  new(String name) {
    this.name = name
  }
  
  def String first(List&lt;String&gt; elements) {
    elements.get(0)
  }
}</pre><p>
				</p>
				<!--  section -->
				<section id="packageDecl">
				<h2>Package Declaration</h2>
				<p>
				Package declarations look like in Java. There are two small differences: 
				<ul>
					<li>An identifier can be escaped with a <code>^</code> character in case it conflicts with a keyword.</li>
					<li>The terminating semicolon is optional.</li>
				</ul>
				</p><pre class="prettyprint lang-xtend">
package com.acme</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="imports">
				<h2>Imports</h2>
				<p>
				The ordinary imports of type names are equivalent to the imports known from Java. 
				Again one can escape any names conflicting with keywords using a <code>^</code>. In contrast to Java, the 
				terminating semicolon is optional. Xtend also features static imports but 
				allows only a wildcard <code>*</code> at the end, i.e. you currently cannot import single members using a static 
				import. Non-static wildcard imports are deprecated for the benefit of better tooling. As in Java all classes from the <code>java.lang</code> package are implicitly imported.
				</p><pre class="prettyprint lang-xtend">
import java.math.BigDecimal
import static java.util.Collections.*</pre><p>
				Static methods of helper classes can also be imported as <strong>extensions</strong>. See the section on 
				<a href="#extensionMethods">extension methods</a> for details.
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_ClassDeclaration">
				<h2>Class Declaration</h2>
				<p>
				The class declaration reuses a lot of Java&apos;s syntax but still is a bit different in some aspects:
				Java&apos;s default "package private" visibility does not exist in Xtend. As an Xtend class is compiled to
				a top-level Java class and Java does not allow <code>private</code> or <code>protected</code> top-level
				classes any Xtend class is <code>public</code>. It is possible to write <code>public</code> explicitly. Since version 2.3, multiple class declaration per file are supported. Each of these classes
				is compiled to a separate top-level Java class.Abstract classes are defined using the <code>abstract</code> modifier as in Java. See also <a href="#abstractMethods"></a> 
				on abstract methods.Xtend&apos;s approach to inheritance is conceptionally the same as in Java. Single inheritance of 
				classes as well as implementing multiple interfaces is supported. 
				Xtend classes can of course extend other Xtend classes, and even Java classes can inherit from Xtend classes. The most simple class looks like this:
				</p><pre class="prettyprint lang-xtend">
class MyClass {
}</pre><p>
				A more advanced generic class declaration in Xtend:
				</p><pre class="prettyprint lang-xtend">
class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, 
                   Cloneable, java.io.Serializable {
  ...
}</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="constructors">
				<h2>Constructors</h2>
				<p>
				An Xtend class can define one or more constructors. Unlike Java you don&apos;t have to repeat the name of the class over and over again,
				but use keyword <strong>new</strong> to declare a constructor.
				Constructors can also delegate to other constructors using <code>this(args...)</code> in their first
				line. 
				</p><pre class="prettyprint lang-xtend">
class MyClass extends AnotherClass {
  new(String s) {
    super(s)
  }
  
  new() {
    this("default")
  }
}</pre><p>
				The same rules with regard to inheritance apply as in Java, i.e. if the super class does not define a 
				no-argument constructor, you have to explicitly call one using <code>super(args...)</code> as the first 
				expression in the body of the constructor.The default visibility of constructors is <code>public</code> but you can also specify <code>protected</code>
				or <code>private</code>.
				</p>
				</section>
				<!--  section -->
				<section id="fields">
				<h2>Fields</h2>
				<p>
				A field can have an initializer. Final fields are declared using <code>val</code>, while 
				<code>var</code> introduces a non-final field and can be ommitted. Yet, if an initializer expression
				is present, the type of a field can be skipped after <code>val</code> and <code>var</code>.
				Fields marked as <code>static</code> will be compiled to static Java fields.  </p><pre class="prettyprint lang-xtend">
class MyClass {
  int count = 1
  static boolean debug = false
  var name = &apos;Foo&apos;          // type String is inferred 
  val UNIVERSAL_ANSWER = 42 // final field with inferred type int
  ...
}</pre><p>
				The default visibility is <code>private</code>. You can also declare it explicitly as 
				being <code>public</code>, <code>protected</code>, or <code>private</code>. A specialty of Xtend are fields that provide <strong>extension methods</strong> which are covered in 
				<a href="#extensionMethods">their own section</a>.
				</p>
				</section>
				<!--  section -->
				<section id="methods">
				<h2>Methods</h2>
				<p>
				Xtend methods are declared within a class and are translated to a corresponding Java method with 
				exactly the same signature. The only exceptions are dispatch methods, which are explained 
				<a href="#polymorphicDispatch">in section</a>. 
				</p><pre class="prettyprint lang-xtend">
def String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre><p>
				The default visibility of a plain method is <code>public</code>. You can explicitly declare it as
				being <code>public</code>, <code>protected</code>, or <code>private</code>.Xtend supports the <code>static</code> modifier for methods:
				</p><pre class="prettyprint lang-xtend">
def static createInstance() {
  new MyClass(&apos;foo&apos;)
}</pre><p>
				As in Java 5, Xtend allows vararg parameters:
				</p><pre class="prettyprint lang-xtend">
def printAll(String... strings) {
  strings.forEach[s | println(s)]
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="abstractMethods">
				<h3>Abstract Methods</h3>
				<p>
				An abstract method in Xtend just does not define a body and must be declared within an <code>abstract</code>
				class. Also specifying the return type is mandatory since it cannot be inferred. </p><pre class="prettyprint lang-xtend">
abstract class MyAbstractClass() {
	def String abstractMethod() // no body
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="Section2_6">
				<h3>Overriding Methods</h3>
				<p>
				Methods can override other methods from the super class or implemented interface methods using the
				keyword <code>override</code>. If a method overrides a method from a super type, the 
				<code>override</code> keyword is mandatory and replaces the keyword <code>def</code>. As in Java 
				<code>final</code> methods cannot be overridden by subclasses.Example:
				</p><pre class="prettyprint lang-xtend">
override String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="declaredExceptions">
				<h3>Declared Exceptions</h3>
				<p>
				Xtend does not force you to catch or redeclare checked exceptions. Nevertheless, you can still declare 
				the exceptions thrown in a method&apos;s body using the same <code>throws</code> clause as in Java.If you don&apos;t declare checked exceptions in your method but they are possibly thrown in your code, the
				compiler will rethrow the checked exception silently (using the sneaky-throw technique introduced by 
				<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>). 
				  
				</p><pre class="prettyprint lang-xtend">
/*
 * throws an Exception
 */
def void throwException() throws Exception {
   throw new Exception
}

/*
 * throws an Exception without declaring it
 */
def void sneakyThrowException() {
   throw new Exception
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="inferredReturnTypes">
				<h3>Inferred Return Types</h3>
				<p>
				If the return type of a method can be inferred from its body it does not have to be declared.That is the method
				</p><pre class="prettyprint lang-xtend">
def String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre><p>
				could be declared like this:
				</p><pre class="prettyprint lang-xtend">
def first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre><p>
				This does not work for abstract method declarations as well as if the return type of a method 
				depends on a recursive call of the same method.
				</p>
				<!-- subsection -->
				<section id="genericMethods">
				<h3>Generic Methods</h3>
				<p>
				You can specify type parameters just like in Java. To generalize the method from the previous section,
				you would declare it like this:</p><pre class="prettyprint lang-xtend">
def &lt;T&gt; first(List&lt;T&gt; elements) {
  elements.get(0)
}</pre><p>
				Also bounds and the like are supported and share the same syntax as defined in the 
				<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.4.4">the Java Language Specification</a>
				</p>
				<!-- subsection -->
				<section id="polymorphicDispatch">
				<h3>Dispatch Methods</h3>
				<p>
				Generally, method binding works just like method binding in Java. Method calls are bound 
				based on the static types of arguments. Sometimes this is not what you want. Especially in the 
				context of <a href="#extensionMethods">extension methods</a> you would like to have polymorphic behavior.A dispatch method is marked using the keyword <code>dispatch</code>.
				</p><pre class="prettyprint lang-xtend">
def dispatch printType(Number x) { 
  "it&apos;s a number" 
}

def dispatch printType(Integer x) { 
  "it&apos;s an int" 
}</pre><p>
				For a set of visible dispatch methods in the current type hierarchy charing the same name and the same
				number of arguments, the compiler infers a synthetic method (the dispatcher) using the common super type of all declared arguments.
				The actual dispatch methods are reduced in visibility and renamed (prepending an underscore) so that client code always binds to
				the dispatcher method.For the two dispatch methods in the example above the following Java code would be generated:
				</p><pre class="prettyprint lang-java">
protected String _printType(final Number x) {
  return "it\&apos;s a number";
}

protected String _printType(final Integer x) {
  return "it\&apos;s an int";
}

public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre><p>
				Note that the <code>instanceof</code> cascade is ordered such that more specific types come first.The default visibility of the underscore methods is <code>protected</code>. If all dispatch methods
				explicitly declare the same visibility, this will be the visibility of the inferred dispatcher, too.
				Otherwise it is <code>public</code>.
				 
				The comparism of the type parameters goes from left to right. That is in the following example, the second
				method declaration is considered more specific since its first parameter type is the most specific:</p><pre class="prettyprint lang-xtend">
def dispatch printTypes(Number x, Integer y) { 
  "it&apos;s some number and an int" 
}

def dispatch printTypes(Integer x, Number y) { 
  "it&apos;s an int and a number" 
}</pre><p>
				generates the following Java code :
				</p><pre class="prettyprint lang-java">
public String printTypes(final Number x, final Number y) {
  if (x instanceof Integer
       && y != null) {
    return _printTypes((Integer)x, y);
  } else if (x != null
       && y instanceof Integer) {
    return _printTypes(x, (Integer)y);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x, y).toString());
  }
}</pre><p>
				As you can see a <code>null</code> reference is never a match. If you want to fetch <code>null</code> 
				you can declare a dispatch case using the type <code>java.lang.Void</code>.
				</p><pre class="prettyprint lang-xtend">
def dispatch printType(Number x) { 
  "it&apos;s some number" 
}

def dispatch printType(Integer x) { 
  "it&apos;s an int" 
}

def dispatch printType(Void x) { 
  "it&apos;s null" 
}</pre><p>
				This compiles to the following Java code:
				</p><pre class="prettyprint lang-java">
public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else if (x == null) {
    return _printType((Void)null);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="Section3_7">
				<h4>Dispatch Methods and Inheritance</h4>
				<p>
				Any visible Java methods from super types conforming to the compiled form of a dispatch method are
				also included in the dispatch. Conforming means they have the right number of arguments and have 
				the same name (starting with an underscore).For example, consider the following Java class :
				</p><pre class="prettyprint lang-java">
public abstract class AbstractLabelProvider {
   protected String _label(Object o) {
      // some generic implementation
   }
}</pre><p>
				and the following Xtend class which extends the Java class :
				</p><pre class="prettyprint lang-xtend">
class MyLabelProvider extends AbstractLabelProvider {
   def dispatch label(Entity it)  {
     name
   }
     
   def dispatch label(Method it) { 
     name+"("+params.join(",")+"):"+type
   }
   
   def dispatch label(Field it) { 
     name+type
   }
}</pre><p>
				The resulting dispatch method in the generated Java class <code>MyLabelProvider</code> would then look like this:
				</p><pre class="prettyprint lang-java">
public String label(final Object it) {
  if (it instanceof Entity) {
    return _label((Entity)it);
  } else if (it instanceof Field) {
    return _label((Field)it);
  } else if (it instanceof Method) {
    return _label((Method)it);
  } else if (it != null) {
    return super._label(it);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(it).toString());
  }
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="Section3_8">
				<h4>Static Dispatch Methods</h4>
				<p>
				Also static dispatch methods are supported. But you cannot mix static and non-static
				dispatch methods.
				</p>
				</section>
				<!--  section -->
				<section id="Annotations">
				<h2>Annotations</h2>
				<p>
				The syntax and semantics for annotations is exactly like defined in the 
				<a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java Language Specification</a>. 
				Annotations are available on classes, fields, methods and parameters. Here is an example:</p><pre class="prettyprint lang-xtend">
@TypeAnnotation("some value")
class MyClass {
  @FieldAnnotation(children = {@MyAnno(true), @MyAnno(false)})
  String myField
  
  @MethodAnnotation(children = {@MyAnno(true), @MyAnno})
  def String myMethod(@ParameterAnnotation String param) {
    //...
  }
}</pre><p>
				Certain annotations defined in the library have a special effect on how the code is translated to Java.
				These annotations are explained in <a href="#processedAnnotations">section</a>.
				</p>
				</section>
				<!--  section -->
				<section id="extensionMethods">
				<h2>Extension Methods</h2>
				<p>
				Extension methods allow to add new methods to existing types without modifying them. 
				This feature is actually where Xtend got its name from. They are based on a simple syntactic trick: 
				Instead of passing the first argument of an extension method inside the parentheses of a call, the 
				method is called on the argument parameter as if it was one of its members.
				</p><pre class="prettyprint lang-xtend">
"hello".toFirstUpper() // calls toFirstUper("hello")</pre><p>
				Method calls in extension syntax often result in more readable code, as method calls are chained rather than nested. 
				Another benefit of extensions is that you can add methods which are specific to a certain context
				(read layer) only. You might for instance not want to put UI-specific methods and dependencies to your
				domain model classes. Therefore such functionality is often defined in static methods or methods in
				some "service class". That works, but the code is less readable and object-oriented if you call methods
				like this. In Java for instance you often see code like this:</p><pre class="prettyprint lang-java">
persistenceManager.save(myObject);</pre><p>
				With extension methods you can write it like so:</p><pre class="prettyprint lang-xtend">
myObject.save</pre><p>
				There are different ways to make methods available as extensions, which are described in the following.
				</p>
				<!-- subsection -->
				<section id="libraryExtensions">
				<h3>Extensions From The Library</h3>
				<p>
				The <a href="#library">library</a> puts a lot of very useful extension methods on existing types from the Java
				SDK without any further ado.</p><pre class="prettyprint lang-xtend">
"hello".toFirstUpper // calls StringExtensions.toFirstUpper(String)
listOfStrings.map[toUpperCase] // calls ListExtensions.&lt;T, R&gt;map(List&lt;T&gt; list, Function&lt;? super T, ? extends R&gt; mapFunction)</pre><p>
				Have a look at the Java doc to see what&apos;s there:<ul>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.ObjectExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.IterableExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.MapExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.ListExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.CollectionExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.BooleanExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.IntegerExtensions</code></li>
					<li><code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.FunctionExtensions</code></li>
				</ul>
				</p>
				<!-- subsection -->
				<section id="Section2_9">
				<h3>Local Extension Methods</h3>
				<p>
				All visible non-static methods of the current class and its super types are automatically available as extensions. For example
				</p><pre class="prettyprint lang-xtend">
class MyClass {
  def doSomething(Object obj) {
    // do something with obj
  }
  
  def extensionCall(Object obj) {
    obj.doSomething()  // calls this.doSomething(obj)
  }
}</pre><p>
				Local static methods have to be made available through an import like any other static method.
				</p>
				<!-- subsection -->
				<section id="extensionImports">
				<h3>Extension Imports</h3>
				<p>
				In Java, you would usually write a helper class with static methods to decorate an existing
				class with additional behavior. In order to integrate such static helper classes, Xtend allows to put
				the keyword <code>extension</code> after the <code>static</code> keyword of a <a href="#imports">static import</a>
				thus making all imported static functions available as extensions methods.The following import declaration 
				</p><pre class="prettyprint lang-xtend">
import static extension java.util.Collections.*</pre><p>
				allows to use its methods like this:
				</p><pre class="prettyprint lang-xtend">
new MyClass().singletonList() 
  // calls Collections.singletonList(new MyClass())</pre><p>
				</p>
				<!-- subsection -->
				<section id="Extension_Fields">
				<h3>Extension Fields</h3>
				<p>
				By adding the <code>extension</code> keyword to a field declaration, its instance methods become extension methods.Imagine you want to have some layer specific functionality on a class <code>Person</code>. Let&apos;s say you are in a servlet-like class
				and want to persist a <code>Person</code> using some persistence mechanism. Let&apos;s assume <code>Person</code> implements
				a common interface <code>Entity</code>.
				 
				You could have the following interface
				</p><pre class="prettyprint lang-java">
interface EntityPersistence {
  public save(Entity e);
  public update(Entity e);
  public delete(Entity e);
}</pre><p>
				And if you have obtained an instance of that type (through a factory or dependency injection or what ever) like this:
				</p><pre class="prettyprint lang-xtend">
class MyServlet {
  extension EntityPersitence ep = Factory.get(typeof(EntityPersistence))
  ...
  
}</pre><p>
				You are able to save, update and delete any entity like this:</p><pre class="prettyprint lang-xtend">
val Person person = ...
person.save  // calls ep.save(person)
person.name = &apos;Horst&apos;
person.update  // calls ep.update(person)
person.delete  // calls ep.delete(person)</pre><p>
				Using the <code>extension</code> modifier on fields has a significant advantage over 
				static <a href="#extensionImports">extension imports</a>: Your code is not bound to the actual implementation of the extension method.
				You can simply exchange the component that provides the referenced extension with another implementation from outside,
				by providing a different instance. No matter you do so via a factory, dependency injection or simply
				using a setter.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="Xtend_Expressions">
		<div class="page-header">
			<h1>
				Expressions
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
				Xtend there are no statements. Instead, everything is an expression and has a return value. That
				allows to compose your code in intersting ways. For example, you can have a
				<code>try catch</code> expression on the right hand side of an assignment: 
				</p><pre class="prettyprint lang-xtend">
val data = try {
    fileContentsToString(&apos;data.txt&apos;)
  } catch (IOException e) {
  &apos;dummy data&apos;
  }</pre><p>
				If <code>fileContentsToString()</code> throws an <code>IOException</code>, it is caught and the string <code>&apos;dummy data&apos;</code> is assigned to the value <code>data</code>.
				 
				Expressions can appear as <a href="#fields">initializers of fields</a>, the body of constructors
				or methods and as values in annotations. A method body can either be a <a href="#blocks">block expression</a> 
				or a <a href="#templates">template expression</a>.
				</p>
				<!--  section -->
				<section id="Xtend_Expressions_Literals">
				<h2>Literals</h2>
				<p>
				A literal denotes a fixed unchangeable value. Literals for <a href="#stringLiterals">strings</a>, <a href="#numberLiterals">numbers</a>, <a href="#booleanLiteral">booleans</a>,
				<code>null</code> and <a href="#typeLiteral">Java types</a> are supported.
				</p>
				<!-- subsection -->
				<section id="stringLiterals">
				<h3>String Literals</h3>
				<p>
				A string literal is of type <code>java.lang.String</code> (just like in Java).
				String literals are enclosed by a pair of single quotes or double quotes. We mostly use single quotes
				because the signal-to-noise ration is a bit better, but generally you should use the terminals which are
				least likely occure in the actual string. Special characters can be quoted with a backslash or defined using
				Java&apos;s unicode notation. Contrary to Java, strings can span multiple lines.</p><pre class="prettyprint lang-xtend">
&apos;Hello World !&apos;
"Hello World !"
&apos;Hello "World" !&apos;
"Hello \"World\" !"
&apos;\u00a1Hola el mundo!&apos;
"Hello 

  World !"</pre><p>
				</p>
				<!-- subsection -->
				<section id="numberLiterals">
				<h3>Number Literals</h3>
				<p>
				Xtend supports roughly the same number literals as Java with a few differences.   
				First, there are no signed number literals. If you put a minus operator in front of an number 
				literal it is taken as a <a href="#operators">UnaryOperator</a> with one argument (the positive number 
				literal). Second, as in Java 7, you can separate digits using <code>_</code> for better readability
				of large numbers.
				 
				An integer literal creates an <code>int</code>, a <code>long</code> (suffix <code>L</code>) or a
				<code class="prettyprint lang-java">java.math.BigInteger</code> (suffix <code>BI</code>). There are no octal numbers</p><pre class="prettyprint lang-xtend">
42
1_234_567_890 
0xbeef    // hexadecimal
077       // decimal 77 (*NOT* octal)
-1  // an expression consisting of the unary - operator and an integer literal  
42L
0xbeef#L // hexadecimal, mind the &apos;#&apos;
0xbeef_beef_beef_beef_beef#BI // BigInteger</pre><p>
				A floating-point literal creates a <code>double</code> (suffix <code>D</code> or none), a <code>float</code> 
				(suffix <code>F</code>) or a <code class="prettyprint lang-java">java.math.BigDecimal</code> (suffix <code>BD</code>). If you use a <code>.</code> you have to 
				specify both, the integer and the fractional part of the mantissa. There are only decimal floating-point 
				literals.  
				</p><pre class="prettyprint lang-xtend">
42d     // double
0.42e2  // implicit double
0.42e2f // float
4.2f    // float
0.123_456_789_123_456_789_123_456_789e2000bd // BigDecimal</pre><p>
				</p>
				<!-- subsection -->
				<section id="booleanLiteral">
				<h3>Boolean Literals</h3>
				<p>
				There are two boolean literals, <code>true</code> and <code>false</code> which correspond to their 
				Java counterpart of type <code>boolean</code>. 
				</p>
				<!-- subsection -->
				<section id="nullLiteral">
				<h3>Null Literal</h3>
				<p>
				The null pointer literal is <code>null</code> has exactly the same semantics as in Java.
				</p>
				<!-- subsection -->
				<section id="typeLiteral">
				<h3>Type Literals</h3>
				<p>
				Type literals are specified using the keyword <code>typeof</code> :
				</p><pre class="prettyprint lang-xtend">
typeof(java.lang.String) // yields java.lang.String.class</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="typeCasts">
				<h2>Type Casts</h2>
				<p>
				A type cast behaves exactly like casts in Java, but has a slightly more readable syntax.
				Type casts bind stronger than any other operator but weaker than feature calls.The conformance rules for casts are defined in the 
				<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5">Java Language Specification</a>.
				Here are some examples:
				</p><pre class="prettyprint lang-xtend">
something as MyClass
42 as Integer</pre><p>
				Although casts are supported you might want to use a <a href="#switchExpression">switch with a type guard</a> as a better and safer alternative.
				</p>
				</section>
				<!--  section -->
				<section id="operators">
				<h2>Infix Operators and Operator Overloading</h2>
				<p>
				There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
				to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
				operators for any type just by implementing the corresponding method signature. As an example, the 
				<a href="#library">Xtend runtime library</a> contains a class <code>BigDecimalExtensions</code> that defines operators for 
				<code>BigDecimals</code> which allows the following code:
				</p><pre class="prettyprint lang-xtend">
val x = 2.71BD
val y = 3.14BD
val sum = x + y    // calls BigDecimalExtension.operator_plus(x,y)</pre><p>
				This is the complete list of all available operators and their corresponding method signatures.<table class="table table-bordered table-condensed">
				<tr><td><code>e1 += e2</code></td>
				<td><code>e1.operator_add(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 || e2</code></td>
				<td><code>e1.operator_or(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 && e2</code></td>
				<td><code>e1.operator_and(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 == e2</code></td>
				<td><code>e1.operator_equals(e2)</code></td>
				</tr>
				<tr><td><code>e1 != e2</code></td>
				<td><code>e1.operator_notEquals(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 &lt; e2</code></td>
				<td><code>e1.operator_lessThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &gt; e2</code></td>
				<td><code>e1.operator_greaterThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &lt;= e2</code></td>
				<td><code>e1.operator_lessEqualsThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &gt;= e2</code></td>
				<td><code>e1.operator_greaterEqualsThan(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 -&gt; e2</code></td>
				<td><code>e1.operator_mappedTo(e2)</code></td>
				</tr>
				<tr><td><code>e1 .. e2</code></td>
				<td><code>e1.operator_upTo(e2)</code></td>
				</tr>
				<tr><td><code>e1 =&gt; e2</code></td>
				<td><code>e1.operator_doubleArrow(e2)</code></td>
				</tr>
				<tr><td><code>e1 &lt;&lt; e2</code></td>
				<td><code>e1.operator_doubleLessThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &gt;&gt; e2</code></td>
				<td><code>e1.operator_doubleGreaterThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &lt;&lt;&lt; e2</code></td>
				<td><code>e1.operator_tripleLessThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &gt;&gt;&gt; e2</code></td>
				<td><code>e1.operator_tripleGreaterThan(e2)</code></td>
				</tr>
				<tr><td><code>e1 &lt;&gt; e2</code></td>
				<td><code>e1.operator_diamond(e2)</code></td>
				</tr>
				<tr><td><code>e1 ?: e2</code></td>
				<td><code>e1.operator_elvis(e2)</code></td>
				</tr>
				<tr><td><code>e1 &lt;=&gt; e2</code></td>
				<td><code>e1.operator_spaceship(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 + e2</code></td>
				<td><code>e1.operator_plus(e2)</code></td>
				</tr>
				<tr><td><code>e1 - e2</code></td>
				<td><code>e1.operator_minus(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>e1 * e2</code></td>
				<td><code>e1.operator_multiply(e2)</code></td>
				</tr>
				<tr><td><code>e1 / e2</code></td>
				<td><code>e1.operator_divide(e2)</code></td>
				</tr>
				<tr><td><code>e1 % e2</code></td>
				<td><code>e1.operator_modulo(e2)</code></td>
				</tr>
				<tr><td><code>e1 ** e2</code></td>
				<td><code>e1.operator_power(e2)</code></td>
				</tr>
				<tr><td></td>
				<td></td>
				</tr>
				<tr><td><code>! e1</code></td>
				<td><code>e1.operator_not()</code></td>
				</tr>
				<tr><td><code>- e1</code></td>
				<td><code>e1.operator_minus()</code></td>
				</tr>
				</table>
				
				    
				The table above also defines the operator precedence in ascending order. The blank lines separate 
				precedence levels. The assignment operator <code>+=</code> is right-to-left associative in the same way 
				as the plain assignment operator <code>=</code> is. That is a = b = c is executed as a = (b = c), all
				other operators are left-to-right associative. Parenthesis can be used to adjust the default 
				precedence and associativity. 
				</p>
				<!-- subsection -->
				<section id="Section2_10">
				<h3>Short-Circuit Boolean Operators</h3>
				<p>
				If the operators <code>||</code> and <code>&&</code> are bound to the library methods 
				<code>BooleanExtensions.operator_and(boolean l, boolean r)</code> resp. 
				<code>BooleanExtensions.operator_or(boolean l, boolean r)</code> the operation is evaluated in short circuit mode.
				That means that the right hand operand might not be evaluated at all in the following cases: 
				<ol>
					<li>in the case of <code>||</code> the operand on the right hand side is not evaluated if the left 
					    operand evaluates to <code>true</code>.</li>
					<li>in the case of <code>&&</code> the operand on the right hand side is not evaluated if the left 
					    operand evaluates to <code>false</code>.</li>
				</ol>
				Still you can overload these operators for your types or even override it for booleans, in which case
				both operands are always evaluated and the defined method is invoked, i.e. no short-circuit execution is happening.
				</p>
				<!-- subsection -->
				<section id="Section2_11">
				<h3>Examples</h3>
				<p>
				</p><pre class="prettyprint lang-xtend">
my.property = 23
myList += 23
x &gt; 23 && y &lt; 23
x && y || z
1 + 3 * 5 * (- 23)
!(x)</pre><p>
				</p>
				<!-- subsection -->
				<section id="assignments">
				<h3>Assignments</h3>
				<p>
				<a href="#variableDeclaration">Local variables</a> can be reassigned using the <code>=</code> operator. </p><pre class="prettyprint lang-xtend">
var greeting = &apos;Hello&apos;
if (isInformal)
  greeting = &apos;Hi&apos;</pre><p>
				Of course, also non-final fields can be set using an assignment: 
				</p><pre class="prettyprint lang-xtend">
myObj.myField = &apos;foo&apos;</pre><p>
				</p>
				<!-- subsection -->
				<section id="propertyAssignments">
				<h4>Setting Properties</h4>
				<p>
				The lack of properties in Java leads to a lot of syntactic noise when working with data objects.
				As Xtend is designed to integrate with existing Java APIs it respects the Java Beans convention,
				hence you can call a setter using an assignment:</p><pre class="prettyprint lang-java">
myObj.myProperty = &apos;foo&apos; // calls myObj.setMyProperty("foo")</pre><p>
				The setter is only used if the field is not accessible from the given context. That&apos;s why the 
				<a href="#propertyAnnotation">@Property annotation</a> would rename the local field to <code>_myProperty</code>.The return type of an assignment is the type of the right hand side, in case it&apos;s a simple assignment.
				If it&apos;s translated to a setter method it yields whatever the setter method returns.
				</p>
				</section>
				<!--  section -->
				<section id="blocks">
				<h2>Blocks</h2>
				<p>
				The block expression allows to have imperative code sequences. It consists of a sequence of 
				expressions, and returns the value of the last expression. The return type of a block is also the 
				type of the last expression. Empty blocks return <code>null</code>. 
				<a href="#variableDeclaration">Variable declarations</a> are only allowed within blocks and cannot be used as 
				a block&apos;s last expression.A block expression is surrounded by curly braces and contains at least one expression. It can 
				optionally be terminated by a semicolon. Here are two examples:</p><pre class="prettyprint lang-xtend">
{
  doSideEffect("foo")
  result
}</pre><p>
				</p><pre class="prettyprint lang-xtend">
{
  var x = greeting
  if (x.equals("Hello ")) {
    x + "World!" 
  } else {
    x
  }
}</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="variableDeclaration">
				<h2>Variable Declarations</h2>
				<p>
				Variable declarations are only allowed within <a href="#blocks">blocks</a>. They are visible in any 
				subsequent expressions in the block. A variable declaration starting with the keyword <code>val</code> denotes a so called value, which
				is essentially a final (i.e. unsettable) variable. In some cases, one needs to update the value of 
				a reference. In such situations the variable needs to be declared with the keyword <code>var</code>, 
				which stands for &apos;variable&apos;.A typical example for using <code>var</code> is a counter in a loop:
				</p><pre class="prettyprint lang-xtend">
{
  val max = 100
  var i = 0
  while (i &lt; max) {
    println("Hi there!")
    i = i + 1
  }
}</pre><p>
				Shadowing variables from outer scopes is not allowed, the only exception is the 
				<a href="#implicitVariables">implicit variable <code>it</code></a>.Variables declared outside a lambda expression using the <code>var</code> keyword are not accessible from within a
				lambda expressions.
				</p>
				<!-- subsection -->
				<section id="Section2_12">
				<h3>Typing</h3>
				<p>
				The type of the variable itself can either be explicitly declared or be inferred from the right hand side
				expression. Here is an example for an explicitly declared type:
				</p><pre class="prettyprint lang-xtend">
var List&lt;String&gt; msg = new ArrayList</pre><p>
				In such cases, the type of the right hand expression must conform to the type 
				of the expression on the left side. Alternatively the type can be left out and will be inferred from the initialization expression:  
				</p><pre class="prettyprint lang-xtend">
var msg = new ArrayList&lt;String&gt; // -&gt; msg is of type ArrayList&lt;String&gt;</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="featureCalls">
				<h2>Field Access and Method Invocation</h2>
				<p>
				A simple name can refer to a local field, variable or parameter. In addition
				it can point to a method with zero arguments, since empty parenthesis are optional. 
				</p>
				<!-- subsection -->
				<section id="propertyAccess">
				<h3>Property Access</h3>
				<p>
				If there is no field with the given name and also no method with the name and zero parameters
				accessible, a simple name binds to a corresponding Java-Bean getter method if available :</p><pre class="prettyprint lang-xtend">
myObj.myProperty // myObj.getMyProperty()  (.. in case myObj.myProperty is not visible.)</pre><p>
				</p>
				<!-- subsection -->
				<section id="implicitVariables">
				<h3>Implicit Variables <strong>this</strong> and <strong>it</strong></h3>
				<p>
				Like in Java an instance of the class is bound to <code>this</code>. Which allows for either qualifying
				field access or method invocations like in :</p><pre class="prettyprint lang-xtend">
this.myField</pre><p>
				or omit the receiver:</p><pre class="prettyprint lang-xtend">
myField</pre><p>
				You can use the variable name <code>it</code> to get the same behavior for any variable or parameter:</p><pre class="prettyprint lang-xtend">
val it = new Person
name = &apos;Horst&apos; // translates to &apos;it.setName("Horst");&apos;</pre><p>
				Another speciality of the variable <code>it</code> is that it can be shadowed. This is especially useful
				when used together with <a href="#lambdas">lambda expressions</a>.As <code>this</code> is bound to the surrounding object in Java, <code>it</code> can be used
				in finer-grained constructs such as <a href="#lambdas">lambda expressions</a>. That is why <code>it.myProperty</code> has 
				higher precedence than <code>this.myProperty</code>.
				</p>
				<!-- subsection -->
				<section id="staticAccess">
				<h3>Static Access</h3>
				<p>
				For accessing a static field or method you have to use the double colon <code>::</code> like in this example:</p><pre class="prettyprint lang-xtend">
MyClass::myField
MyClass::myMethod(&apos;foo&apos;)</pre><p>
				Alternatively you could import the method using a <a href="#imports">static import</a>.
				</p>
				<!-- subsection -->
				<section id="nullSafeFeatureCalls">
				<h3>Null-Safe Feature Call</h3>
				<p>
				Checking for <code>null</code> references can make code very unreadable. In many situations it is ok for an 
				expression to return <code>null</code> if a receiver was <code>null</code>. Xtend supports the safe navigation 
				operator <code>?.</code> to make such code better readable.Instead of writing 
				</p><pre class="prettyprint lang-java">
if (myRef != null) myRef.doStuff()</pre><p>
				one can write
				</p><pre class="prettyprint lang-xtend">
myRef?.doStuff</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="constructorCall">
				<h2>Constructor Call</h2>
				<p>
				ConstructorCalls have the same syntax as in Java. The only difference is that empty parenthesis
				are optional:
				</p><pre class="prettyprint lang-xtend">
new String() == new String
new ArrayList&lt;BigDecimal&gt;() == new ArrayList&lt;BigDecimal&gt;</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="lambdas">
				<h2>Lambda Expressions</h2>
				<p>
				A lambda expression is basically a piece of code, which is wrapped in an object to pass it around. As
				a Java developer it&apos;s best to think of a lambda expression as an anonymous class, i.e. 
				like in the following Java code :</p><pre class="prettyprint lang-java">
// Java Code!
final JTextField textField = new JTextField();
textField.addActionListener(new ActionListener() {
  @Override
  public void actionPerformed(ActionEvent e) {
    textField.setText("Something happened!");
  }
});</pre><p>
				This kind of anonymous classes can be found everywhere in Java code and have always been the poor-man&apos;s replacement
				for lambda expressions in Java. Xtend not only supports lambda expressions, but offers an extremely dense syntax for it. That is the
				code above can be written in Xtend like this:</p><pre class="prettyprint lang-xtend">
val textField = new JTextField
textField.addActionListener([ ActionEvent e |
  textField.text = "Something happened!"
])</pre><p>
				As you might have guessed, a lambda expression is surrounded by square brackets (inspired from Smalltalk).
				Also a lambda expression like a method declares parameters. The lambda above has one parameter called <code>e</code> which is of
				type <code>ActionEvent</code>. You don&apos;t have to specify the type explicitly because it can be inferred from
				the context:</p><pre class="prettyprint lang-xtend">
textField.addActionListener([ e |
  textField.text = "Something happened!"
])</pre><p>
				Also as lambdas with one parameter are a common case, there is a special short hand for them,
				which is to leave the declaration including the vertical bar out. The name of the single variable will be <a href="#implicitVariables">it</a>
				in that case:</p><pre class="prettyprint lang-xtend">
textField.addActionListener([
  textField.text = "Something happened!"
])</pre><p>
				A lambda expression with zero arguments is written like this (note the bar after the opening bracket):</p><pre class="prettyprint lang-xtend">
val Runnable runnable = [|
  println("Hello I&apos;m executed!")
]</pre><p>
				When a method call&apos;s last parameter is a lambda it can be passed right after the parameters.
				For instance if you want to sort some strings by their length, you could write :</p><pre class="prettyprint lang-xtend">
Collections::sort(someStrings) [ a, b |
  a.length - b.length
]</pre><p>
				which is just the same as writing</p><pre class="prettyprint lang-xtend">
Collections::sort(someStrings, [ a, b |
  a.length - b.length
])</pre><p>
				Since you can leave out empty parenthesis methods wich get a lambda as the single argument you can reduce
				the code above further more:</p><pre class="prettyprint lang-xtend">
textField.addActionListener[
  textField.text = "Something happened!"
]</pre><p>
				A lambda expression also captures the current scope, so that any final variables and parameters visible at construction time can be referred to 
				in the closure&apos;s expression. That&apos;s exactly what we did with the variable <code>textField</code>.
				</p>
				<!-- subsection -->
				<section id="closureTypes">
				<h3>Typing</h3>
				<p>
				Closures are expressions which produce <strong>Function</strong> objects. The type of a lambda expression generally depends on the target
				type, as seen in the previous examples. That is, the lambda expression can coerce to any interface which has declared only 
				one method (in addition to the ones inherited from <code>java.lang.Object</code>). This allows for using lambda expressions in many existing Java
				APIs directly.However, if you write a lambda expression without having any target type expectation, like in the following
				assignment:</p><pre class="prettyprint lang-xtend">
val toUpperCaseFunction = [String s | s.toUpperCase] // inferred type is (String)=&gt;String</pre><p>
				The type will be one of the types found in <code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.Functions</code>) or (<code class="prettyprint lang-java">org.eclipse.xtext.xbase.lib.Procedures</code>.
				It&apos;s a procedure if the return type is <code>void</code>, otherwise it&apos;s a function.Xtend supports a shorthand syntax for function types. Instead of writing <code>Function1&lt;? super String,? extends String&gt;</code>
				which is what you&apos;ll find in the generated Java code, you can simply write <code>(String)=&gt;String</code>.Example:
				</p><pre class="prettyprint lang-xtend">
val (String)=&gt;String stringToStringFunction = [toUpperCase]
// or
val Function1&lt;? super String,? extends String&gt; same = [toUpperCase]
// or
val stringToStringFunction2 = [String s | s.toUpperCase] // inferred type is (String)=&gt;String</pre><p>
				Checked exceptions that are thrown in the body of a closure but not declared in the implemented method of the target type are rethrown using the 
				<a href="#declaredExceptions">sneaky-throw technique</a>.
				Of course you can always <a href="#Xtend_Expressions_TryCatch">catch and handle</a> them.
				</p>
				</section>
				<!--  section -->
				<section id="ifExpression">
				<h2>If Expression</h2>
				<p>
				An if expression is used to choose two different values based on a predicate.An expression 
				</p><pre class="prettyprint lang-xtend">
if (p) e1 else e2</pre><p>
				 
				results in either the value <code>e1</code> or <code>e2</code> depending on whether the predicate <code>p</code> evaluates 
				to <code>true</code> or <code>false</code>. The else part is optional which is a shorthand for <code>else null</code>. That means </p><pre class="prettyprint lang-xtend">
if (foo) x</pre><p>
				is a short hand for</p><pre class="prettyprint lang-xtend">
if (foo) x else null</pre><p>
				The type of an if expression is the common super type of the return types <code>T1</code> and <code>T2</code> 
				of the two expression <code>e1</code> and <code>e2</code>.While the <code>if</code>-expression has the syntax of Java&apos;s if statement it behaves more like Java&apos;s ternary operator 
				(<code>predicate ? thenPart : elsePart</code>), because it is an expression and returns a value.
				Consequently, you can use if expressions deeply nested within expressions:</p><pre class="prettyprint lang-xtend">
val name = if (firstName != null) firstName + &apos; &apos; + lastName else lastName</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="switchExpression">
				<h2>Switch Expression</h2>
				<p>
				The <code>switch</code> expression is very different from Java&apos;s switch statement. First, there is no fall through which means 
				only one <code>case</code> is evaluated at most. Second, the use of <code>switch</code> is not limited 
				to certain values but can be used for any object reference instead. <code>Object.equals()</code> is used to
				compare the value in the case with the one you are switching over.
				 
				Given the following example:
				 
				</p><pre class="prettyprint lang-xtend">
switch myString {
  case myString.length&gt;5 : "a long string."
  case &apos;some&apos; : "It&apos;s some string."
  default : "It&apos;s another short string."
}</pre><p>
				the main expression <code>numberAsText</code> is evaluated first and then compared to each case sequentially.
				If the case expression is of type <code>boolean</code>, the case matches if the expression evaluates
				to true. If it&apos;s not of type <code>boolean</code> it&apos;s compared to the value from the main expression using <code>Object.equals(Object)</code>.If a case is a match, that is it evaluates to <code>true</code> or the result equals the one we are switching
				over, the case expression after the colon is evaluated and is the result of the whole expression.
				</p>
				<!-- subsection -->
				<section id="Section2_13">
				<h3>Type guards</h3>
				<p>
				Instead if or in addition to the case guard you can have a so called <strong>Type Guard</strong>. That is syntactically just a
				<a href="#types">type reference</a>. The cool thing is that the value is automatically down casted
				in subsequent expressions. Example:</p><pre class="prettyprint lang-xtend">
def length(Object x) {
  switch x {
    String case x.length &gt; 0 : x.length
    List&lt;?&gt; : x.size
    default : -1
  }
}</pre><p>
				Only if the switch value is an instance of the specified type, the case&apos;s guard expression is executed using the same 
				semantics explained previously. If the switch expression contains an explicit declaration of a local variable or the expression 
				references a local variable, the type guard acts like a cast, that is all references to the switch value will be of the 
				type specified in the type guard.Switches with type guards are a safe and much more readable alternative to instance of / casting orgies you might know from Java.
				</p>
				</section>
				<!--  section -->
				<section id="forLoop">
				<h2>For Loop</h2>
				<p>
				The for loop 
				</p><pre class="prettyprint lang-xtend">
for (T1 variable : arrayOrIterable) expression</pre><p>
				 
				is used to execute a certain expression for each element of an array or an instance of 
				<code>java.lang.Iterable</code>. The local <code>variable</code> is final, hence canot be updated. The return type of a for loop is <code>void</code>. The type of the local variable can be left out. 
				In that case it is inferred from the type of the array or <code>java.lang.Iterable</code> returned by the 
				iterable expression.</p><pre class="prettyprint lang-xtend">
for (String s : myStrings) {
  doSideEffect(s)
}

for (s : myStrings)
  doSideEffect(s)</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="whileExpression">
				<h2>While Loop</h2>
				<p>
				A while loop 
				</p><pre class="prettyprint lang-xtend">
while (predicate) expression</pre><p>
				 
				is used to execute a certain expression unless the predicate is evaluated to <code>false</code>. 
				The return type of a while loop is <code>void</code>.</p><pre class="prettyprint lang-xtend">
while (true) {
  doSideEffect("foo")
}

while ((i=i+1) &lt; max) 
  doSideEffect("foo")</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="doWhileExpression">
				<h2>Do-While Loop</h2>
				<p>
				A do-while loop 
				</p><pre class="prettyprint lang-xtend">
do expression while (predicate)</pre><p>
				 
				is used to execute a certain expression unless the predicate is evaluated to <code>false</code>. 
				The difference to the <a href="#whileExpression">while loop</a> is that the execution starts by executing 
				the block once before evaluating the predicate for the first time. The return type of a do-while 
				loop is <code>void</code>.</p><pre class="prettyprint lang-xtend">
do {
  doSideEffect("foo");
} while (true)


do doSideEffect("foo") while ((i=i+1)&lt;max)</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_Expressions_Return">
				<h2>Return Expression</h2>
				<p>
				A method or lambda expression automatically returns the value of it&apos;s expression.
				If it&apos;s a <a href="#blocks">block expression</a> this is the value of the last expression in it.
				However, sometimes you want to return early or make it explicit.The syntax is just like in Java:</p><pre class="prettyprint lang-xtend">
listOfStrings.map(e| {
  if (e==null) 
    return "NULL"
  e.toUpperCase
})</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_Expressions_Throw">
				<h2>Throwing Exceptions</h2>
				<p>
				Throwing <code>java.lang.Throwable</code>s up the call stack has the same semantics and syntax 
				as in Java.</p><pre class="prettyprint lang-xtend">
{
  ...
  if (myList.isEmpty)
    throw new IllegalArgumentException("the list must not be empty")
  ...
}</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="Xtend_Expressions_TryCatch">
				<h2>Try, Catch, Finally</h2>
				<p>
				The try-catch-finally expression is used to handle exceptional situations.
				You are not forced to catch checked exceptions, if you do not catch checked exceptions they are 
				rethrown in a wrapping runtime exception if not declared in the method&apos;s signature. 
				Other than that the syntax again is like the one known from Java.</p><pre class="prettyprint lang-xtend">
try {
  throw new RuntimeException()
} catch (NullPointerException e) {
  // handle e
} finally {
  // do stuff
}</pre><p>
				For try-catch it&apos;s again beneficial that it is an expression, because you can write code like the following
				and don&apos;t have to rely on non-final variables:</p><pre class="prettyprint lang-xtend">
val name = try {
    person.name
  } catch (NullPointerException e) {
    "no name"
  }</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="templates">
				<h2>Template Expressions</h2>
				<p>
				Templates allow for readable string concatenation. Templates are surrounded by triple single quotes (<code>&apos;&apos;&apos;</code>). 
				A template expression can span multiple lines and expressions can be nested which are evaluated and their <code>toString()</code> 
				representation is automatcially inserted at that position.The terminals for interpolated expression are so called guillemets <code>&laquo;expression&raquo;</code>. They read nicely and are not often used
				in text so you seldomly need to escape them. These escaping conflicts are the reason why
				template languages often use longer character sequences like e.g. <code>&lt;%= expression %&gt;</code> in JSP, for the price of worst readability. 
				The downside with the guillemets in Xtend is that you&apos;ll have to use a proper encoding (Always use UTF-8 and you are good).If you use the Eclipse plug-in which is recommended, the guillemets will be inserted automatically using
				content assist. They are also bound to <strong>CTRL+SHIFT+&lt;</strong> and <strong>CTRL+SHIFT+</strong> for <code>&laquo;</code> and <code>&raquo;</code> respectively.
				On a mac they are bound to <strong>alt+q</strong> (<code>&laquo;</code>) and <strong>alt+Q</strong> (<code>&raquo;</code>).Let us have a look at an example of how a typical method with template expressions looks like:</p><pre class="prettyprint lang-xtend">
def someHTML(String content) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;content&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre><p>
				As you can see, template expressions can be used as the direct body of a method.
				If an interpolation expression evaluates to <code>null</code> an empty string is added.Template expressions can occur everywhere. 
				Here&apos;s an example showing it in conjunction with the powerful <a href="#switchExpression">switch expression</a>:</p><pre class="prettyprint lang-xtend">
def toText(Node n) {
  switch n {
    Contents : n.text

    A : &apos;&apos;&apos;&lt;a href="&laquo;n.href&raquo;"&gt;&laquo;n.applyContents&raquo;&lt;/a&gt;&apos;&apos;&apos;

    default : &apos;&apos;&apos;
        &lt;&laquo;n.tagName&raquo;&gt;
          &laquo;n.applyContents&raquo;
        &lt;/&laquo;n.tagName&raquo;&gt;
    &apos;&apos;&apos;
  }
}</pre><p>
				</p>
				<!-- subsection -->
				<section id="templateIF">
				<h3>Conditions in Templates</h3>
				<p>
				There is a special <code>IF</code> to be used within templates:</p><pre class="prettyprint lang-xtend">
def someHTML(Paragraph p) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;IF p.headLine != null&raquo;
      	&lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
      &laquo;ENDIF&raquo;
      &lt;p&gt;
        &laquo;p.text&raquo;
      &lt;/p&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre><p>
				</p>
				<!-- subsection -->
				<section id="templateFOREACH">
				<h3>Loops in Templates</h3>
				<p>
				Also a <code>FOR</code> statement is available:</p><pre class="prettyprint lang-xtend">
def someHTML(List&lt;Paragraph&gt; paragraphs) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs&raquo;
        &laquo;IF p.headLine != null&raquo;
      	  &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre><p>
				The for statement optionally allows to specify what to prepend (<code>BEFORE</code>), put in-between (<code>SEPARATOR</code>), and what to
				put at the end (<code>AFTER</code>) of all iterations. <code>BEFORE</code> and <code>AFTER</code>
				are only executed if there is at least one iteration. (<code>SEPARATOR</code>) is only added between
				iterations, that it is executed if there are at least two iterations.Here&apos;s an example:</p><pre class="prettyprint lang-xtend">
def someHTML(List&lt;Paragraph&gt; paragraphs) &apos;&apos;&apos;
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs BEFORE &apos;&lt;div&gt;&apos; SEPARATOR &apos;&lt;/div&gt;&lt;div&apos; AFTER &apos;&lt;/div&gt;&apos;&raquo;
        &laquo;IF p.headLine != null&raquo;
      	  &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
&apos;&apos;&apos;</pre><p>
				</p>
				<!-- subsection -->
				<section id="templateType">
				<h3>Typing</h3>
				<p>
				The template expression is of type <code class="prettyprint lang-java">java.lang.CharSequence</code> but auto-convertes to <code class="prettyprint lang-java">java.lang.String</code>
				if that is the expected target type.
				</p>
				<!-- subsection -->
				<section id="WhitespaceHandling">
				<h3>White Space Handling</h3>
				<p>
				One of the key features of templates is the smart handling of white space in the template output. 
				The white space is not written into the output data structure as is but preprocessed. This allows 
				for readable templates as well as nicely formatted output. This can be achieved by applying three 
				simple rules when the template is evaluated.<ol>
					<li>
					    Indentation in the template that is relative to a control structure will not be propagated 
					    to the output string. A control structure is a <code>FOR</code>-loop or a condition 
					    (<code>IF</code>) as well as the opening and closing marks of the rich string itself.
					    
					    The indentation is considered to be relative to such a control structure if the previous 
					    line ends with a control structure followed by optional white space. The amount of white 
					    space is not taken into account but the delta to the other lines.
					  </li>
					<li>
					    Lines that do not contain any static text which is not white space but do contain control 
					    structures or invocations of other templates which evaluate to an empty string, will not 
					    appear in the output.
					  </li>
					<li>
					    Any newlines in appended strings (no matter they are created with template expressions or not) will
						be prepended with the current indentation when inserted.
					  </li>
				</ol>
				Although this algorithm sounds a bit complicated at first it behaves very intuitively. In addition the
				syntax coloring in Eclipse communicates this behavior.<div class="thumbnail">
					<img src="images/Xtend_template_coloring.png" alt="">
				</div>
				The behavior is best described with a set of examples. The following table assumes a data structure 
				of nested nodes.<table class="table table-bordered table-condensed">
				<tr><td>
				      <pre class="prettyprint lang-xtend">
class Template {
  def print(Node n) &apos;&apos;&apos;
    node &laquo;n.name&raquo; {}
  &apos;&apos;&apos;
}</pre>
				
				    </td>
				<td>
				      <pre class="prettyprint lang-xtend">
node NodeName {}</pre>
				
				    </td>
				</tr>
				</table>
				The indentation before <code>node &laquo;n.name&raquo;</code> will be skipped as it is relative to the opening mark of
				the rich string and thereby not considered to be relevant for the output but only for readability 
				of the template itself.<table class="table table-bordered table-condensed">
				<tr><td>
				      <pre class="prettyprint lang-xtend">
class Template {
  def print(Node n) &apos;&apos;&apos;
    node &laquo;n.name&raquo; {
      &laquo;IF hasChildren&raquo;
        &laquo;n.children.map[print]&raquo;
      &laquo;ENDIF&raquo;
    }
  &apos;&apos;&apos;
}</pre>
				
				    </td>
				<td>
				      <pre class="prettyprint lang-xtend">
node Parent{
  node FirstChild {
  }
  node SecondChild {
    node Leaf {
    }
  }
}</pre>
				
				    </td>
				</tr>
				</table>
				As in the previous example, there is no indentation on the root level for the same reason.
				The first nesting level has only one indentation level in the output. This is derived from
				the indentation of the <code>IF hasChildren</code> condition in the template which is nested in
				the node. The additional nesting of the recursive invocation <code>children.map[print]</code> is not
				visible in the output as it is relative the the surrounding control structure. The line with
				<code>IF</code> and <code>ENDIF</code> contain only control structures thus they are skipped in 
				the output. Note the additional indentation of the node <strong>Leaf</strong> which happens due to the first rule:
				Indentation is propagated to called templates.
				</p>
				</section>
			</div>
		</div>
		</section>
		<!-- chapter -->
		<section id="processedAnnotations">
		<div class="page-header">
			<h1>
				Processed Annotations
			</h1>
		</div>
		<div class="row">
			<div class="span9 offset2">
				<p>
				Xtend comes with annotations that help to steer the compilation process.
				These annotations reside in the <code>org.eclipse.xtend.lib</code> plug-in/jar which must be on the classpath
				of the project containing the Xtend files. 
				</p>
				<!--  section -->
				<section id="propertyAnnotation">
				<h2>@Property</h2>
				<p>
				For fields that are annotated as <code>@Property</code>, the Xtend compiler will generate a Java field, a
				getter and, if the field is non-final, a setter method. The name of the Java field will be prefixed with 
				an <code>_</code> and have the visibility of the Xtend field. The accessors methods are always <code>public</code>. 
				Thus, an Xtend field</p><pre class="prettyprint lang-xtend">
@Property String name</pre><p>
				will compile to the Java code</p><pre class="prettyprint lang-java">
private String _name;

public String getName() {
  return this._name;
}

public void setName(final String name) {
  this._name = name;
}</pre><p>
				</p>
				</section>
				<!--  section -->
				<section id="dataAnnotation">
				<h2>@Data</h2>
				<p>
				The annotation <code>@Data</code>, will turn an annotated class into a value object class. A class annotated with <code>@Data</code> 
				has the following effect:<ul>
					<li>all fields are flagged final,</li>
					<li>getter methods will be generated (if not existent),</li>
					<li>a constructor taking paramaters for all non-initialized fields will be generated (if not existent),</li>
					<li>equals(Object) / hashCode() methods will be generated (if not existent),</li>
					<li>a toString() method will be generated (if not existent).</li>
				</ul>
				Example:</p><pre class="prettyprint lang-xtend">
@Data class Person {
  String firstName
  String lastName
}</pre><p>
				</p>
				</section>
			</div>
		</div>
		</section>
	</div>
			<!-- Le javascript
			================================================== -->
			<!-- Placed at the end of the document so the pages load faster -->

			<script src="../bootstrap/js/jquery.min.js"></script>
			<script src="../bootstrap/js/bootstrap.min.js"></script>
		</body>
	</html>
