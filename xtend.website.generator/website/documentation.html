<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtend - Modernized Java</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="Xtend is a statically typed programming language sitting on top of Java.">
	<meta name="author" content="Sven Efftinge">
	<style>
		#header_wrapper {
			padding-top: 10px;
			/* 60px to make the container go all the way to the bottom of the topbar */
		}
		
		code.prettyprint {
	        padding: 0px;
	        background-color: white;
			border: none;
	    }
	</style>
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
					prettyPrint();
	         
					 $('a[data-rel]').each(function() {
	             $(this).attr('rel', $(this).data('rel'));
	         });
	        
					 $("a[rel^='prettyPhoto']").prettyPhoto({
	             animation_speed: 'fast',
	             slideshow: 5000,
	             autoplay_slideshow: false,
	             opacity: 0.80,
	             show_title: true,
	             theme: 'ligh_square',
	             overlay_gallery: false,
	             social_tools: false
	       
	         });
	         
					$('#nav-outline > li > a').live('click', function() {        
						$(this).parent().find('ul').slideToggle();      
					});
	         
		 	     
		 	     getTwitters('tweet', { 
			        id: 'xtendlang', 
			        count: 5,
			        includeRT: true,
			        enableLinks: true, 
			        clearContents: true,
			        template : '"%text%" - %time% by <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">@%user_screen_name%</a><br/><br/>'
			     });
	         
	         var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		 	     po.src = 'https://apis.google.com/js/plusone.js';
		 	     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
	
	      <div class="btn-group pull-right">
	        <g:plusone href="http://www.xtend-lang.org"></g:plusone>
	      </div>
	
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li class="active"><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
	
				</div>
				<!--/.nav-collapse -->
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<ul id="nav-outline">
	<li>&nbsp;</li>
	<li style="color : #333;">Getting Started</li>
	<li><a href="#Introduction">Introduction</a>
	</li>
	<li><a href="#GettingStarted">Hello World</a>
	</li>
	<li><a href="#moviesExample">The Movies Example</a>
<ul>	<li><a href="#_0">The Data</a></li>
	<li><a href="#_1">Parsing The Data</a></li>
	<li><a href="#_2">Answering Some Questions</a></li>
</ul>	</li>
	<li>&nbsp;</li>
	<li style="color : #333;">Reference Documentation</li>
	<li><a href="#types">Java Interoperability</a>
<ul>	<li><a href="#localTypeInference">Type Inference</a></li>
	<li><a href="#conversionRules">Conversion Rules</a></li>
	<li><a href="#javaInteroperability">Interoperability with Java</a></li>
</ul>	</li>
	<li><a href="#Xtend_Classes_Members">Classes and Members</a>
<ul>	<li><a href="#packageDecl">Package Declaration</a></li>
	<li><a href="#imports">Imports</a></li>
	<li><a href="#Xtend_ClassDeclaration">Class Declaration</a></li>
	<li><a href="#constructors">Constructors</a></li>
	<li><a href="#fields">Fields</a></li>
	<li><a href="#methods">Methods</a></li>
	<li><a href="#Annotations">Annotations</a></li>
	<li><a href="#extensionMethods">Extension Methods</a></li>
</ul>	</li>
	<li><a href="#Xtend_Expressions">Expressions</a>
<ul>	<li><a href="#Xtend_Expressions_Literals">Literals</a></li>
	<li><a href="#typeCasts">Type Casts</a></li>
	<li><a href="#operators">Infix Operators and Operator Overloading</a></li>
	<li><a href="#blocks">Blocks</a></li>
	<li><a href="#variableDeclaration">Variable Declarations</a></li>
	<li><a href="#featureCalls">Field Access and Method Invocation</a></li>
	<li><a href="#constructorCall">Constructor Call</a></li>
	<li><a href="#lambdas">Lambda Expressions</a></li>
	<li><a href="#ifExpression">If Expression</a></li>
	<li><a href="#switchExpression">Switch Expression</a></li>
	<li><a href="#forLoop">For Loop</a></li>
	<li><a href="#whileExpression">While Loop</a></li>
	<li><a href="#doWhileExpression">Do-While Loop</a></li>
	<li><a href="#Xtend_Expressions_Return">Return Expression</a></li>
	<li><a href="#Xtend_Expressions_Throw">Throwing Exceptions</a></li>
	<li><a href="#Xtend_Expressions_TryCatch">Try, Catch, Finally</a></li>
	<li><a href="#templates">Template Expressions</a></li>
</ul>	</li>
	<li><a href="#processedAnnotations">Processed Annotations</a>
<ul>	<li><a href="#propertyAnnotation">@Property</a></li>
	<li><a href="#dataAnnotation">@Data</a></li>
</ul>	</li>
	<li>&nbsp;</li>
	<li style="color : #333;">Additional Resources</li>
	<li><a href="documentation/2.3.0/Documentation.pdf">Documentation <img src="images/pdf_icon.gif"></a>
	<li><a href="api/2.3.0/index.html">Runtime Library API</a>
</ul>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="Introduction" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Introduction
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Xtend is a statically-typed programming language which translates to comprehensible Java source code. 
							Syntactically and semantically Xtend has its roots in the Java programming language but improves on many aspects:
						</p>
						<p>
							</p>
							<ul>
								<li><strong><a href="#extensionMethods">Extension methods</a></strong> - enhance closed types with new functionality</li>
								<li><strong><a href="#lambdas">Lambda Expressions</a></strong> - concise syntax for anonymous function literals</li>
								<li><strong><a href="#operators">Operator overloading</a></strong> - make your libraries even more expressive</li>
								<li><strong><a href="#switchExpression">Powerful switch expressions</a></strong> - type based switching with implicit casts</li>
								<li><strong><a href="#polymorphicDispatch">Multiple dispatch</a></strong> - a.k.a. polymorphic method invocation</li>
								<li><strong><a href="#templates">Template expressions</a></strong> - with intelligent white space handling</li>
								<li><strong><a href="#Xtend_Expressions">No statements</a></strong> - everything is an expression</li>
								<li><strong><a href="#propertyAccess">Properties</a></strong> - shorthands for accessing and defining getters and setter</li>
								<li><strong>Local type inference</strong> - you rarely need to write down type signatures anymore</li>
								<li><strong>Full support for Java Generics</strong> - including all conformance and conversion rules</li>
								<li><strong>Translates to Java</strong> not bytecode - understand what is going on and use your code for platforms 
								    such as Android or GWT</li>
							</ul>
							<p>
						</p>
						<p>
							Unlike other JVM languages Xtend has <a href="#javaInteroperability">zero interoperability issues</a> with Java:
							Everything you write interacts with Java exactly as expected. At the same time Xtend is much more concise, 
							readable and expressive. Xtend's small <a href="#library">library</a> is just a thin layer that provides useful 
							utilities and extensions on top of the Java Development Kit (JDK).
						</p>
						<p>
							Of course, you can call Xtend methods from Java, too, in a completely transparent way. Furthermore, Xtend provides a modern 
							Eclipse-based IDE closely integrated with Eclipse's Java Development Tools (JDT), including features like call-hierarchies, rename refactoring, 
							debugging and many more.
						</p>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="GettingStarted" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Hello World
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The first thing you want to see in any language is a "Hello World" example. 
							In Xtend, that reads as
							</p>
							<pre class="prettyprint lang-xtend linenums">
class HelloWorld {
  def static void main(String[] args) {
    println("Hello World")
  }
}</pre>
							<p>
						</p>
						<p>
							You see that Xtend looks a lot like Java. At a first glance the main difference seems to be the <code class="prettyprint lang-xtend">def</code>
							keyword to declare a method. Also like in Java it is mandatory to define a class and a main method as the entry point for an application. 
							Admittedly 'hello world' programs are not a particular strength of Xtend. The real expressiveness is unleashed when you do real stuff
							as you will learn in a second.
						</p>
						<p>
							An Xtend class resides in a plain Java project. As soon as the SDK is installed, Eclipse will automatically 
							translate it to Java code. By default you will find it in a source folder <strong>xtend-gen</strong>, which is of course configurable.
							The hello world example is translated to the following Java code:
							</p>
							<pre class="prettyprint lang-java linenums">
// Generated Java Source Code
import org.eclipse.xtext.xbase.lib.InputOutput;

public class HelloWorld {
  public static void main(final String[] args) {
    InputOutput.&lt;String&gt;println("Hello World");
  }
}</pre>
							<p>
						</p>
						<p>
							The only surprising fact in the generated Java code may be the referenced library class <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/InputOutput.html"><abbr title="org.eclipse.xtext.xbase.lib.InputOutput">InputOutput</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/InputOutput.java">(src)</a>. 
							It is provided by the <a href="#library">runtime library</a> and only one nice utility that is handy when using
							expressions.
						</p>
						<p>
							You can put an Xtend class into a source folder of any Java project within Eclipse (or any Maven project). Eclipse will complain
							about the missing library if it is not on the classpath and provide a quick fix to add it.
						</p>
						<p>
							The next thing you might want to do is materializing one of the example projects into your workspace.
							To do so right click anywhere in the <strong>Navigator</strong> view in Eclipse and select <strong>New -&gt; Example...</strong>.
						</p>
						<p>
							In the upcoming dialog you will find two examples for Xtend:
						</p>
						<p>
							</p>
							<ul>
								<li><strong>Xtend Introductory Examples</strong> contains a couple of example code snippets illustrating certain
								  aspects and strengths of Xtend. 
								  It for instance shows how to build an API which allows for writing code like this:
								<pre class="prettyprint lang-xtend linenums">
assertEquals(42.km/h, (40_000.m + 2.km) / 60.min)</pre>
								  Also the <a href="#moviesExample">the movies example</a> explained in detail in <a href="#moviesExample">the next section</a>
								  is included there.</li>
								<li><strong>Xtend Solutions For Euler</strong> contains solutions to a lot of the problems you will find at <a href="http://projecteuler.net/">Project Euler's website</a>.
								   These examples are leveraging the whole expressive power of Xtend. For instance <a href="http://projecteuler.net/problem=1">Euler Problem 1</a> can be solved
								   with the following expression :
								<pre class="prettyprint lang-xtend linenums">
(1..999).filter[ i | i % 3 == 0 || i % 5 == 0 ].reduce[ i1, i2 | i1 + i2 ]</pre></li>
							</ul>
							<p>
						</p>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="moviesExample" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							The Movies Example
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The movies example is included in the example project <strong>Xtend Introductory Examples</strong> (src/examples6/Movies.xtend) and is about reading
							a file with data about movies and doing some analysis on it.
						</p>
						<!--  section -->
						<section id="_0" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">The Data</h2>
						<p>
							The movie database is a plain text file (data.csv) with data sets describing movies.
							Here is an example data set:
							</p>
							<pre class="prettyprint lang-xtend linenums">
Naked Lunch  1991  6.9  16578  Biography  Comedy  Drama  Fantasy</pre>
							<p>
						</p>
						<p>
							The values are separated by two spaces. The columns are :
							</p>
							<ol>
								<li>title</li>
								<li>year</li>
								<li>rating</li>
								<li>numberOfVotes</li>
								<li>categories</li>
							</ol>
							<p>
							
							 
							Let us define a data type <code class="prettyprint lang-xtend">Movie</code> representing a data set:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Data class Movie {
  String title
  int year
  double rating
  long numberOfVotes
  Set&lt;String&gt; categories 
}</pre>
							<p>
						</p>
						<p>
							It is a plain class with a typed field for each column in the data sets. The <a href="#dataAnnotation">@Data</a>
							annotation will turn this class into a value object, that is it will get 
							</p>
							<ul>
								<li>a getter-method for each field,</li>
								<li>a <code class="prettyprint lang-xtend">hashCode()</code>/<code class="prettyprint lang-xtend">equals()</code> implementation,</li>
								<li>implementation of <code class="prettyprint lang-xtend">Object.toString(),</code></li>
								<li>a constructor accepting values for all fields in the declared order.</li>
							</ul>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="_1" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Parsing The Data</h2>
						<p>
							Let us now add another class to the same file (any number of <a href="#Xtend_Classes_Members">classes</a> per file is allowed) and initialize a field
							called movies with a list of movies. For the initialization we read in the text file and turn the data sets into <code class="prettyprint lang-xtend">Movie</code>s:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
import java.io.FileReader
import java.util.Set
import static extension com.google.common.io.CharStreams.*

class Movies {
  
  val movies = new FileReader('data.csv').readLines.map [ line |
    val segments = line.split('  ').iterator
    return new Movie(
      segments.next, 
      Integer::parseInt(segments.next), 
      Double::parseDouble(segments.next), 
      Long::parseLong(segments.next), 
      segments.toSet
    )
  ]
}</pre>
							<p>
						</p>
						<p>
							A <a href="#fields">field's type</a> can be inferred from the expression on the right hand-side. 
							That is called local type inference and is supported everyhwere in Xtend.
							We want the field to be final, so we declare it as a value using the keyword <code class="prettyprint lang-xtend">val</code>.
						</p>
						<p>
							The initialization on the right hand side first creates a fresh instance of <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/FileReader.html"><abbr title="java.io.FileReader">FileReader</abbr></a>.
							Then the method <code class="prettyprint lang-xtend">readLines()</code> is invoked on that instance. But if you have a look at <code class="prettyprint lang-xtend">FileReader</code> you will not find
							such a method, because <code class="prettyprint lang-xtend">readLines()</code> is in fact a static method from Google Guava's <a href="http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/io/CharStreams.html"><abbr title="com.google.common.io.CharStreams">CharStreams</abbr></a> which was imported 
							as an <a href="#extensionImports">extension</a> which allows us to use this readable syntax.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
import static extension com.google.common.io.CharStreams.*</pre>
							<p>
						</p>
						<p>
							<a href="http://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/io/CharStreams.html"><code class="prettyprint lang-xtend">CharStreams.readLines(Reader)</code></a> returns a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><code class="prettyprint lang-xtend">List&lt;String&gt;</code></a> on which we call another extension method called <code class="prettyprint lang-xtend">map</code>.
							That one is defined in the <a href="#library">runtime library</a> (<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/ListExtensions.html">ListExtensions.map(...)</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ListExtensions.java">(src)</a>) and is always imported and
							therefore automatically available on all lists. The <code class="prettyprint lang-xtend">map</code> extension expects a function as a parameter.
							It basically invokes that function for each value in the list and returns another list containing the results of the function invocations.
						</p>
						<p>
							Function objects are created using <a href="#lambdas">lambda expressions</a> (the code in squared brackets).
							Within the lambda we process a single line from the text file and turn it into a movie by splitting the string using the
							separator (two whitespaces) and calling iterator on the result. As you might know <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html">String.split(String)</a>
							returns a string array (<code class="prettyprint lang-xtend">String[]</code>), which Xtend <a href="#conversionRules">auto-convertes to a list</a> when we 
							call <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><code class="prettyprint lang-xtend">Iterable.iterator()</code></a> on it.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val segments = line.split('  ').iterator</pre>
							<p>
						</p>
						<p>
							Now we use the iterator to create an instance of <code class="prettyprint lang-xtend">Movie</code>.
							The data type conversion (e.g. <code class="prettyprint lang-xtend">String</code> to <code class="prettyprint lang-xtend">int</code>) is done by calling <a href="#staticAccess">static methods</a> from the wrapper types. 
							The rest of the iterable is turned into a set using the extension method <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IteratorExtensions.html"><code class="prettyprint lang-xtend">IteratorExtensions.toSet(Iterator&lt;T&gt;)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IteratorExtensions.java">(src)</a>
							and contains all the categories the movie is associated with.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
return new Movie (
  segments.next, 
  Integer::parseInt(segments.next), 
  Double::parseDouble(segments.next), 
  Long::parseLong(segments.next), 
  segments.toSet
)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="_2" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Answering Some Questions</h2>
						<p>
							Now that we have turned the text file into a <code class="prettyprint lang-xtend">List&lt;Movie&gt;</code>, we are ready to execute some queries against it.
							We use <strong>JUnit</strong> to make the individual analysis executable.
						</p>
						<!-- subsection -->
						<section id="_3" style="padding-top: 68px; margin-top: -68px;">
						<h3>Question 1 : What Is The Number Of Action Movies?</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def numberOfActionMovies() {
  assertEquals(828, 
    movies.filter[ categories.contains('Action') ].size)
}</pre>
							<p>
						</p>
						<p>
							First the movies are <code class="prettyprint lang-xtend">filter</code>ed. The lambda expression checks whether the current movie's categories contain 
							the entry <code class="prettyprint lang-xtend">'Action'</code>. Note that unlike the lambda we used to turn the lines in the file into movies, we 
							have not declared a parameter name this time. 
							We could have written 
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ movie | movie.categories.contains('Action') ].size</pre>
							<p>
							
							but since we left out the name and the vertical bar the variable is automatically named <code class="prettyprint lang-xtend">it</code> which
							(like <code class="prettyprint lang-xtend">this</code>) is an <a href="#implicitVariables">implicit variable</a>. That is why we can write either
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ it.categories.contains('Action') ].size</pre>
							<p>
							
							or 
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ categories.contains('Action') ].size</pre>
							<p>
						</p>
						<p>
							Eventually we call <code class="prettyprint lang-xtend">size</code> on the resulting iterable which also is an extension method defined in 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IterableExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">(src)</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="_4" style="padding-top: 68px; margin-top: -68px;">
						<h3>Question 2 : What Is The Year The Best Movie From The 80ies Was Released?</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def void yearOfBestMovieFrom80ies() {
  assertEquals(1989, 
    movies.filter[ (1980..1989).contains(year) ].sortBy[ rating ].last.year)
}</pre>
							<p>
						</p>
						<p>
							Here we <code class="prettyprint lang-xtend">filter</code> for all movies whose year is included in the range from 1980 to 1989 (the 80ies).
							The <code class="prettyprint lang-xtend">..</code> operator is again an extension defined in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IntegerExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IntegerExtensions">IntegerExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerExtensions.java">(src)</a> and returns an instance of <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IntegerRange.html"><abbr title="org.eclipse.xtext.xbase.lib.IntegerRange">IntegerRange</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerRange.java">(src)</a>.
							Operator overloading is explained in <a href="#operators">section</a>.
						</p>
						<p>
							The resulting iterable is sorted (<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IterableExtensions.html"><code class="prettyprint lang-xtend">IterableExtensions.sortBy</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">(src)</a>) by the <code class="prettyprint lang-xtend">rating</code> of the movies. 
							Since it is sorted in ascending order, we take the last movie from the list and return its <code class="prettyprint lang-xtend">year</code>.
						</p>
						<p>
							We could have sorted descending and take the head of the list as well:
							</p>
							<pre class="prettyprint lang-xtend linenums">
movies.filter[ (1980..1989).contains(year) ].sortBy[ -rating ].head.year</pre>
							<p>
						</p>
						<p>
							Note that first sorting and then taking the last or first is slightly more expensive than needed. We could
							have used the method <code class="prettyprint lang-xtend">reduce</code> instead to find the best movie which would be more efficient. Maybe
							you want to try it on your own?
						</p>
						<p>
							The calls to <code class="prettyprint lang-xtend">movie.year</code> as well as <code class="prettyprint lang-xtend">movie.categories</code> in the previous example in fact access the corresponding 
							<a href="#propertyAccess">getter methods</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="_5" style="padding-top: 68px; margin-top: -68px;">
						<h3>Question 3 : What Is The The Sum Of All Votes Of The Top Two Movies?</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Test def void sumOfVotesOfTop2() {
  val long sum = movies.sortBy[ -rating ].take(2).map[ numberOfVotes ].reduce[ a, b | a + b ]
  assertEquals(47_229L, sum)
}</pre>
							<p>
						</p>
						<p>
							First the movies are sorted by rating, then we take the best two. Next the list of movies is turned into a list of their <code class="prettyprint lang-xtend">numberOfVotes</code> using the <code class="prettyprint lang-xtend">map</code> function. 
							Now we have a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><code class="prettyprint lang-xtend">List&lt;Long&gt;</code></a> which can be reduced to a single <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html"><abbr title="java.lang.Integer">Integer</abbr></a> by adding the values.
						</p>
						<p>
							You could also use <code class="prettyprint lang-xtend">reduce</code> instead of <code class="prettyprint lang-xtend">map</code> and <code class="prettyprint lang-xtend">reduce</code>. Do you know how?
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="types" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Java Interoperability
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Xtend, like Java, is a statically typed language. In fact it completely supports Java's type system, including the primitive types 
							as <code class="prettyprint lang-xtend">int</code> or <code class="prettyprint lang-xtend">boolean</code>, arrays and of course all classes, interfaces, enums and annotations that reside on the 
							classpath.
						</p>
						<p>
							Java generics are fully supported as well: You can define type parameters on methods and classes and pass type arguments to
							generic types just as you are used to from Java. The type system and its conformance and casting rules are implemented as
							defined in  
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html">the Java Language Specification</a>.
						</p>
						<!--  section -->
						<section id="localTypeInference" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Type Inference</h2>
						<p>
							One of the problems with Java is that you are forced to write type signatures over
							and over again. That is why so many people do not like static typing. 
							But this is in fact not a problem of static typing but simply a problem with Java. Although Xtend is typed
							just like Java, you rarely have to write types down because they can be computed from the context.
						</p>
						</section>
						<!--  section -->
						<section id="conversionRules" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Conversion Rules</h2>
						<p>
							In addition to Java's autoboxing to convert primitives to their corresponding wrapper types (e.g. <code class="prettyprint lang-xtend">int</code>
							is automatically converted to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html"><abbr title="java.lang.Integer">Integer</abbr></a> when needed), there are additional conversion rules.
						</p>
						<p>
							Arrays are automatically converted to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><code class="prettyprint lang-xtend">List&lt;ComponentType&gt;</code></a> and vice versa. That is you can
							write the following:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def toList(String[] array) {
  val List&lt;String&gt; asList = array
  return asList
}</pre>
							<p>
						</p>
						<p>
							Another very useful conversion applies to lambda expressions. A lambda expression
							usually is of one of the types listed in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.html"><abbr title="org.eclipse.xtext.xbase.lib.Functions">Functions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a>
							or <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Procedures.html"><abbr title="org.eclipse.xtext.xbase.lib.Procedures">Procedures</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a>. However if the expected type is an interface with a single method
							declaration, a lambda expression is automatically converted to that
							type. This allows to use lambda expressions with many existing Java libraries. See <a href="#closureTypes"></a>
							for more details.
						</p>
						</section>
						<!--  section -->
						<section id="javaInteroperability" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Interoperability with Java</h2>
						<p>
							Resembling and supporting every aspect of Java's type system ensures that there is no impedance mismatch between Java and Xtend.
							This means that Xtend and Java are 100% interoperable. There are no exceptional cases. You do not have
							to think in two worlds. You can call Xtend code from Java and vice versa without any surprises or hassles.
						</p>
						<p>
							As a bonus if you know Java's type system (specifically generics), you already know the most complicated part
							of Xtend.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="Xtend_Classes_Members" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Classes and Members
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							At a first glance an Xtend file pretty much looks like a Java file. It starts with a package 
							declaration followed by an import section and a class definition.
							The class in fact is directly translated to a Java class in the corresponding Java package.
							A class can have constructors, fields and methods.
						</p>
						<p>
							Here is an example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
package com.acme

import java.util.List

class MyClass {
  String name
  
  new(String name) {
    this.name = name
  }
  
  def String first(List&lt;String&gt; elements) {
    elements.get(0)
  }
}</pre>
							<p>
						</p>
						<!--  section -->
						<section id="packageDecl" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Package Declaration</h2>
						<p>
							Package declarations look like in Java. There are two small differences: 
							</p>
							<ul>
								<li>An identifier can be escaped with a <code class="prettyprint lang-xtend">^</code> character in case it conflicts with a keyword.</li>
								<li>The terminating semicolon is optional.</li>
							</ul>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
package com.acme</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="imports" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Imports</h2>
						<p>
							The ordinary imports of type names are equivalent to the imports known from Java. 
							Again one can escape any names conflicting with keywords using a <code class="prettyprint lang-xtend">^</code>. In contrast to Java, the 
							terminating semicolon is optional. Xtend also features static imports but 
							allows only a wildcard <code class="prettyprint lang-xtend">*</code> at the end, i.e. you currently cannot import single members using a static 
							import. Non-static wildcard imports are deprecated for the benefit of better tooling.
						</p>
						<p>
							As in Java all classes from the <code class="prettyprint lang-xtend">java.lang</code> package are implicitly imported.
							</p>
							<pre class="prettyprint lang-xtend linenums">
import java.math.BigDecimal
import static java.util.Collections.*</pre>
							<p>
						</p>
						<p>
							Static methods of helper classes can also be imported as <code class="prettyprint lang-xtend">extension</code>s. See the section on 
							<a href="#extensionMethods">extension methods</a> for details.
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_ClassDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Class Declaration</h2>
						<p>
							The class declaration reuses a lot of Java's syntax but still is a bit different in some aspects:
							Java's default "package private" visibility does not exist in Xtend. As an Xtend class is compiled to
							a top-level Java class and Java does not allow <code class="prettyprint lang-java">private</code> or <code class="prettyprint lang-java">protected</code> top-level
							classes any Xtend class is <code class="prettyprint lang-xtend">public</code>. It is possible to write <code class="prettyprint lang-xtend">public</code> explicitly.
						</p>
						<p>
							Since version 2.3, multiple class declaration per file are supported. Each of these classes
							is compiled to a separate top-level Java class.
						</p>
						<p>
							Abstract classes are defined using the <code class="prettyprint lang-xtend">abstract</code> modifier as in Java. See also <a href="#abstractMethods"></a> 
							on abstract methods.
						</p>
						<p>
							Xtend's approach to inheritance is conceptionally the same as in Java. Single inheritance of 
							classes as well as implementing multiple interfaces is supported. 
							Xtend classes can of course extend other Xtend classes, and even Java classes can inherit from Xtend classes.
						</p>
						<p>
							The most simple class looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
}</pre>
							<p>
						</p>
						<p>
							A more advanced generic class declaration in Xtend:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, 
                   Cloneable, java.io.Serializable {
  ...
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="constructors" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Constructors</h2>
						<p>
							An Xtend class can define one or more constructors. Unlike Java you do not have to repeat the name of the class over and over again,
							but use keyword <code class="prettyprint lang-xtend">new</code> to declare a constructor.
							Constructors can also delegate to other constructors using <code class="prettyprint lang-xtend">this(args...)</code> in their first
							line. 
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass extends AnotherClass {
  new(String s) {
    super(s)
  }
  
  new() {
    this("default")
  }
}</pre>
							<p>
						</p>
						<p>
							The same rules with regard to inheritance apply as in Java, i.e. if the super class does not define a 
							no-argument constructor, you have to explicitly call one using <code class="prettyprint lang-xtend">super(args...)</code> as the first 
							expression in the body of the constructor.
						</p>
						<p>
							The default visibility of constructors is <code class="prettyprint lang-xtend">public</code> but you can also specify <code class="prettyprint lang-xtend">protected</code>
							or <code class="prettyprint lang-xtend">private</code>.
						</p>
						</section>
						<!--  section -->
						<section id="fields" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Fields</h2>
						<p>
							A field can have an initializer. Final fields are declared using <code class="prettyprint lang-xtend">val</code>, while 
							<code class="prettyprint lang-xtend">var</code> introduces a non-final field and can be ommitted. Yet, if an initializer expression
							is present, the type of a field can be skipped after <code class="prettyprint lang-xtend">val</code> and <code class="prettyprint lang-xtend">var</code>.
							Fields marked as <code class="prettyprint lang-xtend">static</code> will be compiled to static Java fields.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
  int count = 1
  static boolean debug = false
  var name = 'Foo'          // type String is inferred 
  val UNIVERSAL_ANSWER = 42 // final field with inferred type int
  ...
}</pre>
							<p>
						</p>
						<p>
							The default visibility is <code class="prettyprint lang-xtend">private</code>. You can also declare it explicitly as 
							being <code class="prettyprint lang-xtend">public</code>, <code class="prettyprint lang-xtend">protected</code>, or <code class="prettyprint lang-xtend">private</code>.
						</p>
						<p>
							A specialty of Xtend are fields that provide <strong>extension methods</strong> which are covered in 
							<a href="#extensionMethods">their own section</a>.
						</p>
						</section>
						<!--  section -->
						<section id="methods" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Methods</h2>
						<p>
							Xtend methods are declared within a class and are translated to a corresponding Java method with 
							exactly the same signature. The only exceptions are dispatch methods, which are explained 
							<a href="#polymorphicDispatch">later</a>. 
							</p>
							<pre class="prettyprint lang-xtend linenums">
def String first(List&lt;String&gt; elements) {
  elements.get(0)
}</pre>
							<p>
						</p>
						<p>
							The default visibility of a plain method is <code class="prettyprint lang-xtend">public</code>. You can explicitly declare it as
							being <code class="prettyprint lang-xtend">public</code>, <code class="prettyprint lang-xtend">protected</code>, or <code class="prettyprint lang-xtend">private</code>.
						</p>
						<p>
							Xtend supports the <code class="prettyprint lang-xtend">static</code> modifier for methods:
							</p>
							<pre class="prettyprint lang-xtend linenums">
def static createInstance() {
  new MyClass('foo')
}</pre>
							<p>
						</p>
						<p>
							As in Java 5, Xtend allows vararg parameters:
							</p>
							<pre class="prettyprint lang-xtend linenums">
def printAll(String... strings) {
  strings.forEach[ s | println(s) ]
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="abstractMethods" style="padding-top: 68px; margin-top: -68px;">
						<h3>Abstract Methods</h3>
						<p>
							An abstract method in Xtend just does not define a body and must be declared within an <code class="prettyprint lang-xtend">abstract</code>
							class. Also specifying the return type is mandatory since it cannot be inferred.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
abstract class MyAbstractClass() {
  def String abstractMethod() // no body
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_6" style="padding-top: 68px; margin-top: -68px;">
						<h3>Overriding Methods</h3>
						<p>
							Methods can override other methods from the super class or implement interface methods using the
							keyword <code class="prettyprint lang-xtend">override</code>. If a method overrides a method from a super type, the 
							<code class="prettyprint lang-xtend">override</code> keyword is mandatory and replaces the keyword <code class="prettyprint lang-xtend">def</code>. As in Java 
							<code class="prettyprint lang-java">final</code> methods cannot be overridden by subclasses.
						</p>
						<p>
							Example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
override String second(List&lt;String&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="declaredExceptions" style="padding-top: 68px; margin-top: -68px;">
						<h3>Declared Exceptions</h3>
						<p>
							Xtend does not force you to catch or redeclare checked exceptions. Nevertheless, you can still declare 
							the exceptions thrown in a method's body using the same <code class="prettyprint lang-xtend">throws</code> clause as in Java.
						</p>
						<p>
							If you do not declare checked exceptions in your method but they are possibly thrown in your code, the
							compiler will rethrow the checked exception silently (using the sneaky-throw technique introduced by 
							<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>). 
							  
							</p>
							<pre class="prettyprint lang-xtend linenums">
/*
 * throws an Exception
 */
def void throwException() throws Exception {
   throw new Exception
}

/*
 * throws an Exception without declaring it
 */
def void sneakyThrowException() {
   throw new Exception
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="inferredReturnTypes" style="padding-top: 68px; margin-top: -68px;">
						<h3>Inferred Return Types</h3>
						<p>
							If the return type of a method can be inferred from its body it does not have to be declared.
						</p>
						<p>
							That is the method
							</p>
							<pre class="prettyprint lang-xtend linenums">
def String second(List&lt;String&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						<p>
							could be declared like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
def second(List&lt;String&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						<p>
							This does not work for abstract method declarations as well as if the return type of a method 
							depends on a recursive call of the same method.
						</p>
						</section>
						<!-- subsection -->
						<section id="genericMethods" style="padding-top: 68px; margin-top: -68px;">
						<h3>Generic Methods</h3>
						<p>
							You can specify type parameters just like in Java. To generalize the method from the previous section,
							you would declare it like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def &lt;T&gt; second(List&lt;T&gt; elements) {
  elements.get(1)
}</pre>
							<p>
						</p>
						<p>
							Also bounds and the like are supported and share the same syntax as defined in the 
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/classes.html#8.4.4">the Java Language Specification</a>
						</p>
						</section>
						<!-- subsection -->
						<section id="polymorphicDispatch" style="padding-top: 68px; margin-top: -68px;">
						<h3>Dispatch Methods</h3>
						<p>
							Generally, method binding works just like method binding in Java. Method calls are bound 
							based on the static types of arguments. Sometimes this is not what you want. Especially in the 
							context of <a href="#extensionMethods">extension methods</a> you would like to have polymorphic behavior.
						</p>
						<p>
							A dispatch method is marked using the keyword <code class="prettyprint lang-xtend">dispatch</code>.
							</p>
							<pre class="prettyprint lang-xtend linenums">
def dispatch printType(Number x) { 
  "it's a number" 
}

def dispatch printType(Integer x) { 
  "it's an int" 
}</pre>
							<p>
						</p>
						<p>
							For a set of visible dispatch methods in the current type hierarchy sharing the same name and the same
							number of arguments, the compiler infers a synthetic method (the dispatcher) using the common super type of all declared arguments.
							The actual dispatch methods are reduced in visibility and renamed (prepending an underscore) so that client code always binds to
							the dispatcher method.
						</p>
						<p>
							For the two dispatch methods in the example above the following Java code would be generated:
							</p>
							<pre class="prettyprint lang-java linenums">
protected String _printType(final Number x) {
  return "it\'s a number";
}

protected String _printType(final Integer x) {
  return "it\'s an int";
}

public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre>
							<p>
						</p>
						<p>
							Note that the <code class="prettyprint lang-java">instanceof</code> cascade is ordered such that more specific types come first.
						</p>
						<p>
							The default visibility of the underscore methods is <code class="prettyprint lang-xtend">protected</code>. If all dispatch methods
							explicitly declare the same visibility, this will be the visibility of the inferred dispatcher, too.
							Otherwise it is <code class="prettyprint lang-xtend">public</code>.
							 
							The comparison of the type parameters goes from left to right. That is in the following example, the second
							method declaration is considered more specific since its first parameter type is the most specific:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def dispatch printTypes(Number x, Integer y) { 
  "it's some number and an int" 
}

def dispatch printTypes(Integer x, Number y) { 
  "it's an int and a number" 
}</pre>
							<p>
						</p>
						<p>
							generates the following Java code :
							</p>
							<pre class="prettyprint lang-java linenums">
public String printTypes(final Number x, final Number y) {
  if (x instanceof Integer
       &amp;&amp; y != null) {
    return _printTypes((Integer)x, y);
  } else if (x != null
       &amp;&amp; y instanceof Integer) {
    return _printTypes(x, (Integer)y);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x, y).toString());
  }
}</pre>
							<p>
						</p>
						<p>
							As you can see a <code class="prettyprint lang-xtend">null</code> reference is never a match. If you want to fetch <code class="prettyprint lang-xtend">null</code> 
							you can declare a dispatch case using the type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Void.html"><abbr title="java.lang.Void">Void</abbr></a>.
							</p>
							<pre class="prettyprint lang-xtend linenums">
def dispatch printType(Number x) { 
  "it's some number" 
}

def dispatch printType(Integer x) { 
  "it's an int" 
}

def dispatch printType(Void x) { 
  "it's null" 
}</pre>
							<p>
						</p>
						<p>
							This compiles to the following Java code:
							</p>
							<pre class="prettyprint lang-java linenums">
public String printType(final Number x) {
  if (x instanceof Integer) {
    return _printType((Integer)x);
  } else if (x != null) {
    return _printType(x);
  } else if (x == null) {
    return _printType((Void)null);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(x).toString());
  }
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="_7" style="padding-top: 68px; margin-top: -68px;">
						<h4>Dispatch Methods and Inheritance</h4>
						<p>
							Any visible Java methods from super types conforming to the compiled form of a dispatch method are
							also included in the dispatch. Conforming means they have the right number of arguments and have 
							the same name (starting with an underscore).
						</p>
						<p>
							For example, consider the following Java class :
							</p>
							<pre class="prettyprint lang-java linenums">
public abstract class AbstractLabelProvider {
   protected String _label(Object o) {
      // some generic implementation
   }
}</pre>
							<p>
						</p>
						<p>
							and the following Xtend class which extends the Java class :
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyLabelProvider extends AbstractLabelProvider {
   def dispatch label(Entity it)  {
     name
   }
     
   def dispatch label(Method it) { 
     name+"("+params.join(",")+"):"+type
   }
   
   def dispatch label(Field it) { 
     name+type
   }
}</pre>
							<p>
						</p>
						<p>
							The resulting dispatch method in the generated Java class <code class="prettyprint lang-xtend">MyLabelProvider</code> would then look like this:
							</p>
							<pre class="prettyprint lang-java linenums">
public String label(final Object it) {
  if (it instanceof Entity) {
    return _label((Entity)it);
  } else if (it instanceof Field) {
    return _label((Field)it);
  } else if (it instanceof Method) {
    return _label((Method)it);
  } else if (it != null) {
    return super._label(it);
  } else {
    throw new IllegalArgumentException("Unhandled parameter types: " +
      Arrays.&lt;Object&gt;asList(it).toString());
  }
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_8" style="padding-top: 68px; margin-top: -68px;">
						<h4>Static Dispatch Methods</h4>
						<p>
							Also static dispatch methods are supported. But you cannot mix static and non-static
							dispatch methods.
						</p>
						</section>
						</section>
						</section>
						<!--  section -->
						<section id="Annotations" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Annotations</h2>
						<p>
							The syntax and semantics for annotations is exactly like defined in the 
							<a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java Language Specification</a>. 
							Annotations are available on classes, fields, methods and parameters. Here is an example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@TypeAnnotation("some value")
class MyClass {
  @FieldAnnotation(children = {@MyAnno(true), @MyAnno(false)})
  String myField
  
  @MethodAnnotation(children = {@MyAnno(true), @MyAnno})
  def String myMethod(@ParameterAnnotation String param) {
    //...
  }
}</pre>
							<p>
						</p>
						<p>
							Certain annotations defined in the library have a special effect on how the code is translated to Java.
							These annotations are explained in <a href="#processedAnnotations">section</a>.
						</p>
						</section>
						<!--  section -->
						<section id="extensionMethods" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Extension Methods</h2>
						<p>
							Extension methods allow to add new methods to existing types without modifying them. 
							This feature is actually where Xtend got its name from. They are based on a simple syntactic trick: 
							Instead of passing the first argument of an extension method inside the parentheses of a call, the 
							method is called on the argument parameter as if it was one of its members.
							</p>
							<pre class="prettyprint lang-xtend linenums">
"hello".toFirstUpper() // calls toFirstUper("hello")</pre>
							<p>
						</p>
						<p>
							Method calls in extension syntax often result in more readable code, as they are chained rather than nested. 
							Another benefit of extensions is that you can add methods which are specific to a certain context
							or layer of your application. You might for instance not want to put UI-specific methods and dependencies to your
							domain model classes. Therefore such functionality is often defined in static methods or methods in
							some "service class". That works, but the code is less readable and less object-oriented if you call methods
							like this. In Java for instance you often see code like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
persistenceManager.save(myObject);</pre>
							<p>
						</p>
						<p>
							Without tying your entities to the persistenceManager, extension methods allow you to write
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObject.save</pre>
							<p>
						</p>
						<p>
							There are different ways to make methods available as extensions, which are described in the following.
						</p>
						<!-- subsection -->
						<section id="libraryExtensions" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extensions From The Library</h3>
						<p>
							The <a href="#library">library</a> puts a lot of very useful extension methods on existing types from the Java
							SDK without any further ado.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
"hello".toFirstUpper // calls StringExtensions.toFirstUpper(String)
listOfStrings.map[ toUpperCase ] // calls ListExtensions.&lt;T, R&gt;map(List&lt;T&gt; list, Function&lt;? super T, ? extends R&gt; mapFunction)</pre>
							<p>
						</p>
						<p>
							Have a look at the JavaDoc to see what is there:
						</p>
						<p>
							</p>
							<ul>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/ObjectExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.ObjectExtensions">ObjectExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ObjectExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IterableExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IterableExtensions">IterableExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/MapExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.MapExtensions">MapExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/MapExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/ListExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.ListExtensions">ListExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ListExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/CollectionExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.CollectionExtensions">CollectionExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/CollectionExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/BooleanExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.BooleanExtensions">BooleanExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/IntegerExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.IntegerExtensions">IntegerExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerExtensions.java">(src)</a></li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/FunctionExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.FunctionExtensions">FunctionExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/FunctionExtensions.java">(src)</a></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_9" style="padding-top: 68px; margin-top: -68px;">
						<h3>Local Extension Methods</h3>
						<p>
							All visible non-static methods of the current class and its super types are automatically available as extensions. For example
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyClass {
  def doSomething(Object obj) {
    // do something with obj
  }
  
  def extensionCall(Object obj) {
    obj.doSomething()  // calls this.doSomething(obj)
  }
}</pre>
							<p>
						</p>
						<p>
							Local static methods have to be made available through an import like any other static method.
						</p>
						</section>
						<!-- subsection -->
						<section id="extensionImports" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extension Imports</h3>
						<p>
							In Java, you would usually write a helper class with static methods to decorate an existing
							class with additional behavior. In order to integrate such static helper classes, Xtend allows to put
							the keyword <code class="prettyprint lang-xtend">extension</code> after the <code class="prettyprint lang-xtend">static</code> keyword of a <a href="#imports">static import</a>
							thus making all imported static functions available as extensions methods.
						</p>
						<p>
							The following import declaration 
							</p>
							<pre class="prettyprint lang-xtend linenums">
import static extension java.util.Collections.*</pre>
							<p>
						</p>
						<p>
							allows to use its methods like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
new MyClass().singletonList() 
  // calls Collections.singletonList(new MyClass())</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Extension_Fields" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extension Fields</h3>
						<p>
							By adding the <code class="prettyprint lang-xtend">extension</code> keyword to a field declaration, its instance methods become extension methods.
						</p>
						<p>
							Imagine you want to have some layer specific functionality on a class <code class="prettyprint lang-xtend">Person</code>. Let us say you are in a servlet-like class
							and want to persist a <code class="prettyprint lang-xtend">Person</code> using some persistence mechanism. Let us assume <code class="prettyprint lang-xtend">Person</code> implements
							a common interface <code class="prettyprint lang-xtend">Entity</code>.
							 
							You could have the following interface
							</p>
							<pre class="prettyprint lang-java linenums">
interface EntityPersistence {
  public save(Entity e);
  public update(Entity e);
  public delete(Entity e);
}</pre>
							<p>
						</p>
						<p>
							And if you have obtained an instance of that type (through a factory or dependency injection or what ever) like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MyServlet {
  extension EntityPersistence ep = Factory.get(typeof(EntityPersistence))
  ...
  
}</pre>
							<p>
						</p>
						<p>
							You are able to save, update and delete any entity like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val Person person = ...
person.save  // calls ep.save(person)
person.name = 'Horst'
person.update  // calls ep.update(person)
person.delete  // calls ep.delete(person)</pre>
							<p>
						</p>
						<p>
							Using the <code class="prettyprint lang-xtend">extension</code> modifier on fields has a significant advantage over 
							static <a href="#extensionImports">extension imports</a>: Your code is not bound to the actual implementation of the extension method.
							You can simply exchange the component that provides the referenced extension with another implementation from outside,
							by providing a different instance. No matter whether you do so via a factory, a dependency injection
							container or simply using a setter.
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="Xtend_Expressions" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Expressions
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Xtend does not have statements. Instead, everything is an expression and has a return value. That
							allows to compose your code in interesting ways. For example, you can have a
							<code class="prettyprint lang-xtend">try catch</code> expression on the right hand side of an assignment: 
							</p>
							<pre class="prettyprint lang-xtend linenums">
val data = try {
    fileContentsToString('data.txt')
  } catch (IOException e) {
  'dummy data'
  }</pre>
							<p>
						</p>
						<p>
							If <code class="prettyprint lang-xtend">fileContentsToString()</code> throws an <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/IOException.html"><abbr title="java.io.IOException">IOException</abbr></a>, it is caught and the string <code class="prettyprint lang-xtend">'dummy data'</code> is assigned to the value <code class="prettyprint lang-xtend">data</code>.
							 
							Expressions can appear as <a href="#fields">initializers of fields</a>, the body of constructors
							or methods and as values in annotations. A method body can either be a <a href="#blocks">block expression</a> 
							or a <a href="#templates">template expression</a>.
						</p>
						<!--  section -->
						<section id="Xtend_Expressions_Literals" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Literals</h2>
						<p>
							A literal denotes a fixed unchangeable value. Literals for <a href="#stringLiterals">strings</a>, <a href="#numberLiterals">numbers</a>, <a href="#booleanLiteral">booleans</a>,
							<code class="prettyprint lang-xtend">null</code> and <a href="#typeLiteral">Java types</a> are supported.
						</p>
						<!-- subsection -->
						<section id="stringLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>String Literals</h3>
						<p>
							A string literal is of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> (just like in Java).
							String literals are enclosed in a pair of single quotes or double quotes. We mostly use single quotes
							because the signal-to-noise ration is a bit better, but generally you should use the terminals which are
							least likely occure in the actual string. Special characters can be quoted with a backslash or defined using
							Java's unicode notation. Contrary to Java, strings can span multiple lines.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
'Hello World !'
"Hello World !"
'Hello "World" !'
"Hello \"World\" !"
"Hello 

  World !"</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="numberLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>Number Literals</h3>
						<p>
							Xtend supports roughly the same number literals as Java with a few differences.   
							First, there are no signed number literals. If you put a minus operator in front of an number 
							literal it is taken as a <a href="#operators">unary operator</a> with one argument (the positive number 
							literal). Second, as in Java 7, you can separate digits using <code class="prettyprint lang-xtend">_</code> for better readability
							of large numbers.
							 
							An integer literal creates an <code class="prettyprint lang-xtend">int</code>, a <code class="prettyprint lang-xtend">long</code> (suffix <code class="prettyprint lang-xtend">L</code>) or a
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigInteger.html"><abbr title="java.math.BigInteger">BigInteger</abbr></a> (suffix <code class="prettyprint lang-xtend">BI</code>). There are no octal numbers
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
42
1_234_567_890 
0xbeef    // hexadecimal
077       // decimal 77 (*NOT* octal)
-1  // an expression consisting of the unary - operator and an integer literal  
42L
0xbeef#L // hexadecimal, mind the '#'
0xbeef_beef_beef_beef_beef#BI // BigInteger</pre>
							<p>
						</p>
						<p>
							A floating-point literal creates a <code class="prettyprint lang-xtend">double</code> (suffix <code class="prettyprint lang-xtend">D</code> or none), a <code class="prettyprint lang-xtend">float</code> 
							(suffix <code class="prettyprint lang-xtend">F</code>) or a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html"><abbr title="java.math.BigDecimal">BigDecimal</abbr></a> (suffix <code class="prettyprint lang-xtend">BD</code>). If you use a <code class="prettyprint lang-xtend">.</code> you have to 
							specify both, the integer and the fractional part of the mantissa. There are only decimal floating-point 
							literals.  
							</p>
							<pre class="prettyprint lang-xtend linenums">
42d     // double
0.42e2  // implicit double
0.42e2f // float
4.2f    // float
0.123_456_789_123_456_789_123_456_789e2000bd // BigDecimal</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="booleanLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h3>Boolean Literals</h3>
						<p>
							There are two boolean literals, <code class="prettyprint lang-xtend">true</code> and <code class="prettyprint lang-xtend">false</code> which correspond to their 
							Java counterpart of type <code class="prettyprint lang-xtend">boolean</code>.
						</p>
						</section>
						<!-- subsection -->
						<section id="nullLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h3>Null Literal</h3>
						<p>
							The null pointer literal <code class="prettyprint lang-xtend">null</code> has exactly the same semantics as in Java.
						</p>
						</section>
						<!-- subsection -->
						<section id="typeLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h3>Type Literals</h3>
						<p>
							Type literals are specified using the keyword <code class="prettyprint lang-xtend">typeof</code> :
							</p>
							<pre class="prettyprint lang-xtend linenums">
typeof(java.lang.String) // yields java.lang.String.class</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="typeCasts" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Type Casts</h2>
						<p>
							A type cast behaves exactly like casts in Java, but has a slightly more readable syntax.
							Type casts bind stronger than any other operator but weaker than feature calls.
						</p>
						<p>
							The conformance rules for casts are defined in the 
							<a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5">Java Language Specification</a>.
							Here are some examples:
							</p>
							<pre class="prettyprint lang-xtend linenums">
something as MyClass
42 as Integer</pre>
							<p>
						</p>
						<p>
							Although casts are supported you might want to use a <a href="#switchExpression">switch with a type guard</a> or a 
							<a href="#polymorphicDispatch">dispatch method</a> as a better and safer alternative.
						</p>
						</section>
						<!--  section -->
						<section id="operators" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Infix Operators and Operator Overloading</h2>
						<p>
							There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
							to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
							operators for any type just by implementing the corresponding method signature. As an example, the 
							<a href="#library">Xtend runtime library</a> contains a class <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/BigDecimalExtensions.html"><abbr title="org.eclipse.xtext.xbase.lib.BigDecimalExtensions">BigDecimalExtensions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BigDecimalExtensions.java">(src)</a> that defines operators for 
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html">BigDecimals</a> which allows the following code:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val x = 2.71BD
val y = 3.14BD
val sum = x + y    // calls BigDecimalExtension.operator_plus(x,y)</pre>
							<p>
						</p>
						<p>
							This is the complete list of all available operators and their corresponding method signatures:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><code class="prettyprint lang-xtend">e1 += e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_add(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 || e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_or(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &amp;&amp; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_and(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 == e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_equals(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 != e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_notEquals(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_lessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_lessEqualsThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterEqualsThan(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 -&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_mappedTo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 .. e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_upTo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 =&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleArrow(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleGreaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&lt;&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;&gt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleGreaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_diamond(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ?: e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_elvis(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;=&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_spaceship(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 + e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_plus(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 - e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minus(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 * e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_multiply(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 / e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_divide(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 % e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_modulo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ** e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_power(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">! e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_not()</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">- e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minus()</code></td>
							</tr>
							</table>
							<p>
							
							    
							The table above also defines the operator precedence in ascending order. The blank lines separate 
							precedence levels. The assignment operator <code class="prettyprint lang-xtend">+=</code> is right-to-left associative in the same way 
							as the plain assignment operator <code class="prettyprint lang-xtend">=</code> is. That is a = b = c is executed as a = (b = c), all
							other operators are left-to-right associative. Parenthesis can be used to adjust the default 
							precedence and associativity.
						</p>
						<!-- subsection -->
						<section id="_10" style="padding-top: 68px; margin-top: -68px;">
						<h3>Short-Circuit Boolean Operators</h3>
						<p>
							If the operators <code class="prettyprint lang-xtend">||</code> and <code class="prettyprint lang-xtend">&amp;&amp;</code> are bound to the library methods 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/BooleanExtensions.html"><code class="prettyprint lang-xtend">BooleanExtensions.operator_and(boolean l, boolean r)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">(src)</a> resp. 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/BooleanExtensions.html"><code class="prettyprint lang-xtend">BooleanExtensions.operator_or(boolean l, boolean r)</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">(src)</a> the operation is evaluated in short circuit mode.
							That means that the right hand operand might not be evaluated at all in the following cases: 
							</p>
							<ol>
								<li>in the case of <code class="prettyprint lang-xtend">||</code> the operand on the right hand side is not evaluated if the left 
								    operand evaluates to <code class="prettyprint lang-xtend">true</code>.</li>
								<li>in the case of <code class="prettyprint lang-xtend">&amp;&amp;</code> the operand on the right hand side is not evaluated if the left 
								    operand evaluates to <code class="prettyprint lang-xtend">false</code>.</li>
							</ol>
							<p>
						</p>
						<p>
							Still you can overload these operators for your types or even override it for booleans, in which case
							both operands are always evaluated and the defined method is invoked, i.e. no short-circuit execution is happening.
						</p>
						</section>
						<!-- subsection -->
						<section id="_11" style="padding-top: 68px; margin-top: -68px;">
						<h3>Examples</h3>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
my.property = 23
myList += 23
x &gt; 23 &amp;&amp; y &lt; 23
x &amp;&amp; y || z
1 + 3 * 5 * (- 23)
!(x)</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="assignments" style="padding-top: 68px; margin-top: -68px;">
						<h3>Assignments</h3>
						<p>
							<a href="#variableDeclaration">Local variables</a> can be reassigned using the <code class="prettyprint lang-xtend">=</code> operator.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
var greeting = 'Hello'
if (isInformal)
  greeting = 'Hi'</pre>
							<p>
						</p>
						<p>
							Of course, also non-final fields can be set using an assignment: 
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObj.myField = 'foo'</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="propertyAssignments" style="padding-top: 68px; margin-top: -68px;">
						<h4>Setting Properties</h4>
						<p>
							The lack of properties in Java leads to a lot of syntactic noise when working with data objects.
							As Xtend is designed to integrate with existing Java APIs it respects the Java Beans convention,
							hence you can call a setter using an assignment:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
myObj.myProperty = 'foo' // calls myObj.setMyProperty("foo")</pre>
							<p>
						</p>
						<p>
							The setter is only used if the field is not accessible from the given context. That is why the 
							<a href="#propertyAnnotation">@Property annotation</a> would rename the local field to <code class="prettyprint lang-xtend">_myProperty</code>.
						</p>
						<p>
							The return type of an assignment is the type of the right hand side, in case it is a simple assignment.
							If it is translated to a setter method it yields whatever the setter method returns.
						</p>
						</section>
						</section>
						</section>
						<!--  section -->
						<section id="blocks" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Blocks</h2>
						<p>
							The block expression allows to have imperative code sequences. It consists of a sequence of 
							expressions, and returns the value of the last expression. The return type of a block is also the 
							type of the last expression. Empty blocks return <code class="prettyprint lang-xtend">null</code>. 
							<a href="#variableDeclaration">Variable declarations</a> are only allowed within blocks and cannot be used as 
							a block's last expression.
						</p>
						<p>
							A block expression is surrounded by curly braces and contains at least one expression. It can 
							optionally be terminated by a semicolon.
						</p>
						<p>
							Here are two examples:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  doSideEffect("foo")
  result
}</pre>
							<p>
							
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  var x = greeting
  if (x.equals("Hello ")) {
    x + "World!" 
  } else {
    x
  }
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="variableDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Variable Declarations</h2>
						<p>
							Variable declarations are only allowed within <a href="#blocks">blocks</a>. They are visible in any 
							subsequent expressions in the block.
						</p>
						<p>
							A variable declaration starting with the keyword <code class="prettyprint lang-xtend">val</code> denotes a value, which
							is essentially a final (i.e. unsettable) variable. In some cases, one needs to update the value of 
							a reference. In such situations the variable needs to be declared with the keyword <code class="prettyprint lang-xtend">var</code>, 
							which stands for 'variable'.
						</p>
						<p>
							A typical example for using <code class="prettyprint lang-xtend">var</code> is a counter in a loop:
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  val max = 100
  var i = 0
  while (i &lt; max) {
    println("Hi there!")
    i = i + 1
  }
}</pre>
							<p>
						</p>
						<p>
							Shadowing variables from outer scopes is not allowed, the only exception is the 
							<a href="#implicitVariables">implicit variable</a> <code class="prettyprint lang-xtend">it</code>.
						</p>
						<p>
							Variables declared outside a lambda expression using the <code class="prettyprint lang-xtend">var</code> keyword are not accessible from within a
							lambda expressions.
						</p>
						<!-- subsection -->
						<section id="_12" style="padding-top: 68px; margin-top: -68px;">
						<h3>Typing</h3>
						<p>
							The type of the variable itself can either be explicitly declared or be inferred from the right hand side
							expression. Here is an example for an explicitly declared type:
							</p>
							<pre class="prettyprint lang-xtend linenums">
var List&lt;String&gt; msg = new ArrayList</pre>
							<p>
						</p>
						<p>
							In such cases, the type of the right hand expression must conform to the type 
							of the expression on the left side.
						</p>
						<p>
							Alternatively the type can be left out and will be inferred from the initialization expression:  
							</p>
							<pre class="prettyprint lang-xtend linenums">
var msg = new ArrayList&lt;String&gt; // -&gt; msg is of type ArrayList&lt;String&gt;</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="featureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Field Access and Method Invocation</h2>
						<p>
							A simple name can refer to a local field, variable or parameter. In addition
							it can point to a method with zero arguments, since empty parenthesis are optional.
						</p>
						<!-- subsection -->
						<section id="propertyAccess" style="padding-top: 68px; margin-top: -68px;">
						<h3>Property Access</h3>
						<p>
							If there is no field with the given name and also no method with the name and zero parameters
							accessible, a simple name binds to a corresponding Java-Bean getter method if available :
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myObj.myProperty // myObj.getMyProperty()  (.. in case myObj.myProperty is not visible.)</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="implicitVariables" style="padding-top: 68px; margin-top: -68px;">
						<h3>Implicit Variables <strong>this</strong> and <strong>it</strong></h3>
						<p>
							Like in Java an instance of the class is bound to <code class="prettyprint lang-xtend">this</code>. Which allows for either qualifying
							field access or method invocations like in:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
this.myField</pre>
							<p>
						</p>
						<p>
							or omit the receiver:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
myField</pre>
							<p>
						</p>
						<p>
							You can use the variable name <code class="prettyprint lang-xtend">it</code> to get the same behavior for any variable or parameter:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val it = new Person
name = 'Horst' // translates to 'it.setName("Horst");'</pre>
							<p>
						</p>
						<p>
							Another speciality of the variable <code class="prettyprint lang-xtend">it</code> is that it can be shadowed. This is especially useful
							when used together with <a href="#lambdas">lambda expressions</a>.
						</p>
						<p>
							As <code class="prettyprint lang-xtend">this</code> is bound to the surrounding object in Java, <code class="prettyprint lang-xtend">it</code> can be used
							in finer-grained constructs such as <a href="#lambdas">lambda expressions</a>. That is why <code class="prettyprint lang-xtend">it.myProperty</code> has 
							higher precedence than <code class="prettyprint lang-xtend">this.myProperty</code>.
						</p>
						</section>
						<!-- subsection -->
						<section id="staticAccess" style="padding-top: 68px; margin-top: -68px;">
						<h3>Static Access</h3>
						<p>
							For accessing a static field or method you have to use the double colon <code class="prettyprint lang-xtend">::</code> like in this example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
MyClass::myField
MyClass::myMethod('foo')</pre>
							<p>
						</p>
						<p>
							Alternatively you could import the method using a <a href="#imports">static import</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="nullSafeFeatureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h3>Null-Safe Feature Call</h3>
						<p>
							Checking for <code class="prettyprint lang-xtend">null</code> references can make code very unreadable. In many situations it is ok for an 
							expression to return <code class="prettyprint lang-xtend">null</code> if a receiver was <code class="prettyprint lang-xtend">null</code>. Xtend supports the safe navigation 
							operator <code class="prettyprint lang-xtend">?.</code> to make such code better readable.
						</p>
						<p>
							Instead of writing 
							</p>
							<pre class="prettyprint lang-java linenums">
if (myRef != null) myRef.doStuff()</pre>
							<p>
						</p>
						<p>
							one can write
							</p>
							<pre class="prettyprint lang-xtend linenums">
myRef?.doStuff</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="constructorCall" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Constructor Call</h2>
						<p>
							Constructor calls have the same syntax as in Java. The only difference is that empty parenthesis
							are optional:
							</p>
							<pre class="prettyprint lang-xtend linenums">
new String() == new String
new ArrayList&lt;BigDecimal&gt;() == new ArrayList&lt;BigDecimal&gt;</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="lambdas" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Lambda Expressions</h2>
						<p>
							A lambda expression is basically a piece of code, which is wrapped in an object to pass it around. As
							a Java developer it is best to think of a lambda expression as an anonymous class, i.e. 
							like in the following Java code :
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
// Java Code!
final JTextField textField = new JTextField();
textField.addActionListener(new ActionListener() {
  @Override
  public void actionPerformed(ActionEvent e) {
    textField.setText("Something happened!");
  }
});</pre>
							<p>
						</p>
						<p>
							This kind of anonymous classes can be found everywhere in Java code and have always been the poor-man's replacement
							for lambda expressions in Java.
						</p>
						<p>
							Xtend not only supports lambda expressions, but offers an extremely dense syntax for it. That is the
							code above can be written in Xtend like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val textField = new JTextField
textField.addActionListener([ ActionEvent e |
  textField.text = "Something happened!"
])</pre>
							<p>
						</p>
						<p>
							As you might have guessed, a lambda expression is surrounded by square brackets (inspired from Smalltalk).
							Also a lambda expression like a method declares parameters. The lambda above has one parameter called <code class="prettyprint lang-xtend">e</code> which is of
							type <code class="prettyprint lang-xtend">ActionEvent</code>. You do not have to specify the type explicitly because it can be inferred from
							the context:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
textField.addActionListener([ e |
  textField.text = "Something happened!"
])</pre>
							<p>
						</p>
						<p>
							Also as lambdas with one parameter are a common case, there is a special short hand for them,
							which is to leave the declaration including the vertical bar out. The name of the <a href="#implicitVariables">single variable</a>
							will be <code class="prettyprint lang-xtend">it</code> in that case:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
textField.addActionListener([
  textField.text = "Something happened!"
])</pre>
							<p>
						</p>
						<p>
							A lambda expression with zero arguments is written like this (note the bar after the opening bracket):
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val Runnable runnable = [ |
  println("Hello I'm executed!")
]</pre>
							<p>
						</p>
						<p>
							When a method call's last parameter is a lambda it can be passed right after the parameter list.
							For instance if you want to sort some strings by their length, you could write :
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
Collections::sort(someStrings) [ a, b |
  a.length - b.length
]</pre>
							<p>
						</p>
						<p>
							which is just the same as writing
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
Collections::sort(someStrings, [ a, b |
  a.length - b.length
])</pre>
							<p>
						</p>
						<p>
							Since you can leave out empty parenthesis for methods which get a lambda as their only argument, you can reduce
							the code above further:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
textField.addActionListener [
  textField.text = "Something happened!"
]</pre>
							<p>
						</p>
						<p>
							A lambda expression also captures the current scope, so that any final variables and parameters visible at construction time can be referred to. 
							That is exactly what we did with the variable <code class="prettyprint lang-xtend">textField</code> above.
						</p>
						<!-- subsection -->
						<section id="closureTypes" style="padding-top: 68px; margin-top: -68px;">
						<h3>Typing</h3>
						<p>
							Lambdas are expressions which produce <strong>Function</strong> objects. The type of a lambda expression generally depends on the target
							type, as seen in the previous examples. That is, the lambda expression can coerce to any interface which has declared only 
							one method (in addition to the ones inherited from <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html"><abbr title="java.lang.Object">Object</abbr></a>). This allows for using lambda expressions in many existing Java
							APIs directly.
						</p>
						<p>
							However, if you write a lambda expression without having any target type expectation, like in the following
							assignment:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val toUpperCaseFunction = [ String s | s.toUpperCase ] // inferred type is (String)=&gt;String</pre>
							<p>
						</p>
						<p>
							The type will be one of the types found in <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.html"><abbr title="org.eclipse.xtext.xbase.lib.Functions">Functions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a> or <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Procedures.html"><abbr title="org.eclipse.xtext.xbase.lib.Procedures">Procedures</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a>.
							It is a procedure if the return type is <code class="prettyprint lang-xtend">void</code>, otherwise it is a function.
						</p>
						<p>
							Xtend supports a shorthand syntax for function types. Instead of writing <code class="prettyprint lang-xtend">Function1&lt;? super String,? extends String&gt;</code>
							which is what you will find in the generated Java code, you can simply write <code class="prettyprint lang-xtend">(String)=&gt;String</code>.
						</p>
						<p>
							Example:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val (String)=&gt;String stringToStringFunction = [ toUpperCase ]
// or
val Function1&lt;? super String,? extends String&gt; same = [ toUpperCase ]
// or
val stringToStringFunction2 = [ String s | s.toUpperCase ] // inferred type is (String)=&gt;String</pre>
							<p>
						</p>
						<p>
							Checked exceptions that are thrown in the body of a lambda expression but not declared in the implemented method of the target type are rethrown using the 
							<a href="#declaredExceptions">sneaky-throw technique</a>.
							Of course you can always <a href="#Xtend_Expressions_TryCatch">catch and handle</a> them.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="ifExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">If Expression</h2>
						<p>
							An if expression is used to choose between two different values based on a predicate.
						</p>
						<p>
							An expression 
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (p) e1 else e2</pre>
							<p>
							 
							results in either the value <code class="prettyprint lang-xtend">e1</code> or <code class="prettyprint lang-xtend">e2</code> depending on whether the predicate <code class="prettyprint lang-xtend">p</code> evaluates 
							to <code class="prettyprint lang-xtend">true</code> or <code class="prettyprint lang-xtend">false</code>. The else part is optional which is a shorthand for <code class="prettyprint lang-xtend">else null</code>. That means
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (foo) x</pre>
							<p>
						</p>
						<p>
							is a short hand for
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
if (foo) x else null</pre>
							<p>
						</p>
						<p>
							The type of an if expression is the common super type of the return types <code class="prettyprint lang-xtend">T1</code> and <code class="prettyprint lang-xtend">T2</code> 
							of the two expression <code class="prettyprint lang-xtend">e1</code> and <code class="prettyprint lang-xtend">e2</code>.
						</p>
						<p>
							While the if expression has the syntax of Java's if statement it behaves more like Java's ternary operator 
							(<code class="prettyprint lang-java">predicate ? thenPart : elsePart</code>), because it is an expression and returns a value.
							Consequently, you can use if expressions deeply nested within expressions:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val name = if (firstName != null) firstName + ' ' + lastName else lastName</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="switchExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Switch Expression</h2>
						<p>
							The switch expression is very different from Java's switch statement. First, there is no fall through which means 
							only one <code class="prettyprint lang-xtend">case</code> is evaluated at most. Second, the use of <code class="prettyprint lang-xtend">switch</code> is not limited 
							to certain values but can be used for any object reference instead. <code class="prettyprint lang-xtend">Object.equals(Object)</code> is used to
							compare the value in the case with the one you are switching over.
							 
							Given the following example:
							 
							</p>
							<pre class="prettyprint lang-xtend linenums">
switch myString {
  case myString.length&gt;5 : "a long string."
  case 'some' : "It's some string."
  default : "It's another short string."
}</pre>
							<p>
						</p>
						<p>
							the main expression <code class="prettyprint lang-xtend">numberAsText</code> is evaluated first and then compared to each case sequentially.
							If the case expression is of type <code class="prettyprint lang-xtend">boolean</code>, the case matches if the expression evaluates
							to <code class="prettyprint lang-xtend">true</code>. If it is not of type <code class="prettyprint lang-xtend">boolean</code> it is compared to the value from the main
							expression using <code class="prettyprint lang-xtend">Object.equals(Object)</code>.
						</p>
						<p>
							If a case is a match, that is it evaluates to <code class="prettyprint lang-xtend">true</code> or the result equals the one we are switching
							over, the case expression after the colon is evaluated and is the result of the whole expression.
						</p>
						<!-- subsection -->
						<section id="_13" style="padding-top: 68px; margin-top: -68px;">
						<h3>Type guards</h3>
						<p>
							Instead of or in addition to the case guard you can specify a <strong>type guard</strong>. The case only matches if the 
							switch value conforms to this type. A case with both a type guard and a predicate only matches if both match.
							If the switch value is a variable, this variable is automatically casted to the given type within the
							predicate and the case's body.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def length(Object x) {
  switch x {
    String case x.length &gt; 0 : x.length // length is defined for String 
    List&lt;?&gt; : x.size    // size is defined for List
    default : -1
  }
}</pre>
							<p>
						</p>
						<p>
							Switches with type guards are a safe and much more readable alternative to instance of / casting orgies you 
							might know from Java.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="forLoop" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">For Loop</h2>
						<p>
							The for loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (T1 variable : arrayOrIterable) expression</pre>
							<p>
							 
							is used to execute a certain expression for each element of an array or an instance of 
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><abbr title="java.lang.Iterable">Iterable</abbr></a>. The local <code class="prettyprint lang-xtend">variable</code> is final, hence canot be updated.
						</p>
						<p>
							The return type of a for loop is <code class="prettyprint lang-xtend">void</code>. The type of the local variable can be left out. 
							In that case it is inferred from the type of the array or <code class="prettyprint lang-xtend">java.lang.Iterable</code> returned by the 
							iterable expression.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
for (String s : myStrings) {
  doSideEffect(s)
}

for (s : myStrings)
  doSideEffect(s)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="whileExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">While Loop</h2>
						<p>
							A while loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
while (predicate) expression</pre>
							<p>
							 
							is used to execute a certain expression unless the predicate is evaluated to <code class="prettyprint lang-xtend">false</code>. 
							The return type of a while loop is <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
while (true) {
  doSideEffect("foo")
}

while ((i=i+1) &lt; max) 
  doSideEffect("foo")</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="doWhileExpression" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Do-While Loop</h2>
						<p>
							A do-while loop 
							</p>
							<pre class="prettyprint lang-xtend linenums">
do expression while (predicate)</pre>
							<p>
							 
							is used to execute a certain expression until the predicate is evaluated to <code class="prettyprint lang-xtend">false</code>. 
							The difference to the <a href="#whileExpression">while loop</a> is that the execution starts by executing 
							the block once before evaluating the predicate for the first time. The return type of a do-while 
							loop is <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
do {
  doSideEffect("foo");
} while (true)


do doSideEffect("foo") while ((i=i+1)&lt;max)</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_Return" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Return Expression</h2>
						<p>
							A method or lambda expression automatically returns the value of its expression.
							If it is a <a href="#blocks">block expression</a> this is the value of the last expression in it.
							However, sometimes you want to return early or make it explicit.
						</p>
						<p>
							The syntax is just like in Java:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
listOfStrings.map(e| {
  if (e==null) 
    return "NULL"
  e.toUpperCase
})</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_Throw" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Throwing Exceptions</h2>
						<p>
							Throwing <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Throwable.html"><abbr title="java.lang.Throwable">Throwable</abbr></a>s up the call stack has the same semantics and syntax 
							as in Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
{
  ...
  if (myList.isEmpty)
    throw new IllegalArgumentException("the list must not be empty")
  ...
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="Xtend_Expressions_TryCatch" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Try, Catch, Finally</h2>
						<p>
							The try-catch-finally expression is used to handle exceptional situations.
							Checked exceptions are treated like runtime exceptions. You can but do not have to catch them as they
							will be silently rethrown (see the <a href="#declaredExceptions">section on declared exceptions</a>). The syntax 
							again is like Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
try {
  throw new RuntimeException()
} catch (NullPointerException e) {
  // handle e
} finally {
  // do stuff
}</pre>
							<p>
						</p>
						<p>
							For try-catch it is again beneficial that it is an expression, because you can write code like the following
							and do not have to rely on non-final variables:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
val name = try {
    person.name
  } catch (NullPointerException e) {
    "no name"
  }</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="templates" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Template Expressions</h2>
						<p>
							Templates allow for readable string concatenation. Templates are surrounded by triple single quotes (<code class="prettyprint lang-xtend">'''</code>). 
							A template expression can span multiple lines and expressions can be nested which are evaluated and their <code class="prettyprint lang-xtend">toString()</code> 
							representation is automatcially inserted at that position.
						</p>
						<p>
							The terminals for interpolated expression are so called guillemets <code class="prettyprint lang-xtend">&laquo;expression&raquo;</code>. They read nicely and are not often used
							in text so you seldomly need to escape them. These escaping conflicts are the reason why
							template languages often use longer character sequences like e.g. <code class="prettyprint lang-xtend">&lt;%= expression %&gt;</code> in JSP, for the price of worse readability. 
							The downside with the guillemets in Xtend is that you will have to have a consistent encoding. Always use UTF-8 and you are good.
						</p>
						<p>
							If you use the Eclipse plug-in - which is recommended - the guillemets will be inserted on content assist
							within a template. They are additionally bound to <strong>CTRL+SHIFT+&lt;</strong> and <strong>CTRL+SHIFT+</strong> for <code class="prettyprint lang-xtend">&laquo;</code> and <code class="prettyprint lang-xtend">&raquo;</code> respectively.
							On a Mac they are as well bound to <strong>alt+q</strong> (<code class="prettyprint lang-xtend">&laquo;</code>) and <strong>alt+Q</strong> (<code class="prettyprint lang-xtend">&raquo;</code>).
						</p>
						<p>
							Let us have a look at an example of how a typical method with a template expressions looks like:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(String content) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;content&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						<p>
							As you can see, template expressions can be used as the direct body of a method.
							If an interpolation expression evaluates to <code class="prettyprint lang-xtend">null</code> an empty string is added.
						</p>
						<p>
							Template expressions can occur everywhere. 
							Here is an example showing it in conjunction with the powerful <a href="#switchExpression">switch expression</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def toText(Node n) {
  switch n {
    Contents : n.text

    A : '''&lt;a href="&laquo;n.href&raquo;"&gt;&laquo;n.applyContents&raquo;&lt;/a&gt;'''

    default : '''
        &lt;&laquo;n.tagName&raquo;&gt;
          &laquo;n.applyContents&raquo;
        &lt;/&laquo;n.tagName&raquo;&gt;
    '''
  }
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="templateIF" style="padding-top: 68px; margin-top: -68px;">
						<h3>Conditions in Templates</h3>
						<p>
							There is a special <code class="prettyprint lang-xtend">IF</code> to be used within templates:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(Paragraph p) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;IF p.headLine != null&raquo;
        &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
      &laquo;ENDIF&raquo;
      &lt;p&gt;
        &laquo;p.text&raquo;
      &lt;/p&gt;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="templateFOREACH" style="padding-top: 68px; margin-top: -68px;">
						<h3>Loops in Templates</h3>
						<p>
							Also a <code class="prettyprint lang-xtend">FOR</code> statement is available:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(List&lt;Paragraph&gt; paragraphs) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs&raquo;
        &laquo;IF p.headLine != null&raquo;
          &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						<p>
							The for statement optionally allows to specify what to prepend (<code class="prettyprint lang-xtend">BEFORE</code>), put in-between (<code class="prettyprint lang-xtend">SEPARATOR</code>), and what to
							put at the end (<code class="prettyprint lang-xtend">AFTER</code>) of all iterations. <code class="prettyprint lang-xtend">BEFORE</code> and <code class="prettyprint lang-xtend">AFTER</code>
							are only executed if there is at least one iteration. (<code class="prettyprint lang-xtend">SEPARATOR</code>) is only added between
							iterations, that it is executed if there are at least two iterations.
						</p>
						<p>
							Here is an example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def someHTML(List&lt;Paragraph&gt; paragraphs) '''
  &lt;html&gt;
    &lt;body&gt;
      &laquo;FOR p : paragraphs BEFORE '&lt;div&gt;' SEPARATOR '&lt;/div&gt;&lt;div&gt;' AFTER '&lt;/div&gt;'&raquo;
        &laquo;IF p.headLine != null&raquo;
          &lt;h1&gt;&laquo;p.headline&raquo;&lt;/h1&gt;
        &laquo;ENDIF&raquo;
        &lt;p&gt;
          &laquo;p.text&raquo;
        &lt;/p&gt;
      &laquo;ENDFOR&raquo;
    &lt;/body&gt;
  &lt;/html&gt;
'''</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="templateType" style="padding-top: 68px; margin-top: -68px;">
						<h3>Typing</h3>
						<p>
							The template expression is of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/CharSequence.html"><abbr title="java.lang.CharSequence">CharSequence</abbr></a>. It is automatically converted
							to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> if that is the expected target type.
						</p>
						</section>
						<!-- subsection -->
						<section id="WhitespaceHandling" style="padding-top: 68px; margin-top: -68px;">
						<h3>White Space Handling</h3>
						<p>
							One of the key features of templates is the smart handling of white space in the template output. 
							The white space is not written into the output data structure as is but preprocessed. This allows 
							for readable templates as well as nicely formatted output. The following three rules are applied 
							when the template is evaluated:
						</p>
						<p>
							</p>
							<ol>
								<li>Indentation in the template that is relative to a control structure will not be propagated 
								    to the output string. A control structure is a <code class="prettyprint lang-xtend">FOR</code>-loop or a condition 
								    (<code class="prettyprint lang-xtend">IF</code>) as well as the opening and closing marks of the template string itself.
								    
								    The indentation is considered to be relative to such a control structure if the previous 
								    line ends with a control structure followed by optional white space. The amount of white 
								    space is not taken into account but the delta to the other lines.</li>
								<li>Lines that do not contain any static text which is not white space but do contain control 
								    structures or invocations of other templates which evaluate to an empty string, will not 
								    appear in the output.</li>
								<li>Any newlines in appended strings (no matter they are created with template expressions or not) will
								    be prepended with the current indentation when inserted.</li>
							</ol>
							<p>
						</p>
						<p>
							Although this algorithm sounds a bit complicated at first it behaves very intuitively. In addition the
							syntax coloring in Eclipse communicates this behavior.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/Xtend_template_coloring.png" alt="Syntax Coloring For Templates In Eclipse" width="566" height="213">
							</div>
							<p>
						</p>
						<p>
							The behavior is best described with a set of examples. The following table assumes a data structure 
							of nested nodes.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td></p>
							<pre class="prettyprint lang-xtend linenums">
class Template {
  def print(Node n) '''
    node &laquo;n.name&raquo; {}
  '''
}</pre>
							<p></td>
							<td></p>
							<pre class="prettyprint lang-xtend linenums">
node NodeName {}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The indentation before <code class="prettyprint lang-xtend">node &laquo;n.name&raquo;</code> will be skipped as it is relative to the opening mark of
							the template string and thereby not considered to be relevant for the output but only for readability 
							of the template itself.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td></p>
							<pre class="prettyprint lang-xtend linenums">
class Template {
  def print(Node n) '''
    node &laquo;n.name&raquo; {
      &laquo;IF hasChildren&raquo;
        &laquo;n.children.map[print]&raquo;
      &laquo;ENDIF&raquo;
    }
  '''
}</pre>
							<p></td>
							<td></p>
							<pre class="prettyprint lang-xtend linenums">
node Parent{
  node FirstChild {
  }
  node SecondChild {
    node Leaf {
    }
  }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							As in the previous example, there is no indentation on the root level for the same reason.
							The first nesting level has only one indentation level in the output. This is derived from
							the indentation of the <code class="prettyprint lang-xtend">IF hasChildren</code> condition in the template which is nested in
							the node. The additional nesting of the recursive invocation <code class="prettyprint lang-xtend">children.map[print]</code> is not
							visible in the output as it is relative the the surrounding control structure. The line with
							<code class="prettyprint lang-xtend">IF</code> and <code class="prettyprint lang-xtend">ENDIF</code> contain only control structures thus they are skipped in 
							the output. Note the additional indentation of the node <strong>Leaf</strong> which happens due to the first rule:
							Indentation is propagated to called templates.
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="processedAnnotations" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Processed Annotations
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Xtend comes with annotations that help to steer the compilation process.
							These annotations reside in the <code class="prettyprint lang-xtend">org.eclipse.xtend.lib</code> plug-in/jar which must be on the classpath
							of the project containing the Xtend files.
						</p>
						<!--  section -->
						<section id="propertyAnnotation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">@Property</h2>
						<p>
							For fields that are annotated as <a href="http://download.eclipse.org/xtend/javadoc/2.3/org/eclipse/xtend/lib/Property.html"><code class="prettyprint lang-xtend">@Property</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.lib/src/org/eclipse/xtend/lib/Property.java">(src)</a>, the Xtend compiler will generate a Java field, a
							getter and, if the field is non-final, a setter method. The name of the Java field will be prefixed with 
							an <code class="prettyprint lang-xtend">_</code> and have the visibility of the Xtend field. The accessors methods are always <code class="prettyprint lang-xtend">public</code>. 
							Thus, an Xtend field
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Property String name</pre>
							<p>
						</p>
						<p>
							will compile to the Java code
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
private String _name;

public String getName() {
  return this._name;
}

public void setName(final String name) {
  this._name = name;
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="dataAnnotation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">@Data</h2>
						<p>
							The annotation <a href="http://download.eclipse.org/xtend/javadoc/2.3/org/eclipse/xtend/lib/Data.html"><code class="prettyprint lang-xtend">@Data</code></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.lib/src/org/eclipse/xtend/lib/Data.java">(src)</a>, will turn an annotated class into a value object class. A class annotated with <code class="prettyprint lang-xtend">@Data</code> 
							has the following effect:
						</p>
						<p>
							</p>
							<ul>
								<li>all fields are flagged final,</li>
								<li>getter methods will be generated (if not existent),</li>
								<li>a constructor taking paramaters for all non-initialized fields will be generated (if not existent),</li>
								<li>equals(Object) / hashCode() methods will be generated (if not existent),</li>
								<li>a toString() method will be generated (if not existent).</li>
							</ul>
							<p>
						</p>
						<p>
							Example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Data class Person {
  String firstName
  String lastName
}</pre>
							<p>
						</p>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3>Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">Xtendlang</a> on Twitter</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
</body>
</html>
