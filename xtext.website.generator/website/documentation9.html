<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtext - Language Development Made Easy!</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages">
	<meta name="author" content="Sven Efftinge">
	<style>
		#header_wrapper {
			padding-top: 10px;
			/* 60px to make the container go all the way to the bottom of the topbar */
		}
		
		code.prettyprint {
	        padding: 0px;
	        background-color: white;
			border: none;
	    }
	</style>
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
					prettyPrint();
	         
					 $('a[data-rel]').each(function() {
	             $(this).attr('rel', $(this).data('rel'));
	         });
	        
					 $("a[rel^='prettyPhoto']").prettyPhoto({
	             animation_speed: 'fast',
	             slideshow: 5000,
	             autoplay_slideshow: false,
	             opacity: 0.80,
	             show_title: true,
	             theme: 'ligh_square',
	             overlay_gallery: false,
	             social_tools: false
	       
	         });
	         
					$('#nav-outline > li > a').live('click', function() {        
						$(this).parent().find('ul').slideToggle();      
					});
	         
					$('.has-popover').popover();
		 	     
		 	     getTwitters('tweet', { 
			        id: 'xtext', 
			        count: 5,
			        includeRT: true,
			        enableLinks: true, 
			        clearContents: true,
			        template : '"%text%" - %time% by <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">@%user_screen_name%</a><br/><br/>'
			     });
	         
	         var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		 	     po.src = 'https://apis.google.com/js/plusone.js';
		 	     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
	
	      <div class="btn-group pull-right">
	        <g:plusone href="http://www.xtext.org"></g:plusone>
	      </div>
	
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li ><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
	
				</div>
				<!--/.nav-collapse -->
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<div id="header_wrapper" class="container">
	<div class="inner">
		<div class="container">
			<div class="page-heading"><h1>Documentation</h1></div>
		</div> <!-- /.container -->
	</div> <!-- /inner -->
	<ul id="nav-outline">
		<li>&nbsp;</li>
		<li style="color : #333;">Getting Started</li>
		<li><a href="documentation.html#FirstFiveMinutes">5 Minutes Tutorial</a>
	<ul>	<li><a href="documentation.html#NewProject">Creating A New Xtext Project</a></li>
		<li><a href="documentation.html#RunWorkflow">Generating The Language Infrastructure</a></li>
		<li><a href="documentation.html#TestingTheEditor">Try The Editor</a></li>
		<li><a href="documentation.html#Conclusion">Conclusion</a></li>
	</ul>	</li>
		<li><a href="documentation1.html#DomainModelWalkThrough">15 Minutes Tutorial</a>
	<ul>	<li><a href="documentation1.html#_0">Create A New Xtext Project</a></li>
		<li><a href="documentation1.html#_1">Write Your Own Grammar</a></li>
		<li><a href="documentation1.html#_2">Generate Language Artifacts</a></li>
		<li><a href="documentation1.html#_3">Run the Generated IDE Plug-in</a></li>
		<li><a href="documentation1.html#_4">Second Iteration: Adding Packages and Imports</a></li>
	</ul>	</li>
		<li><a href="documentation2.html#DomainmodelNextSteps">15 Minutes Tutorial - Extended</a>
	<ul>	<li><a href="documentation2.html#TutorialCodeGeneration">Writing a Code Generator With Xtend</a></li>
		<li><a href="documentation2.html#TutorialUnitTests">Unit Testing the Language</a></li>
		<li><a href="documentation2.html#TutorialValidation">Creating Custom Validation Rules</a></li>
	</ul>	</li>
		<li><a href="documentation3.html#JvmDomainmodel">Five simple steps to your JVM language</a>
	<ul>	<li><a href="documentation3.html#_5">Step One: Create A New Xtext Project</a></li>
		<li><a href="documentation3.html#_6">Step Two: Write the Grammar</a></li>
		<li><a href="documentation3.html#_7">Step Three: Generate Language Artifacts</a></li>
		<li><a href="documentation3.html#_8">Step Four: Define the Mapping to JVM Concepts</a></li>
		<li><a href="documentation3.html#_9">Step Five : Try the Editor!</a></li>
	</ul>	</li>
		<li>&nbsp;</li>
		<li style="color : #333;">Reference Documentation</li>
		<li><a href="documentation4.html#Overview">Overview</a>
	<ul>	<li><a href="documentation4.html#_10">What is Xtext?</a></li>
		<li><a href="documentation4.html#_11">How Does It Work?</a></li>
		<li><a href="documentation4.html#_12">Xtext is Highly Configurable</a></li>
		<li><a href="documentation4.html#_13">Who Uses Xtext?</a></li>
		<li><a href="documentation4.html#_14">Who is Behind Xtext?</a></li>
		<li><a href="documentation4.html#DSL">What is a Domain-Specific Language</a></li>
	</ul>	</li>
		<li><a href="documentation5.html#grammarLanguage">The Grammar Language</a>
	<ul>	<li><a href="documentation5.html#statemachine">A First Example</a></li>
		<li><a href="documentation5.html#syntax">The Syntax</a></li>
		<li><a href="documentation5.html#metamodelInference">Ecore Model Inference</a></li>
		<li><a href="documentation5.html#grammarMixins">Grammar Mixins</a></li>
		<li><a href="documentation5.html#_15">Common Terminals</a></li>
	</ul>	</li>
		<li><a href="documentation6.html#configuration">Configuration</a>
	<ul>	<li><a href="documentation6.html#generator">The Language Generator</a></li>
		<li><a href="documentation6.html#dependencyInjection">Dependency Injection in Xtext with Google Guice</a></li>
	</ul>	</li>
		<li><a href="documentation7.html#runtime_concepts">Runtime Concepts</a>
	<ul>	<li><a href="documentation7.html#runtimeSetup">Runtime Setup (ISetup)</a></li>
		<li><a href="documentation7.html#equinoxSetup">Setup within Eclipse-Equinox (OSGi)</a></li>
		<li><a href="documentation7.html#_16">Logging</a></li>
		<li><a href="documentation7.html#validation">Validation</a></li>
		<li><a href="documentation7.html#linking">Linking</a></li>
		<li><a href="documentation7.html#scoping">Scoping</a></li>
		<li><a href="documentation7.html#valueconverter">Value Converter</a></li>
		<li><a href="documentation7.html#serialization">Serialization</a></li>
		<li><a href="documentation7.html#formatting">Formatting (Pretty Printing)</a></li>
		<li><a href="documentation7.html#fragmentProvider">Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)</a></li>
		<li><a href="documentation7.html#encoding">Encoding in Xtext</a></li>
	</ul>	</li>
		<li><a href="documentation8.html#ide_concepts">IDE Concepts</a>
	<ul>	<li><a href="documentation8.html#labelProvider">Label Provider</a></li>
		<li><a href="documentation8.html#contentAssist">Content Assist</a></li>
		<li><a href="documentation8.html#quickfixes">Quick Fixes</a></li>
		<li><a href="documentation8.html#templates">Template Proposals</a></li>
		<li><a href="documentation8.html#outline">Outline View</a></li>
		<li><a href="documentation8.html#hyperlinking">Hyperlinking</a></li>
		<li><a href="documentation8.html#highlighting">Syntax Coloring</a></li>
		<li><a href="documentation8.html#refactoring">Rename Refactoring</a></li>
	</ul>	</li>
		<li><a href="documentation9.html#Xbase">Xtext and Java</a>
	<ul style="display: block;">	<li><a href="documentation9.html#_17">Plug-in Setup</a></li>
		<li><a href="documentation9.html#jvmtypes">Referring to Java Elements using JVM Types</a></li>
		<li><a href="documentation9.html#xbaseJavaReferences">Referring to Java Types Using Xbase</a></li>
		<li><a href="documentation9.html#xbaseInferredType">Inferring a JVM Model</a></li>
		<li><a href="documentation9.html#xbaseExpressions">Using Xbase Expressions</a></li>
		<li><a href="documentation9.html#xbaseLanguageRef_Introduction">Xbase Language Reference</a></li>
	</ul>	</li>
		<li><a href="documentation10.html#MWE2">MWE2</a>
	<ul>	<li><a href="documentation10.html#MWE2Exampe">Examples</a></li>
		<li><a href="documentation10.html#MWE2LanguageReference">Language Reference</a></li>
		<li><a href="documentation10.html#MWE2SyntaxReference">Syntax Reference</a></li>
	</ul>	</li>
		<li><a href="documentation11.html#emf_integration">Integration with EMF and Other EMF Editors</a>
	<ul>	<li><a href="documentation11.html#model_metamodel">Model, Ecore Model, and Ecore</a></li>
		<li><a href="documentation11.html#emf_codegen">EMF Code Generation</a></li>
		<li><a href="documentation11.html#xtext_resource">XtextResource Implementation</a></li>
		<li><a href="documentation11.html#gmf_integration">Integration with GMF Editors</a></li>
	</ul>	</li>
		<li>&nbsp;</li>
		<li style="color : #333;">Appendix</li>
		<li><a href="documentation12.html#migrating_from_1_0_x">Migrating from Xtext 1.0.x to 2.0</a>
	<ul>	<li><a href="documentation12.html#_18">Take the Shortcut</a></li>
		<li><a href="documentation12.html#_19">Migrating Step By Step</a></li>
		<li><a href="documentation12.html#_20">Now go for then new features</a></li>
	</ul>	</li>
		<li><a href="documentation13.html#migrating_from_0_7">Migrating from Xtext 0.7.x to 1.0</a>
	<ul>	<li><a href="documentation13.html#_21">Migrating Step By Step</a></li>
	</ul>	</li>
		<li>&nbsp;</li>
		<li style="color : #333;">Additional Resources
		<li><a href="documentation/2.3.0/Documentation.pdf">Documentation <img src="images/pdf_icon.gif"></a>
		<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/">API Documentation (JavaDoc)</a>
	</ul>
</div>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="Xbase" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Xtext and Java
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The following chapter demonstrates how to integrate your own DSL with Java. We will do this in four
							stages: First, you will learn how to refer to existing Java elements from within your language. Then
							you will use Xbase to refer to generic types. In the third step, you will map your own DSL's concepts 
							to Java concepts. Last but not least, you will use both Java types and your concepts within Xbase 
							expressions and execute it.
						</p>
						<p>
							Throughout this chapter, we will step by step improve the <a href="documentation2.html#DomainmodelNextSteps">domain model example from the tutorial</a>.
						</p>
						<!--  section -->
						<section id="_17" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Plug-in Setup</h2>
						<p>
							In the following, we are going to use the JVM types model and the Xbase language library. Have a look at your 
							MWE2 workflow and make sure that 
							</p>
							<ul>
								<li>the Xbase models are registered in the standalone setup and</li>
								<li>the 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/generator/types/TypesGeneratorFragment.html"><abbr title="org.eclipse.xtext.generator.types.TypesGeneratorFragment">TypesGeneratorFragment</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/types/TypesGeneratorFragment.java">(src)</a> and the 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.html"><abbr title="org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment">XbaseGeneratorFragment</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.java">(src)</a> are enabled.</li>
							</ul>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
bean = StandaloneSetup {
  ...
  registerGeneratedEPackage = "org.eclipse.xtext.xbase.XbasePackage"
  registerGenModelFile = "platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel"
}
...
fragment = types.TypesGeneratorFragment {}
fragment = xbase.XbaseGeneratorFragment {}</pre>
							<p>
						</p>
						<p>
							To avoid running out of memory when regenerating, make sure to run the workflow with reasonably sized heap and
							PermGen space. We recommend at least
						</p>
						<p>
							<code class="prettyprint lang-xtend">-Xmx512m -XX:MaxPermSize=128m</code>
						</p>
						<p>
							in the <strong>VM Arguments</strong> section of the <strong>Arguments</strong> tab of the run configuration. If you are experiencing ambiguity 
							warnings from Antlr, the <a href="documentation5.html#antlr_errors">usual countermeasures</a> apply. The launch configuration that
							you get with a new Xtext project is already configured properly.
						</p>
						</section>
						<!--  section -->
						<section id="jvmtypes" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Referring to Java Elements using JVM Types</h2>
						<p>
							A common case when developing languages is the requirement to refer to existing concepts of other 
							languages. Xtext makes this very easy for other self defined DSLs. However, it is often very useful
							to have access to the available types of the Java Virtual Machine as well. The JVM types Ecore model enables
							clients to do exactly this. It is possible to create cross-references to classes, interfaces, and their 
							fields and methods. Basically every information about the structural concepts of the Java type system
							is available via the JVM types. This includes annotations and their specific values and enumeration 
							literals, too.
						</p>
						<p>
							The implementation will be selected transparently depending on how the client code is 
							executed. If the environment is a plain stand-alone Java or OSGi environment, the <strong>java.lang.reflect</strong> 
							API will be used to deduce the necessary data. On the contrary, the type-model will be created from the 
							live data of the JDT in an interactive Eclipse environment. All this happens transparently for the clients
							behind the scenes via different implementations that are bound to specific interfaces by means of Google Guice.
						</p>
						<p>
							Using the JVM types model is very simple. First of all, the grammar has to import the <strong>JavaVMTypes</strong> Ecore model. 
							Thanks to content assist this is easy to spot in the list of proposals.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes</pre>
							<p>
						</p>
						<p>
							The next step is to actually refer to an imported concept. Let's define a mapping to available
							Java types for the simple data types in the domain model language. This can be done with a simple cross-reference:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
// simple cross reference to a Java type
DataType:
  'datatype' name=ID 
  'mapped-to' javaType=[jvmTypes::JvmType|QualifiedName];</pre>
							<p>
						</p>
						<p>
							After regenerating your language, it will be allowed to define a type <code class="prettyprint lang-domainexample">Date</code> that maps to the <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html"><abbr title="java.util.Date">Date</abbr></a>
							like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-javatypesexample linenums">
datatype Date mapped-to java.util.Date</pre>
							<p>
						</p>
						<p>
							These two steps will provide a nice integration into the Eclipse JDT. There is <strong>Find References</strong> on Java methods, 
							fields and types that will reveal results in your language files. <strong>Go To Declaration</strong> works as expected
							and content assist will propose the list of available types. Even the <strong>import</strong> statements will also
							apply for Java types.
						</p>
						<!-- subsection -->
						<section id="_77" style="padding-top: 68px; margin-top: -68px;">
						<h3>Customization Points</h3>
						<p>
							There are several customization hooks in the runtime layer of the JVM types and on the editor side as well:
						</p>
						<p>
							The <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.html"><abbr title="org.eclipse.xtext.common.types.xtext.AbstractTypeScopeProvider">AbstractTypeScopeProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/src/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.java">(src)</a> 
							can be used to create scopes for members with respect to
							the override semantics of the Java language. Of course it is possible to use this implementation to
							create scopes for types as well.
						</p>
						<p>
							As the Java VM types expose a lot of information about visibility, parameter types and return types, generics,
							available annotations or enumeration literals, it is very easy to define constraints for the referred types.
						</p>
						<p>
							The <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.html"><abbr title="org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider">ITypesProposalProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.java">(src)</a> can be
							used to provide optimized proposals based on various filter criteria. 
							The most common selector can be used directly via <code class="prettyprint lang-java">createSubTypeProposals(..)</code>. The implementation is optimized
							and uses the JDT Index directly to minimize the effort for object instantiation. The class 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.html"><abbr title="org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters">TypeMatchFilters</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.java">(src)</a>
							provides a comprehensive set of reusable filters that can be easily combined to reduce the list of proposals
							to a smaller number of valid entries.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="xbaseJavaReferences" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Referring to Java Types Using Xbase</h2>
						<p>
							While the JVM types approach from the previous chapter allows to refer to any Java element, it is quite
							limited when it comes to generics. Usually, a type reference in Java can have type arguments which can also include
							wildcards, upper and lower bounds etc. A simple cross-reference using a qualified name is not enough
							to express neither the syntax nor the structure of such a type reference.
						</p>
						<p>
							Xbase offers a parser rule <strong>JvmTypeReference</strong> which supports the full syntax of a Java type reference
							and instantiates a JVM element of type <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmTypeReference.html"><abbr title="org.eclipse.xtext.common.types.JvmTypeReference">JvmTypeReference</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmTypeReference.java">(src)</a>. So
							let us start by inheriting from Xbase:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.eclipse.xtext.example.Domainmodel 
   with org.eclipse.xtext.xbase.Xbase</pre>
							<p>
						</p>
						<p>
							Because we can express all kinds of Java type references directly now, an indirection for <strong>DataTypes</strong> as
							in the previous section is no longer necessary. If we start from the <a href="documentation2.html#DomainmodelNextSteps">domain model 
							example in the tutorial</a> again, we have to replace all cross-references to <strong>Types</strong> by calls to the production 
							rule <strong>JvmTypeReference</strong>. The rules <strong>DataType</strong>, <strong>Type</strong>, and <strong>QualifiedName</strong> become obsolete (the latter is 
							already defined in Xbase), and the <strong>Type</strong> in <strong>AbstractEntity</strong> must be changed to <strong>Entity</strong>. As we now have 
							all kinds of generic Java collections at hand, <strong>Feature.many</strong> is obsolete, too. The whole grammar now reads:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.eclipse.xtext.example.Domainmodel with
                                      org.eclipse.xtext.xbase.Xbase

generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"

Domainmodel:
  (elements += AbstractElement)*
;

PackageDeclaration:
  'package' name = QualifiedName '{'
    (elements += AbstractElement)*
  '}'
;

AbstractElement:
  PackageDeclaration | Entity | Import
;

Import:
  'import' importedNamespace = QualifiedNameWithWildcard
;
  
QualifiedNameWithWildcard:
  QualifiedName '.*'?
;
  
Entity:
  'entity' name = ID 
              ('extends' superType = JvmTypeReference)?
  '{'
    (features += Feature)*
  '}'
;
 
Feature:
  name = ID ':' type = JvmTypeReference
;</pre>
							<p>
						</p>
						<p>
							As we changed the grammar, we have to regenerate the language now.
						</p>
						<p>
							Being able to parse a Java type reference is already nice, but we also have to write them back to their string
							representation when we generate Java code. Unfortunately, a generic type reference with fully qualified
							class names can become a bit bulky. Therefore, the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/ImportManager.html"><abbr title="org.eclipse.xtext.xbase.compiler.ImportManager">ImportManager</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ImportManager.java">(src)</a> shortens
							fully qualified names, keeps track of imported namespaces, avoids name collisions, and helps to serialize
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmTypeReference.html">JvmTypeReferences</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmTypeReference.java">(src)</a> by means of the 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.html"><abbr title="org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer">TypeReferenceSerializer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.java">(src)</a>. This utility encapsulates how type
							references may be serialized depending on the concrete context in the output.
						</p>
						<p>
							The following snippet shows our code generator using an <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/ImportManager.html"><abbr title="org.eclipse.xtext.xbase.compiler.ImportManager">ImportManager</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ImportManager.java">(src)</a>
							in conjunction with as <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.html"><abbr title="org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer">TypeReferenceSerializer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/TypeReferenceSerializer.java">(src)</a>.
							We create a new instance and pass it through the generation functions, collecting types on the way. As
							the import section in a Java file precedes the class body, we create the body into a String variable
							and assemble the whole file's content in a second step.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class DomainmodelGenerator implements IGenerator {
  
  @Inject extension IQualifiedNameProvider
  @Inject extension TypeReferenceSerializer 

  override void doGenerate(Resource resource, IFileSystemAccess fsa) {
    for(e: resource.allContents.toIterable.filter(typeof(Entity))) {
      fsa.generateFile(
        e.fullyQualifiedName.toString("/") + ".java",
        e.compile)
    }
  }
  
  def compile(Entity it) '''
    &laquo;val importManager = new ImportManager(true)&raquo; 
    &laquo;val body = body(importManager)&raquo;
    &laquo;IF eContainer != null&raquo;
      package &laquo;eContainer.fullyQualifiedName&raquo;;
    &laquo;ENDIF&raquo;
    
    &laquo;FOR i:importManager.imports&raquo;
      import &laquo;i&raquo;;
    &laquo;ENDFOR&raquo;
    
    &laquo;body&raquo;
  '''
  
  def body(Entity it, ImportManager importManager) '''
    public class &laquo;name&raquo; &laquo;IF superType != null&raquo;
      extends &laquo;superType.shortName(importManager)&raquo; &laquo;ENDIF&raquo;{
      &laquo;FOR f : features&raquo;
        &laquo;f.compile(importManager)&raquo;
      &laquo;ENDFOR&raquo;
    }
  '''
    
  def compile(Feature it, ImportManager importManager) '''
    private &laquo;type.shortName(importManager)&raquo; &laquo;name&raquo;;
    
    public &laquo;type.shortName(importManager)&raquo; 
      get&laquo;name.toFirstUpper&raquo;() {
      return &laquo;name&raquo;;
    }
    
    public void set&laquo;name.toFirstUpper&raquo;(
      &laquo;type.shortName(importManager)&raquo; &laquo;name&raquo;) {
      this.&laquo;name&raquo; = &laquo;name&raquo;;
    }
  '''
  
  def shortName(JvmTypeReference ref, 
          ImportManager importManager) {
    val result = new StringBuilderBasedAppendable(importManager)
    ref.serialize(ref.eContainer, result);
    result.toString
  }
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="xbaseInferredType" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Inferring a JVM Model</h2>
						<p>
							In many cases, you will want your DSLs concepts to be usable as Java elements. E.g. an <strong>Entity</strong> will
							become a Java class and should be usable as such. In the domain model example, you can write
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-domainexample linenums">
entity Employee extends Person {
  boss: Person
...

entity Person {
  friends: List&lt;Person&gt;
...</pre>
							<p>
						</p>
						<p>
							i.e. use entities instead of Java types or even mix Java types as <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><abbr title="java.util.List">List</abbr></a> with entities such as <strong>Person</strong>.
							One way to achieve this is to let your concepts inherit from a corresponding JVM type, e.g. let <strong>Entity</strong>
							inherit from <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmGenericType.html"><abbr title="org.eclipse.xtext.common.types.JvmGenericType">JvmGenericType</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmGenericType.java">(src)</a>. But this would result in a lot of 
							accidentally inherited properties in your domain model. In Xbase there is an alternative: You can simply define how
							to derive a JVM model from your model. This <strong>inferred JVM model</strong> is the representation of your concepts
							in the typesystem of Xbase.
						</p>
						<p>
							The main component for the inferred JVM model is the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer">IJvmModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java">(src)</a>.
							It has a single method that takes the root model element as an argument and produces a number of 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmDeclaredType.html">JvmDeclaredTypes</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmDeclaredType.java">(src)</a>. As Xbase cannot guess how you
							would like to map your concepts to JVM elements, you have to implement this component yourself. This
							usually boils down to using an injected <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder">JvmTypesBuilder</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">(src)</a> to create
							a hierarchy of JVM elements. The <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html">builder</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">(src)</a> helps
							to initialize the produced types with sensible default and encapsulates the logic that associates the
							source elements with the derived JVM concepts. As this kind of transformation can be elegantly implemented 
							using polymorphic dispatch functions and extension methods, it is a good choice to write the 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer">IJvmModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java">(src)</a> in Xtend. It becomes even simpler if you
							inherit from the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/AbstractModelInferrer.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer">AbstractModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/AbstractModelInferrer.java">(src)</a> which traverses the
							input model and dispatches to its contents until you decide which elements to handle.
						</p>
						<p>
							The inference runs in two phases: In the first phase all the types are created with empty bodies. This way you
							make sure all types exist and are referrable when you create their members in the second phase. 
							Use <code class="prettyprint lang-xtend">acceptor.accept(JvmDeclaredType)</code> for the first phase and provide the initialization
							code for the second phase. You have to pass a <a href="documentation9.html#Xbase_Expressions_Lambda">lambda expression</a> to the method
							<code class="prettyprint lang-xtend">initializeLater()</code> on the return type of the <code class="prettyprint lang-xtend">acceptor.accept()</code> method.
							     
							For our domain model example, we implement a polymorphic dispatch function <strong>infer</strong> for
							<strong>Entities</strong> to transform them into a <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmGenericType.html"><abbr title="org.eclipse.xtext.common.types.JvmGenericType">JvmGenericType</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmGenericType.java">(src)</a> in the first phase. 
							In the second phase, we add a  
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmField.html"><abbr title="org.eclipse.xtext.common.types.JvmField">JvmField</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmField.java">(src)</a> and corresponding accessors for each <strong>Property</strong>. The final 
							<strong>DomainmodelJvmModelInferrer</strong> looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class DomainmodelJvmModelInferrer extends AbstractModelInferrer {

  @Inject extension JvmTypesBuilder
  
  @Inject extension IQualifiedNameProvider
  
  def dispatch void infer(Entity element, 
                IJvmDeclaredTypeAcceptor acceptor, 
                boolean isPrelinkingPhase) {
    
    acceptor.accept(element.toClass(element.fullyQualifiedName)).initializeLater [
      documentation = element.documentation
      for (feature : element.features) {
        members += feature.toField(feature.name, feature.type)
        members += feature.toSetter(feature.name, feature.type)
        members += feature.toGetter(feature.name, feature.type)
      }
    ]
  }
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="_78" style="padding-top: 68px; margin-top: -68px;">
						<h3>Linking and Indexing</h3>
						<p>
							As Java elements and your concepts are now represented as JVM model elements, other models can now transparently
							link to Java or your DSL. In other words, you can use a mapped element of your DSL in the same places
							as the corresponding Java type.
						</p>
						<p>
							The Xbase framework will automatically switch between the JVM element or the DSL element when needed, e.g. when 
							following hyperlinks. The component allowing to navigate between the source model and the JVM model is
							called <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations">IJvmModelAssociations</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.java">(src)</a>, the read-only antagonist of the
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator">IJvmModelAssociator</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.java">(src)</a> that is used by the 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder">JvmTypesBuilder</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">(src)</a>.
						</p>
						<p>
							By default, the inferred model is <a href="documentation7.html#global_scopes">indexed</a>, so it can be cross referenced from other
							models.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="xbaseExpressions" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Using Xbase Expressions</h2>
						<p>
							Xbase is an expression language that can be embedded into Xtext languages. Its syntax is close to Java,
							but it additionally offers type inference, lambda expressions, a powerful switch expression and a lot more. For details
							on this expression langugae, please consult the <a href="documentation9.html#xbaseLanguageRef_Introduction">reference documentation</a> and the 
							Xbase tutorial <strong>(File &gt; New &gt; Example &gt; Xtext Examples &gt; Xbase Tutorial)</strong>.
						</p>
						<p>
							Xbase ships with an interpreter and a compiler that produces Java code. Thus, it is easy to add  
							behavior to your DSLs and make them executable. As Xbase integrates tightly with Java, there is usually no additional code needed to run 
							your DSL as part of a Java application.
						</p>
						<!-- subsection -->
						<section id="_79" style="padding-top: 68px; margin-top: -68px;">
						<h3>Making Your Grammar Refer To Xbase</h3>
						<p>
							If you want to refer to <a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/ecore/EClassifier.html">EClassifiers</a> <a href="https://github.com/eclipse/emf/blob/R2_8_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java">(src)</a> from the Xbase model, you need
							to import Xbase first:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase</pre>
							<p>
						</p>
						<p>
							Now identify the location in your grammar where you want references to Java types and Xbase expressions to appear
							and call the appropriate rules of the super grammar. Adding Xbase expression to the domainmodel example leads to the
							additional concept <strong>Operation</strong>.: An <strong>Operation</strong>'s 
							parameters are <strong>FullJvmFormalParameters</strong>. The production rule for <strong>FullJvmFormalParameters</strong> expects
							both the name and the type here. That is reasonable since the type of parameters should not be inferred. 
							The opertion's return type is a <strong>JvmTypeReference</strong> and its <strong>body</strong> is
							an <strong>XBlockExpression</strong>. The final parser rule reads as:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
Operation:
  'op' name=ValidID '(' 
  (params+=FullJvmFormalParameter (',' params+=FullJvmFormalParameter)*)? ')' 
  ':' type=JvmTypeReference 
    body=XBlockExpression;</pre>
							<p>
						</p>
						<p>
							If you are unsure which entry point to choose for your expressions, consider the <strong>XBlockExpression</strong>.
						</p>
						<p>
							To integrate <strong>Operations</strong> in our models, we have to call this rule. We copy the previous <strong>Feature</strong>
							to a new rule <strong>Property</strong> and let <strong>Feature</strong> become the supertype of <strong>Property</strong> and <strong>Operation</strong>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
Feature:
  Property | Operation
;
 
Property:
  name = ID ':' type = JvmTypeReference
;</pre>
							<p>
						</p>
						<p>
							Note: You will have to adapt the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer">IJvmModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java">(src)</a> to these
							changes, i.e. rename <strong>Feature</strong> to <strong>Property</strong> and create a <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmOperation.html"><abbr title="org.eclipse.xtext.common.types.JvmOperation">JvmOperation</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java">(src)</a>
							for each <strong>Operation</strong>. We leave that as an exercise :-)
						</p>
						<p>
							If you are done with that, everything will work out of the box. Since each expression is now logically
							contained in an <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmOperation.html">operation</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java">(src)</a>, all the scoping rules and
							visibility constraints are implied from that context. The framework will take care that the operation's
							parameters are visible inside the operation's body and that the declared return types are validated against the actual
							expression types.
						</p>
						<p>
							There is yet another aspect of the JVM model that can be explored. Since all the coarse grained concepts
							such as <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmType.html">types</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmType.java">(src)</a> and <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmOperation.html">operations</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java">(src)</a>
							were already derived from the model, a generator can be used to serialize that information to Java code.
							There is no need to write a code generator on top of that. The <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.html"><abbr title="org.eclipse.xtext.xbase.compiler.JvmModelGenerator">JvmModelGenerator</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/JvmModelGenerator.xtend">(src)</a>
							knows how to generate operation bodies properly.
						</p>
						</section>
						<!-- subsection -->
						<section id="_80" style="padding-top: 68px; margin-top: -68px;">
						<h3>Using the Xbase Interpreter</h3>
						<p>
							Sometimes it is more convenient to interpret a model that uses Xbase than to generate code from it.  
							Xbase ships with the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter">XbaseInterpreter</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a> which makes this
							rather easy.
						</p>
						<p>
							An interpreter is essentially an external visitor, that recursively processes a model based on the model
							element's types. By now you should be aware that polymorphic dispatching is exactly the technology needed
							here. In the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter">XbaseInterpreter</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a>, the dispatch method
							is called <strong>_evaluate&lt;SomeDescription&gt;</strong> and takes three parameters, e.g.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
protected Object _evaluateBlockExpression(XBlockExpression literal, 
                      IEvaluationContext context, 
                      CancelIndicator indicator)</pre>
							<p>
						</p>
						<p>
							The <a href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IEvaluationContext.html"><abbr title="org.eclipse.core.expressions.IEvaluationContext">IEvaluationContext</abbr></a> keeps the state of the running application,
							i.e. the local variables and their values. Additionally, it can be <strong>fork</strong>ed, thus allowing to shadow the 
							elements of the original context. Here is an example code snippet how to call the
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter">XbaseInterpreter</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
@Inject private XbaseInterpreter xbaseInterpreter;

@Inject private Provider&lt;IEvaluationContext&gt; contextProvider;

...
public Object evaluate(XExpression expression, Object thisElement) {
  IEvaluationContext evaluationContext = contextProvider.get();
  // provide initial context and implicit variables
  evaluationContext.newValue(XbaseScopeProvider.THIS, thisElement);
  
  IEvaluationResult result = xbaseInterpreter.evaluate(expression,   
    evaluationContext, CancelIndicator.NullImpl);
  if (result.getException() != null) {
    // handle exception
  } 
  return result.getResult();
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="xbaseLanguageRef_Introduction" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Xbase Language Reference</h2>
						<p>
							This document describes the expression language library Xbase. Xbase is a partial programming language
							implemented in Xtext and is meant to be embedded and extended within other programming languages and 
							domain-specific languages (DSL) written in Xtext. Xtext is a highly extendable language development 
							framework covering all aspects of language infrastructure such as parsers, linkers, compilers, 
							interpreters and even full-blown IDE support based on Eclipse.
						</p>
						<p>
							Developing DSLs has become incredibly easy with Xtext. Structural languages which introduce new 
							coarse-grained concepts, such as services, entities, value objects or state-machines can be developed 
							in minutes. However, software systems do not consist of structures solely. At some point a system needs 
							to have some behavior, which is usually specified using so called <strong>expressions</strong>. Expressions are the 
							heart of every programming language and are not easy to get right. On the other hand, expressions are 
							well understood and many programming languages share a common set and understanding of expressions.
						</p>
						<p>
							That is why most people do not add support for expressions in their DSL but try to solve this 
							differently. The most often used workaround is to define only the structural information in the DSL 
							and add behavior by modifying or extending the generated code. It is not only unpleasant to write, 
							read and maintain information which closely belongs together in two different places, abstraction levels 
							and languages. Also, modifying the generated source code comes with a lot of additional problems. 
							This has long time been the preferred solution since adding support for expressions (and a corresponding 
							execution environment) for your language has been hard - even with Xtext.
						</p>
						<p>
							Xbase serves as a language library providing a common expression language bound to the Java platform 
							(i.e. Java Virtual Machine). It consists of an Xtext grammar, as well as reusable and adaptable 
							implementations for the different aspects of a language infrastructure such as an AST structure, a 
							compiler, an interpreter, a linker, and a static analyzer. In addition it comes with implementations to 
							integrate the expression language within an Xtext-based Eclipse IDE. Default implementations for aspects
							like content assistance, syntax coloring, hovering, folding and navigation can be easily integrated and 
							reused within any Xtext based language.
						</p>
						<p>
							Conceptually and syntactically, Xbase is very close to Java statements and expressions, but with a few 
							differences:
							</p>
							<ul>
								<li>No checked exceptions</li>
								<li>Everything is an expression, there are no statements</li>
								<li>Lambda expressions</li>
								<li>Type inference</li>
								<li>Properties</li>
								<li>Simple operator overloading</li>
								<li>Powerful switch expressions</li>
							</ul>
							<p>
						</p>
						<!-- subsection -->
						<section id="xbaseLanguageRef_Syntax" style="padding-top: 68px; margin-top: -68px;">
						<h3>Lexical Syntax</h3>
						<p>
							Xbase comes with a small set of terminal rules, which can be overridden and hence changed by users. 
							However the default implementation is carefully chosen and it is recommended to stick with the 
							lexical syntax described in the following.
						</p>
						<!-- subsection -->
						<section id="Xbase_Syntax_Identifiers" style="padding-top: 68px; margin-top: -68px;">
						<h4>Identifiers</h4>
						<p>
							Identifiers are used to name all constructs, such as types, methods and variables. Xbase uses the default
							identifier-syntax from Xtext - compared to Java, they are slightly simplified to match the common cases
							while having less ambiguities. They start with a letter <strong>a</strong>-<strong>z</strong>, <strong>A</strong>-<strong>Z</strong> or an underscore followed
							by more of these characters or any digit <strong>0</strong>-<strong>9</strong>.
						</p>
						<!-- subsection -->
						<section id="Xbase_Syntax_EscapedIdentifiers" style="padding-top: 68px; margin-top: -68px;">
						<h5>Escaped Identifiers</h5>
						<p>
							Identifiers must not have the same spelling as any reserved keyword. 
							However, this limitation can be avoided by escaping identifiers with the prefix <code class="prettyprint lang-xtend">^</code>. Escaped identifiers 
							are used in cases when there is a conflict with a reserved keyword. Imagine you have introduced a 
							keyword <code class="prettyprint lang-xtend">service</code> in your language but want to call a Java property <strong>service</strong>. 
							In such cases you can use the escaped identifier <code class="prettyprint lang-xtend">^service</code> to reference the Java property.
						</p>
						</section>
						<!-- subsection -->
						<section id="_81" style="padding-top: 68px; margin-top: -68px;">
						<h5>Syntax</h5>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
terminal ID: 
  '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_82" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">Foo</code></li>
								<li><code class="prettyprint lang-xtend">Foo42</code></li>
								<li><code class="prettyprint lang-xtend">FOO</code></li>
								<li><code class="prettyprint lang-xtend">_42</code></li>
								<li><code class="prettyprint lang-xtend">_foo</code></li>
								<li><code class="prettyprint lang-xtend">^extends</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Syntax_Comments" style="padding-top: 68px; margin-top: -68px;">
						<h4>Comments</h4>
						<p>
							Xbase comes with two different kinds of comments: Single-line comments and multi-line comments.
							The syntax is the same as the one known from Java (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.7">§ 3.7 Comments</a>).
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Syntax_Whitespace" style="padding-top: 68px; margin-top: -68px;">
						<h4>White Space</h4>
						<p>
							The white space characters <code class="prettyprint lang-xtend">' '</code>, <code class="prettyprint lang-xtend">'\t'</code>, <code class="prettyprint lang-xtend">'\n'</code>, and <code class="prettyprint lang-xtend">'\r</code> are allowed to occur anywhere between the other syntactic elements.
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Syntax_Keywords" style="padding-top: 68px; margin-top: -68px;">
						<h4>Reserved Keywords</h4>
						<p>
							The following list of words are reserved keywords, thus reducing the set of possible identifiers:
							</p>
							<ol>
								<li><code class="prettyprint lang-xbase">as</code></li>
								<li><code class="prettyprint lang-xbase">case</code></li>
								<li><code class="prettyprint lang-xbase">catch</code></li>
								<li><code class="prettyprint lang-xbase">default</code></li>
								<li><code class="prettyprint lang-xbase">do</code></li>
								<li><code class="prettyprint lang-xbase">else</code></li>
								<li><code class="prettyprint lang-xbase">extends</code></li>
								<li><code class="prettyprint lang-xbase">false</code></li>
								<li><code class="prettyprint lang-xbase">finally</code></li>
								<li><code class="prettyprint lang-xbase">for</code></li>
								<li><code class="prettyprint lang-xbase">if</code></li>
								<li><code class="prettyprint lang-xbase">instanceof</code></li>
								<li><code class="prettyprint lang-xbase">new</code></li>
								<li><code class="prettyprint lang-xbase">null</code></li>
								<li><code class="prettyprint lang-xbase">return</code></li>
								<li><code class="prettyprint lang-xbase">super</code></li>
								<li><code class="prettyprint lang-xbase">switch</code></li>
								<li><code class="prettyprint lang-xbase">throw</code></li>
								<li><code class="prettyprint lang-xbase">true</code></li>
								<li><code class="prettyprint lang-xbase">try</code></li>
								<li><code class="prettyprint lang-xbase">typeof</code></li>
								<li><code class="prettyprint lang-xbase">val</code></li>
								<li><code class="prettyprint lang-xbase">var</code></li>
								<li><code class="prettyprint lang-xbase">while</code></li>
							</ol>
							<p>
						</p>
						<p>
							In case some of the keywords have to be used as identifiers, the escape character for <a href="documentation9.html#Xbase_Syntax_EscapedIdentifiers">identifiers</a> comes in handy.
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="xbaseLanguageRef_Types" style="padding-top: 68px; margin-top: -68px;">
						<h3>Types</h3>
						<p>
							Basically all kinds of JVM types are available and referable.
						</p>
						<!-- subsection -->
						<section id="Xbase_Types_Arrays" style="padding-top: 68px; margin-top: -68px;">
						<h4>Arrays</h4>
						<p>
							Arrays cannot be declared explicitly,
							but they can be passed around and they are (if needed) transparently converted to a List of the component type.
						</p>
						<p>
							In other words, the return type of a Java method that returns an array of ints (<code class="prettyprint lang-java">int[]</code>) can be directly assigned to 
							a variable of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html">List&lt;Integer&gt;</a>. Due to type inference
							this conversion happens implicitly. The conversion is bi-directional: Any method that takes an array as argument can be invoked 
							with a <code class="prettyprint lang-xtend">List</code> instead.
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Types_TypeReferences" style="padding-top: 68px; margin-top: -68px;">
						<h4>Simple Type References</h4>
						<p>
							A simple type reference only consists of a <strong>qualified name</strong>. A qualified name is a name made up of identifiers which are separated by a dot 
							(like in Java).
						</p>
						<p>
							There is no parser rule for a simple type reference, as it is expressed as a parameterized type references without parameters.
						</p>
						<!-- subsection -->
						<section id="_83" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">java.lang.String</code></li>
								<li><code class="prettyprint lang-xtend">String</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Types_FunctionTypes" style="padding-top: 68px; margin-top: -68px;">
						<h4>Function Types</h4>
						<p>
							Xbase introduces <strong>lambda expressions</strong>, and therefore an additional function type signature. On the JVM-Level a lambda
							expression (or more generally any function object) is just an instance of one of the types in 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.html"><abbr title="org.eclipse.xtext.xbase.lib.Functions">Functions</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a>, 
							depending on the number of arguments. However, as lambda expressions are a very important language feature, 
							a special sugared syntax for function types has been introduced.  
							So instead of writing <code class="prettyprint lang-java">Function1&lt;String,Boolean&gt;</code> one can write <code class="prettyprint lang-xbase">(String)=&gt;Boolean</code>.
						</p>
						<p>
							For more information on lambda expressions see <a href="documentation9.html#Xbase_Expressions_Lambda"></a>.
						</p>
						<!-- subsection -->
						<section id="_84" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">=&gt;Boolean // predicate without parameters</code></li>
								<li><code class="prettyprint lang-xbase">()=&gt;String // provider of string</code></li>
								<li><code class="prettyprint lang-xbase">(String)=&gt;Boolean // One argument predicate</code></li>
								<li><code class="prettyprint lang-xbase">(Mutable)=&gt;void // A procedure doing side effects only</code></li>
								<li><code class="prettyprint lang-xbase">(List&lt;String&gt;, Integer)=&gt;String</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Types_ParameterizedTypeReference" style="padding-top: 68px; margin-top: -68px;">
						<h4>Parameterized Type References</h4>
						<p>
							The general syntax for type references allows to take any number of type arguments. The semantics as well as the syntax is almost the same as in Java, so please 
							refer to the third edition of the  <a href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html">Java Language Specification</a>.
						</p>
						<p>
							The only difference is that in Xbase a type reference can also be a function type. In the following the full syntax of type references is shown, including function types and
							type arguments.
						</p>
						<!-- subsection -->
						<section id="_85" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">String</code></li>
								<li><code class="prettyprint lang-xbase">java.lang.String</code></li>
								<li><code class="prettyprint lang-xbase">List&lt;?&gt;</code></li>
								<li><code class="prettyprint lang-xbase">List&lt;? extends Comparable&lt;? extends FooBar&gt;</code></li>
								<li><code class="prettyprint lang-xbase">List&lt;? super MyLowerBound&gt;</code></li>
								<li><code class="prettyprint lang-xbase">List&lt;? extends =&gt;Boolean&gt;</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Types_Primitives" style="padding-top: 68px; margin-top: -68px;">
						<h4>Primitives</h4>
						<p>
							Xbase supports all Java primitives. The conformance rules (e.g. boxing and unboxing) are also exactly like defined
							in the Java Language Specification.
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Types_ConformanceRules" style="padding-top: 68px; margin-top: -68px;">
						<h4>Conformance and Conversion</h4>
						<p>
							Type conformance rules are used in order to find out whether some expression can be used in a certain situation. For instance when assigning a value to a variable, 
							the type of the right hand expression needs to conform to the type of the variable.
						</p>
						<p>
							As Xbase implements the type system of Java it also fully supports the conformance rules defined
							in the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html">Java Language Specification</a>.
						</p>
						<p>
							Some types in Xbase can be used synonymously even if they do not conform to each other in Java. An example for this are arrays and lists 
							or function types with compatible function parameters. Objects of these types are implicitly converted by Xbase on demand.
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Types_CommonSuperType" style="padding-top: 68px; margin-top: -68px;">
						<h4>Common Super Type</h4>
						<p>
							Because of type inference Xbase sometimes needs to compute the most common super type of a given set
							of types.
						</p>
						<p>
							For a set <strong>[T1,T2,...Tn]</strong> of types the common super type is computed by using the linear type inheritance sequence of <strong>T1</strong> and is iterated until one type
							conforms to each <strong>T2,..,Tn</strong>. The linear type inheritance sequence of <strong>T1</strong> is computed by ordering all types which are part if the type hierarchy of <strong>T1</strong>
							by their specificity. A type <strong>T1</strong> is considered more specific than <strong>T2</strong> if <strong>T1</strong> is a subtype of <strong>T2</strong>. Any types with equal specificity will be sorted by
							the maximal distance to the originating subtype. <strong>CharSequence</strong> has distance 2 to <strong>StringBuilder</strong> because
							the supertype <strong>AbstractStringBuilder</strong> implements the interface, too. Even if <strong>StringBuilder</strong> implements
							<strong>CharSequence</strong> directly, the interface gets distance 2 in the ordering because it is not the most general class
							in the type hierarchy that implements the interface. If the distances for two classes are the same in
							the hierarchy, their qualified name is used as the compare-key to ensure deterministic results.
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="xbaseLanguageRef_Expressions" style="padding-top: 68px; margin-top: -68px;">
						<h3>Expressions</h3>
						<p>
							Expressions are the main language constructs which are used to express behavior and compute values. The concept of 
							statements is not supported, but instead powerful expressions are used to handle situations in which the imperative nature of statements would
							be helpful. An expression always results in a value (it might be the value <code class="prettyprint lang-xbase">null</code> though). In addition, every resolved expressions is
							of a static type.
						</p>
						<!-- subsection -->
						<section id="Xbase_Expressions_Literals" style="padding-top: 68px; margin-top: -68px;">
						<h4>Literals</h4>
						<p>
							A literal denotes a fixed unchangeable value. Literals for strings, numbers, booleans,
							<code class="prettyprint lang-xbase">null</code> and Java types are supported.
						</p>
						<!-- subsection -->
						<section id="Xbase_Expressions_StringLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h5>String Literals</h5>
						<p>
							String literals can either use <code class="prettyprint lang-xbase">'single quotes'</code> or <code class="prettyprint lang-xbase">"double quotes"</code> as their terminals. When using
							double quotes all literals allowed by Java string literals are supported. In addition new line 
							characters are allowed, i.e. in Xbase string literals can span multiple lines. When using single 
							quotes the only difference is that single quotes within the literal have to be escaped and double quotes 
							do not.
						</p>
						<p>
							See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.5">§ 3.10.5 String Literals</a>
						</p>
						<p>
							In contrast to Java, equal string literals within the same class do not neccessarily refer to the same
							instance at runtime.
						</p>
						</section>
						<!-- subsection -->
						<section id="_86" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">'Foo Bar Baz'</code></li>
								<li><code class="prettyprint lang-xbase">"Foo Bar Baz"</code></li>
								<li><pre class="prettyprint lang-xbase linenums">
"the quick brown fox
   jumps over the lazy dog."</pre></li>
								<li><code class="prettyprint lang-xbase">'Escapes : \' '</code></li>
								<li><code class="prettyprint lang-xbase">"Escapes : \" "</code></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_NumberLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h5>Number Literals</h5>
						<p>
							Xbase supports roughly the same number literals as Java with a few notable differences.   
							As in Java 7, you can separate digits using <code class="prettyprint lang-xbase">_</code> for better readability
							of large numbers.
							 
							An integer literal represents an <code class="prettyprint lang-xbase">int</code>, a <code class="prettyprint lang-xbase">long</code> (suffix <code class="prettyprint lang-xtend">L</code>) or even a
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigInteger.html"><abbr title="java.math.BigInteger">BigInteger</abbr></a> (suffix <code class="prettyprint lang-xtend">BI</code>). There are no octal number literals.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
42
1_234_567_890 
0xbeef    // hexadecimal
077       // decimal 77 (*NOT* octal)
42L
0xbeef#L // hexadecimal, mind the '#'
0xbeef_beef_beef_beef_beef#BI // BigInteger</pre>
							<p>
						</p>
						<p>
							A floating-point literal creates a <code class="prettyprint lang-xbase">double</code> (suffix <code class="prettyprint lang-xtend">D</code> or omitted), a <code class="prettyprint lang-xbase">float</code> 
							(suffix <code class="prettyprint lang-xtend">F</code>) or a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html"><abbr title="java.math.BigDecimal">BigDecimal</abbr></a> (suffix <code class="prettyprint lang-xtend">BD</code>). If you use a <code class="prettyprint lang-xtend">.</code> sign you have to 
							specify both, the integer and the fractional part of the mantissa. There are only decimal floating-point 
							literals.  
							</p>
							<pre class="prettyprint lang-xbase linenums">
42d     // double
0.42e2  // implicit double
0.42e2f // float
4.2f    // float
0.123_456_789_123_456_789_123_456_789e2000bd // BigDecimal</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_BooleanLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h5>Boolean Literals</h5>
						<p>
							There are two boolean literals, <code class="prettyprint lang-xbase">true</code> and <code class="prettyprint lang-xbase">false</code> which correspond to their Java counterpart of type <strong>boolean</strong>.
						</p>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">true</code></li>
								<li><code class="prettyprint lang-xbase">false</code></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_NullLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h5>Null Literal</h5>
						<p>
							The null literal is, as in Java, <code class="prettyprint lang-xbase">null</code>. 
							It is compatible to any reference type and therefore always of the null type.
						</p>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">null</code></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_TypeLiteral" style="padding-top: 68px; margin-top: -68px;">
						<h5>Type Literals</h5>
						<p>
							Type literals are specified using the keyword <code class="prettyprint lang-xbase">typeof</code> :
						</p>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">typeof(String)</code> which yields <code class="prettyprint lang-java">String.class</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_TypeCasts" style="padding-top: 68px; margin-top: -68px;">
						<h4>Type Casts</h4>
						<p>
							Type cast behave the same as in Java, but have a slightly more readable syntax.
							Type casts bind stronger than any other operator but weaker than feature calls.
						</p>
						<p>
							The conformance rules for casts are defined in the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5">Java Language Specification</a>.
						</p>
						<!-- subsection -->
						<section id="_87" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">my.foo as MyType</code></li>
								<li><code class="prettyprint lang-xbase">(1 + 3 * 5 * (- 23)) as BigInteger</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_Operators" style="padding-top: 68px; margin-top: -68px;">
						<h4>Infix Operators / Operator Overloading</h4>
						<p>
							There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
							to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
							operators for any type just by implementing the corresponding method signature.
							The following defines the operators and the corresponding Java method signatures / expressions.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><code class="prettyprint lang-xtend">e1 += e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_add(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 || e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_or(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &amp;&amp; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_and(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 == e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_equals(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 != e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_notEquals(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_lessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_lessEqualsThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;= e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_greaterEqualsThan(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 -&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_mappedTo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 .. e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_upTo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 =&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleArrow(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_doubleGreaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&lt;&lt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleLessThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &gt;&gt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_tripleGreaterThan(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_diamond(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ?: e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_elvis(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 &lt;=&gt; e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_spaceship(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 + e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_plus(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 - e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minus(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 * e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_multiply(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 / e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_divide(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 % e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_modulo(e2)</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">e1 ** e2</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_power(e2)</code></td>
							</tr>
							<tr><td></td>
							<td></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">! e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_not()</code></td>
							</tr>
							<tr><td><code class="prettyprint lang-xtend">- e1</code></td>
							<td><code class="prettyprint lang-xtend">e1.operator_minus()</code></td>
							</tr>
							</table>
							<p>
							
							    
							The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
							The assignment operator <code class="prettyprint lang-xtend">+=</code> is right-to-left associative in the same way as the plain assignment
							operator <code class="prettyprint lang-xtend">=</code> is. Consequently, <code class="prettyprint lang-xtend">a = b = c</code> is executed as <code class="prettyprint lang-xtend">a = (b = c)</code>. All other
							operators are left-to-right associative. Parentheses can be used to adjust the default precedence and associativity.
						</p>
						<!-- subsection -->
						<section id="_88" style="padding-top: 68px; margin-top: -68px;">
						<h5>Short-Circuit Boolean Operators</h5>
						<p>
							If the operators <code class="prettyprint lang-xtend">||</code> and <code class="prettyprint lang-xtend">&amp;&amp;</code> are used in a context where the left hand operand is of type boolean, the operation is evaluated
							in short circuit mode, which means that the right hand operand is not evaluated at all in the following cases: 
							</p>
							<ol>
								<li>in the case of <code class="prettyprint lang-xtend">||</code> the operand on the right hand side is not evaluated if the left operand evaluates to <code class="prettyprint lang-xbase">true</code>.</li>
								<li>in the case of <code class="prettyprint lang-xtend">&amp;&amp;</code> the operand on the right hand side is not evaluated if the left operand evaluates to <code class="prettyprint lang-xbase">false</code>.</li>
							</ol>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_89" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">my.foo = 23</code></li>
								<li><code class="prettyprint lang-xbase">myList += 23</code></li>
								<li><code class="prettyprint lang-xbase">x &gt; 23 &amp;&amp; y &lt; 23</code></li>
								<li><code class="prettyprint lang-xbase">x &amp;&amp; y || z</code></li>
								<li><code class="prettyprint lang-xbase">1 + 3 * 5 * (- 23)</code></li>
								<li><code class="prettyprint lang-xbase">!(x)</code></li>
								<li><code class="prettyprint lang-xbase">my.foo = 23</code></li>
								<li><code class="prettyprint lang-xbase">my.foo = 23</code></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_90" style="padding-top: 68px; margin-top: -68px;">
						<h5>With Operator</h5>
						<p>
							The <strong>with</strong> operator <code class="prettyprint lang-xtend">=&gt;</code> executes the <a href="documentation9.html#Xbase_Expressions_Lambda">lambda expression</a> with a single parameter on the right-hand
							 side with a given argument on its left-hand side. The result is the left operand after applying the lambda expression. In 
							combination with the  <a href="documentation9.html#Xbase_Expressions_implicit_parameter">implicit parameter</a> <code class="prettyprint lang-xbase">it</code> this allows very convenient
							initialization of newly created objects. Example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
val person = new Person =&gt; [
  firstName = 'John'
  lastName = 'Coltrane'
]
// equivalent to
val person = new Person
person.firstName = 'John'
person.lastName = 'Coltrane'</pre>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_PropertyAssignment" style="padding-top: 68px; margin-top: -68px;">
						<h4>Assignments</h4>
						<p>
							<a href="documentation9.html#Xbase_Expressions_VariableDeclaration">Local variables</a> can be reassigned using the <code class="prettyprint lang-xtend">=</code> operator. Also properties can be set using 
							that operator:
							Given the expression
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myObj.myProperty = "foo"</pre>
							<p>
						</p>
						<p>
							The compiler first looks for an accessible Java Field called <code class="prettyprint lang-xtend">myProperty</code> on the declared or inferred type of <code class="prettyprint lang-xtend">myObj</code>. If such
							a field can be found, the expressions translates to
							the following Java code:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
myObj.myProperty = "foo";</pre>
							<p>
						</p>
						<p>
							Remember, in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
							Java expression, which is the assigned value.
						</p>
						<p>
							If there is no accessible field on the left operand's type, a method called <code class="prettyprint lang-java">setMyProperty(OneArg)</code> (JavaBeans
							setter method) is looked up. It has to take one argument of the type (or a super type) of the right hand operand. The return value of the assignment will be the 
							return value of the setter method (which is usually of type <code class="prettyprint lang-xbase">void</code> and therefore the value <code class="prettyprint lang-xbase">null</code>). 
							As a result the compiler translates to :
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
myObj.setMyProperty("foo")</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_FeatureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h4>Feature Calls</h4>
						<p>
							A feature call is used to access members of objects, such as fields and methods, but it can also refer to local variables and parameters, 
							which are made available by the current expression's scope.
						</p>
						<!-- subsection -->
						<section id="Xbase_Expressions_PropertyAccess" style="padding-top: 68px; margin-top: -68px;">
						<h5>Property Access</h5>
						<p>
							Feature calls are directly translated to their Java equivalent with the exception, that access to properties follows similar rules as 
							described in <a href="documentation9.html#Xbase_Expressions_PropertyAssignment"></a>. 
							That is, for the expression
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myObj.myProperty</pre>
							<p>
						</p>
						<p>
							the compiler first looks for an accessible field <code class="prettyprint lang-xbase">myProperty</code> in the type of <code class="prettyprint lang-xbase">myObj</code>. If no such field exists it 
							tries to find a method called <code class="prettyprint lang-java">myProperty()</code> before it looks 
							for the getter methods <code class="prettyprint lang-java">getMyProperty()</code>. If none of these members can be found, the expression is unbound and a compiliation error is indicated.
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_NullSafeFeatureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h5>Null-Safe Feature Call</h5>
						<p>
							Checking for null references can make code very unreadable. In many situations it is ok for an expression to return <code class="prettyprint lang-xbase">null</code> if a receiver was <code class="prettyprint lang-xbase">null</code>.
							Xbase supports the safe navigation operator <code class="prettyprint lang-xbase">?.</code> to make such code more readable.
						</p>
						<p>
							Instead of writing
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
if ( myRef != null ) myRef.doStuff()</pre>
							<p>
						</p>
						<p>
							one can write
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myRef?.doStuff()</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_staticFeatureCalls" style="padding-top: 68px; margin-top: -68px;">
						<h5>Static Feature Calls</h5>
						<p>
							To access static members of a type, use <code class="prettyprint lang-xtend">::</code>, e.g.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
java::util::Collections::singleton("Lonesome Cowboy")
System::err.println("An error occurred")</pre>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_ImplicitThis" style="padding-top: 68px; margin-top: -68px;">
						<h4>Implicit variables 'this' and 'it'</h4>
						<p>
							If the current scope contains a variable named <code class="prettyprint lang-xbase">this</code> or <code class="prettyprint lang-xbase">it</code>, the compiler will make all its members available implicitly.
							That is if one of 
							</p>
							<pre class="prettyprint lang-xbase linenums">
it.myProperty
this.myProperty</pre>
							<p>
							
							is a valid expression
							</p>
							<pre class="prettyprint lang-xbase linenums">
myProperty</pre>
							<p>
							
							is valid as well. It resolves to the same feature as long as there is no local variable <code class="prettyprint lang-xbase">myProperty</code> declared,
							which would have higher precedence.
						</p>
						<p>
							As <code class="prettyprint lang-xbase">this</code> is bound to the surrounding object in Java, <code class="prettyprint lang-xbase">it</code> can be used
							in finer-grained constructs such as function parameters. That is why <code class="prettyprint lang-xbase">it.myProperty</code> has 
							higher precedence than <code class="prettyprint lang-xbase">this.myProperty</code>. <code class="prettyprint lang-xbase">it</code> is also the 
							<a href="documentation9.html#Xbase_Expressions_implicit_parameter">default parameter name in lambda expressions</a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_ConstructorCall" style="padding-top: 68px; margin-top: -68px;">
						<h4>Constructor Call</h4>
						<p>
							Construction of objects is done by invoking Java constructors. The syntax is exactly as in Java.
						</p>
						<!-- subsection -->
						<section id="_91" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><pre class="prettyprint lang-xbase linenums">
new String()</pre></li>
								<li><pre class="prettyprint lang-xbase linenums">
new java.util.ArrayList&lt;java.math.BigDecimal&gt;()</pre></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_Lambda" style="padding-top: 68px; margin-top: -68px;">
						<h4>Lambda Expressions</h4>
						<p>
							A lambda expression is a literal that defines an anonymous function. Xbase' lambda expressions are allowed
							to access variables of the declarator. Any final variables and parameters visible at construction 
							time can be referred to in the lambda expression's body. These expressions are also known as closures.
						</p>
						<p>
							Lambda expressions are surrounded by square brackets (\<code class="prettyprint lang-xtend">[]</code>):
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myList.findFirst([ e | e.name==null ])</pre>
							<p>
						</p>
						<p>
							When a function object is expected to be the last parameter of a feature call, you may declare the lambda expression after the parentheses:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myList.findFirst() [ e | e.name==null ]</pre>
							<p>
						</p>
						<p>
							Since in Xbase parentheses are optional for method calls, the same can be written as:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myList.findFirst[ e | e.name==null ]</pre>
							<p>
						</p>
						<p>
							This example can be further simplified since the lambda's parameter is available as the implicit variable <code class="prettyprint lang-xbase">it</code>, 
							if the parameter is not declared explicitly:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myList.findFirst[ it.name==null ]</pre>
							<p>
						</p>
						<p>
							Since <code class="prettyprint lang-xbase">it</code> is implicit, this is the same as:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
myList.findFirst[ name==null ]</pre>
							<p>
						</p>
						<p>
							Another usecase for lambda expressions is to store function objects in variables:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
val func = [ String s | s.length&gt;3 ]</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="Xbase_Expressions_LambdaTypeInference" style="padding-top: 68px; margin-top: -68px;">
						<h5>Typing</h5>
						<p>
							Lambda expressions produce function objects. The type is a <a href="documentation9.html#Xbase_Types_FunctionTypes">function type</a>, parameterized
							with the types of the lambda's parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
							The parameter types can be inferred if the lambda expression is used in a context where this is possible.
						</p>
						<p>
							For instance, given the following Java method signature:
							</p>
							<pre class="prettyprint lang-java linenums">
public T &lt;T&gt;getFirst(List&lt;T&gt; list, Function0&lt;T,Boolean&gt; predicate)</pre>
							<p>
						</p>
						<p>
							the type of the parameter can be inferred. Which allows users to write:
							</p>
							<pre class="prettyprint lang-xbase linenums">
newArrayList( "Foo", "Bar" ).findFirst[ e | e == "Bar" ]</pre>
							<p>
							
							instead of 
							</p>
							<pre class="prettyprint lang-xbase linenums">
newArrayList( "Foo", "Bar" ).findFirst[ String e | e == "Bar" ]</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_FunctionMapping" style="padding-top: 68px; margin-top: -68px;">
						<h5>Function Mapping</h5>
						<p>
							An Xbase lambda expression is a Java object of one of the <strong>Function</strong> interfaces that are part of the runtime library of Xbase. There is an interface 
							for each number of parameters (up to six parameters). The names of the interfaces are 
							</p>
							<ul>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.Function0.html">Function0&lt;ReturnType&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a> for zero parameters,</li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.Function1.html">Function1&lt;Param1Type, ReturnType&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a> for one parameters,</li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.Function2.html">Function2&lt;Param1Type, Param2Type, ReturnType&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a> for two parameters,</li>
								<li>...</li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Functions.Function6.html">Function6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Functions.java">(src)</a> for six parameters,</li>
							</ul>
							<p>
							
							or
							</p>
							<ul>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Procedures.Procedure0.html">Procedure0</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a> for zero parameters,</li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Procedures.Procedure1.html">Procedure1&lt;Param1Type&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a> for one parameters,</li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Procedures.Procedure2.html">Procedure2&lt;Param1Type, Param2Type&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a> for two parameters,</li>
								<li>...</li>
								<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/lib/Procedures.Procedure6.html">Procedure6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type&gt;</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/Procedures.java">(src)</a> for six parameters,</li>
							</ul>
							<p>
							
							if the return type is <code class="prettyprint lang-java">void</code>.
						</p>
						<p>
							In order to allow seamless integration with existing Java libraries such as the JDK or Google Guava 
							(formerly known as Google Collect) lambda expressions are auto coerced to expected types if those 
							types declare only one abstract method (methods from <code class="prettyprint lang-java">java.lang.Object</code> don't count).
						</p>
						<p>
							As a result given the method <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html">Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;)</a> is available
							as an extension method, it can be invoked like this
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
newArrayList( 'aaa', 'bb', 'c' ).sort [
  e1, e2 | if ( e1.length &gt; e2.length ) {
        -1 
       } else if ( e1.length &lt; e2.length ) { 
        1
       } else { 
        0
       }
]</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_implicit_parameter" style="padding-top: 68px; margin-top: -68px;">
						<h5>Implicit Parameter <strong>it</strong></h5>
						<p>
							If a lambda expression has a single parameter whose type can be inferred, the declaration of the parameter can
							be omitted. Use <code class="prettyprint lang-xbase">it</code> to refer to the parameter inside the lambda expression's body.
							</p>
							<pre class="prettyprint lang-xbase linenums">
val (String s)=&gt;String function = [ toUpperCase ] 
  // equivalent to [it | it.toUpperCase]</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="_92" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">[ | "foo" ]   // lambda expression without parameters</code></li>
								<li><code class="prettyprint lang-xbase">[ String s | s.toUpperCase() ] // explicit argument type</code></li>
								<li><code class="prettyprint lang-xbase">[ a, b, c | a+b+c ] // inferred argument types</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_IfExpression" style="padding-top: 68px; margin-top: -68px;">
						<h4>If Expression</h4>
						<p>
							An if expression is used to choose two different values based on a predicate. While it has the syntax of Java's if statement it behaves  
							like Java's ternary operator (<code class="prettyprint lang-java">predicate ? thenPart : elsePart</code>), i.e. it is an expression that returns a value. Consequently, you can use 
							if expressions deeply nested within other expressions.
						</p>
						<p>
							An expression <code class="prettyprint lang-xbase">if (p) e1 else e2</code> results in either the value <code class="prettyprint lang-xtend">e1</code> or <code class="prettyprint lang-xtend">e2</code> depending on whether the predicate <code class="prettyprint lang-xtend">p</code> 
							evaluates to <code class="prettyprint lang-xbase">true</code> or <code class="prettyprint lang-xbase">false</code>. The else part is optional which is a shorthand for <code class="prettyprint lang-xbase">else null</code>.
							That means
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
if (foo) x</pre>
							<p>
						</p>
						<p>
							is the a short hand for
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
if (foo) x else null</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="Xbase_Expressions_IfTypeInference" style="padding-top: 68px; margin-top: -68px;">
						<h5>Typing</h5>
						<p>
							The type of an if expression is calculated by the return types <code class="prettyprint lang-xtend">T1</code> and <code class="prettyprint lang-xtend">T2</code> of the two expression <code class="prettyprint lang-xtend">e1</code> and <code class="prettyprint lang-xtend">e2</code>.
							It uses the rules defined in <a href="documentation9.html#Xbase_Types_CommonSuperType"></a>.
						</p>
						</section>
						<!-- subsection -->
						<section id="_93" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xbase">if (isFoo) this else that</code></li>
								<li><code class="prettyprint lang-xbase">if (isFoo) { this } else if (thatFoo) { that } else { other }</code></li>
								<li><code class="prettyprint lang-xbase">if (isFoo) this</code></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_SwitchExpression" style="padding-top: 68px; margin-top: -68px;">
						<h4>Switch Expression</h4>
						<p>
							The switch expression is a bit different from Java's. First, there is no fall through which means only one case is evaluated at most.
							Second, the use of switch is not limited to certain values but can be used for any object reference instead.
							 
							For a switch expression 
							</p>
							<pre class="prettyprint lang-xbase linenums">
switch e {
  case e1 : er1
  case e2 : er2
  ...
  case en : ern
  default : er
}</pre>
							<p>
						</p>
						<p>
							the main expression <code class="prettyprint lang-xtend">e</code> is evaluated first and then each case sequentially. If the switch expression
							contains a variable declaration using the syntax known from <a href="documentation9.html#Xbase_Expressions_ForLoop">for loops</a>, the value is bound to the given name.
							Expressions of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Boolean.html"><abbr title="java.lang.Boolean">Boolean</abbr></a> or <code class="prettyprint lang-xbase">boolean</code> are not allowed in a switch expression.
						</p>
						<p>
							The guard of each case clause is evaluated until the switch value equals the result of the case's guard expression or if the case's guard expression evaluates to <code class="prettyprint lang-xbase">true</code>.
							Then the right hand expression of the case evaluated and the result is returned.
						</p>
						<p>
							If none of the guards matches the default expression is evaluated and returned. If no default expression
							is specified the expression evaluates to <code class="prettyprint lang-xbase">null</code>.
						</p>
						<p>
							Example:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
switch myString {
  case myString.length&gt;5 : 'a long string.'
  case 'foo' : "It's a foo."
  default : "It's a short non-foo string."
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="_94" style="padding-top: 68px; margin-top: -68px;">
						<h5>Type guards</h5>
						<p>
							In addition to the case guards one can add a so called <strong>Type Guard</strong> which is syntactically just a <a href="documentation9.html#Xbase_Types_TypeReferences">type reference</a> preceding
							the than optional case keyword. The compiler will use that type for the switch expression in subsequent expressions.
							Example:
							</p>
							<pre class="prettyprint lang-xbase linenums">
var Object x = ...;
switch x {
  String case x.length()&gt;0 : x.length()
  List&lt;?&gt; : x.size()
  default : -1
}</pre>
							<p>
						</p>
						<p>
							Only if the switch value passes a type guard, i.e. an instanceof operation returns <code class="prettyprint lang-xbase">true</code>, the case's guard expression is executed using the same semantics as explained above. 
							If the switch expression contains an explicit declaration of a local variable or the expression references a local variable,
							the type guard works like an automated cast. All subsequent references to the switch value will be of the type specified in the type guard.
						</p>
						</section>
						<!-- subsection -->
						<section id="_95" style="padding-top: 68px; margin-top: -68px;">
						<h5>Typing</h5>
						<p>
							The return type of a switch expression is computed using the rules defined in the
							section on <a href="documentation9.html#Xbase_Types_CommonSuperType">common supertypes</a>. The set of types from which the common 
							super type is computed corresponds to the types of each case's result expression. If a switch expression's
							type is computed using the expected type from the context, it is sufficient to return the expected type if all 
							case branches types conform to the expected type.
						</p>
						</section>
						<!-- subsection -->
						<section id="_96" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><pre class="prettyprint lang-xbase linenums">
switch foo {
  Entity : foo.superType.name
  Datatype : foo.name
  default : throw new IllegalStateException
}</pre></li>
								<li><pre class="prettyprint lang-xbase linenums">
switch x : foo.bar.complicated('hello',42) {
  case "hello42" : ...
  case x.length&lt;2 : ...
  default : ....
}</pre></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_VariableDeclaration" style="padding-top: 68px; margin-top: -68px;">
						<h4>Variable Declarations</h4>
						<p>
							Variable declarations are only allowed within <a href="documentation9.html#Xbase_Expressions_Blocks">blocks</a>. They are visible in any
							subsequent expressions in the block. Generally, overriding or shadowing variables from outer scopes is not allowed.
							However, it can be used to overload the <a href="documentation9.html#Xbase_Expressions_ImplicitThis">implicit variable</a> 
							<code class="prettyprint lang-xbase">it</code>, in order to subsequently access an object's features in an unqualified manner.
						</p>
						<p>
							A variable declaration starting with the keyword <code class="prettyprint lang-xbase">val</code> denotes an unchangeable value, which is essentially 
							a final variable. In rare cases, one needs to update the value of a reference. In such situations
							the variable needs to be declared with the keyword <code class="prettyprint lang-xbase">var</code>, which stands for variable.
						</p>
						<p>
							A typical example for using <code class="prettyprint lang-xbase">var</code> is a counter in a loop. 
							</p>
							<pre class="prettyprint lang-xbase linenums">
{
  val max = 100
  var i = 0
  while (i &gt; max) {
    println("Hi there!")
    i = i +1
  }
}</pre>
							<p>
						</p>
						<p>
							Variables declared outside a lambda expression using the <code class="prettyprint lang-xbase">var</code> keyword are not accessible from within a
							the lambda expression.
						</p>
						<!-- subsection -->
						<section id="_97" style="padding-top: 68px; margin-top: -68px;">
						<h5>Typing</h5>
						<p>
							The return type of a variable declaration expression is always <code class="prettyprint lang-xbase">void</code>. 
							The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
							Here is an example for an explicitly declared type:
							</p>
							<pre class="prettyprint lang-xbase linenums">
var List&lt;String&gt; msg = new ArrayList&lt;String&gt;();</pre>
							<p>
							
							In such cases, the right hand expression's type must <a href="documentation9.html#Xbase_Types_ConformanceRules">conform</a> to the type on the left hand side.
						</p>
						<p>
							Alternatively the type can be left out and will be inferred from the initialization expression:  
							</p>
							<pre class="prettyprint lang-xbase linenums">
var msg = new ArrayList&lt;String&gt; // -&gt; type ArrayList&lt;String&gt;</pre>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_Blocks" style="padding-top: 68px; margin-top: -68px;">
						<h4>Blocks</h4>
						<p>
							The block expression allows to have imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
							The return type of a block is also the type of the last expression. Empty blocks return <code class="prettyprint lang-xbase">null</code>. 
							<a href="documentation9.html#Xbase_Expressions_VariableDeclaration">Variable declarations</a> are only allowed within blocks and cannot be used as a block's last expression.
						</p>
						<p>
							A block expression is surrounded by curly braces and contains at least one expression.
							It can optionally be terminated by a semicolon.
						</p>
						<!-- subsection -->
						<section id="_98" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
{
  doSideEffect("foo")
  result
}</pre>
							<p>
							
							</p>
							<pre class="prettyprint lang-xbase linenums">
{
  var x = greeting();
  if (x.equals("Hello ")) {
    x+"World!"; 
  } else {
    x;
  }
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_ForLoop" style="padding-top: 68px; margin-top: -68px;">
						<h4>For Loop</h4>
						<p>
							The for loop <code class="prettyprint lang-xbase">for (T1 variable : iterableOfT1) expression</code> is used to execute a certain expression for each element of an
							array of an instance of <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><abbr title="java.lang.Iterable">Iterable</abbr></a>.
							The local <code class="prettyprint lang-xtend">variable</code> is final, hence canot be updated.
						</p>
						<p>
							The return type of a for loop is <code class="prettyprint lang-xbase">void</code>.
							The type of the local variable can be left out. In that case it is inferred from the type of the array
							or <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Iterable.html"><abbr title="java.lang.Iterable">Iterable</abbr></a> returned by the iterable expression.
						</p>
						<p>
							</p>
							<ul>
								<li><pre class="prettyprint lang-xbase linenums">
for (String s : myStrings) {
  doSideEffect(s);
}</pre></li>
								<li><pre class="prettyprint lang-xbase linenums">
for (s : myStrings)
  doSideEffect(s)</pre></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_WhileExpression" style="padding-top: 68px; margin-top: -68px;">
						<h4>While Loop</h4>
						<p>
							A while loop <code class="prettyprint lang-xbase">while (predicate) expression</code> is used to execute a certain expression unless the predicate is evaluated to <code class="prettyprint lang-xbase">false</code>.
							The return type of a while loop is <code class="prettyprint lang-xbase">void</code>.
						</p>
						<!-- subsection -->
						<section id="_99" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><pre class="prettyprint lang-xbase linenums">
while (true) {
  doSideEffect("foo");
}</pre></li>
								<li><pre class="prettyprint lang-xbase linenums">
while ( ( i = i + 1 ) &lt; max ) 
  doSideEffect( "foo" )</pre></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_DoWhileExpression" style="padding-top: 68px; margin-top: -68px;">
						<h4>Do-While Loop</h4>
						<p>
							A do-while loop <code class="prettyprint lang-xbase">do expression while (predicate)</code> is used to execute a certain expression until the predicate is evaluated to <code class="prettyprint lang-xbase">false</code>.
							The difference to the <a href="documentation9.html#Xbase_Expressions_WhileExpression">while loop</a> is that the execution starts by executing the block once before evaluating the predicate for the first time.
							The return type of a do-while loop is <code class="prettyprint lang-xbase">void</code>.
						</p>
						<!-- subsection -->
						<section id="_100" style="padding-top: 68px; margin-top: -68px;">
						<h5>Examples</h5>
						<p>
							</p>
							<ul>
								<li><pre class="prettyprint lang-xbase linenums">
do {
  doSideEffect("foo");
} while (true)</pre></li>
								<li><pre class="prettyprint lang-xbase linenums">
do doSideEffect("foo") while ((i=i+1)&lt;max)</pre></li>
							</ul>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_Return" style="padding-top: 68px; margin-top: -68px;">
						<h4>Return Expression</h4>
						<p>
							Although an explicit return is often not necessary, it is supported.
							In a lambda expression for instance a return expression is always implied if the expression itself is not of type
							<code class="prettyprint lang-xbase">void</code>. Anyway you can make it explicit:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
listOfStrings.map [ e |
  if (e==null) 
    return "NULL"
  e.toUpperCase
]</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_Throw" style="padding-top: 68px; margin-top: -68px;">
						<h4>Throwing Exceptions</h4>
						<p>
							Like in Java it is possible to throw <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Throwable.html"><abbr title="java.lang.Throwable">Throwable</abbr></a>. The syntax is exactly the same as in Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
{
  ...
  if (myList.isEmpty)
    throw new IllegalArgumentException("the list must not be empty")
  ...
}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="Xbase_Expressions_TryCatch" style="padding-top: 68px; margin-top: -68px;">
						<h4>Try, Catch, Finally</h4>
						<p>
							The try-catch-finally expression is used to handle exceptional situations.
							You are not forced to declare checked exceptions. If you don't catch checked exceptions, they are rethrown in a way the compiler
							does not complain about a missing throws clause, using the sneaky-throw technique introduced by 
							<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>.
							The syntax again is the same known from Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
try {
  throw new RuntimeException()
} catch (NullPointerException e) {
  // handle e
} finally {
  // do stuff
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!-- subsection -->
						<section id="xbaseLanguageRef_LibraryExtension" style="padding-top: 68px; margin-top: -68px;">
						<h3>Extension Methods</h3>
						<p>
							Languages extending Xbase might want to contribute to the feature scope. Besides that, one can of course
							change the whole implementation as it seems fit. There is a special hook, which can be used to add 
							so-called extension methods to existing types.
						</p>
						<p>
							Xbase itself comes with a standard library of such extension methods adding support for various operators
							for the common types, such as <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><abbr title="java.util.List">List</abbr></a>, etc.
						</p>
						<p>
							These extension methods are declared in separate Java classes. There are various ways how extension methods
							can be added. In the simplest case the language designer predefines which extension methods are available.
							Language users cannot add additional library functions using this mechanism.
						</p>
						<p>
							Another alternative is to have them looked up by a certain naming convention. Also for more general languages
							it is possible to let users add extension methods using imports or similar mechanisms. This approach can be seen in the
							language <a href="http://www.xtend-lang.org">Xtend</a>, where extension methods are lexically imported through static
							imports and/or dependency injection.
						</p>
						<p>
							The precedence of extension methods is always lower than real member methods, i.e. you cannot override
							member features. Also the extension members are not invoked polymorphicly. If you have two extension methods
							on the scope (<code class="prettyprint lang-xtend">foo(Object)</code> and <code class="prettyprint lang-xtend">foo(String)</code>) the expression <code class="prettyprint lang-xbase">(foo as Object).foo</code> would
							bind and invoke <code class="prettyprint lang-xtend">foo(Object)</code>.
						</p>
						<!-- subsection -->
						<section id="_101" style="padding-top: 68px; margin-top: -68px;">
						<h4>Examples</h4>
						<p>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">foo</code></li>
								<li><code class="prettyprint lang-xtend">my.foo</code></li>
								<li><code class="prettyprint lang-xtend">my.foo(x)</code></li>
								<li><code class="prettyprint lang-xtend">oh.my.foo(bar)</code></li>
							</ul>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="XbaseLanguageRef_builderSyntax" style="padding-top: 68px; margin-top: -68px;">
						<h4>Builder Syntax</h4>
						<p>
							If the last argument of a method call is a lambda expression, it can be appended to the method call. Thus,
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
foo(42) [ String s | s.toUpperCase ]</pre>
							<p>
						</p>
						<p>
							will call a Java method with the signature
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
void foo(int, Function1&lt;String, String&gt;)</pre>
							<p>
						</p>
						<p>
							Used in combination with the <a href="documentation9.html#Xbase_Expressions_implicit_parameter">implicit parameter name in lambda
							expressions</a>
							you can write <a href="documentation9.html#xbaseLanguageRef_LibraryExtension">extension libraries</a> to create and initialize graphs of
							objects in a concise builder syntax like in Groovy. Consider you have a set of library methods
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
HtmlNode html(Function1&lt;HtmlNode, Void&gt; initializer)
HeadNode head(HtmlNode parent, Function1&lt;HeadNode, Void&gt; initializer)
...</pre>
							<p>
						</p>
						<p>
							that create DOM elements for HTML pages inside their respective parent elements. You can then create a DOM
							using the following Xbase code:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xbase linenums">
html([ html | 
  head(html, [ 
    // initialize head
  ]) 
] )</pre>
							<p>
						</p>
						<p>
							Appending the lambda expression parameters and prepending the parent parameters using extension syntax yields
							</p>
							<pre class="prettyprint lang-xbase linenums">
html() [ html | 
  html.head() [ 
    // initialize head
  ]  
]</pre>
							<p>
						</p>
						<p>
							Using implicit parameter <code class="prettyprint lang-xbase">it</code> and skipping empty parentheses you can simplify this to 
							</p>
							<pre class="prettyprint lang-xbase linenums">
html [ 
  head [ 
    // initialize head
  ]  
]</pre>
							<p>
						</p>
						</section>
						</section>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3>Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">Xtext</a> on Twitter</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
	<script type="text/javascript" src="google-code-prettify/lang-common.js"></script><script type="text/javascript">
		registerLanguage('grammar|import|generate|terminal|enum|returns|with|hidden|as|current|fragment|EOF', 'xtext');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'xbase');
		registerLanguage('module|var|auto-inject|auto|inject|import|true|false', 'mwe2');
		registerLanguage('IMPORT|EXTENSION|FILE|ENDFILE|DEFINE|ENDDEFINE|FOR|ENDFOR|FOREACH|ENDFOREACH|AS|SEPARATOR|ITERATOR|EXPAND|REM|ENDREM|PROTECT|ENDPROTECT|this|IF|ENDIF|ELSE|null', 'xpand');
		registerLanguage('import|extension|this|create|cached|true|false|let|switch|case|if|then|else|context|WARNING|ERROR', 'check');
		registerLanguage('Hello', 'mydsl');
		registerLanguage('package|entity|datatype|many|import|extends|public|op|return|mapped-to', 'domainexample');
		registerLanguage('datatype|mapped-to', 'javatypesexample');
		registerLanguage('events|commands|state|actions|end|resetEvents', 'fowlerexample');
		registerLanguage('ref', 'linkingexample');
	</script>
</body>
</html>
