<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtext - Language Development Made Easy!</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages">
	<meta name="author" content="Sven Efftinge">
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<!--[if lt IE 9]>
	<link href="css/iebugs.css" rel="stylesheet" type='text/css'>
	<![endif]-->
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
					prettyPrint();
	         
					 $('a[data-rel]').each(function() {
	             $(this).attr('rel', $(this).data('rel'));
	         });
	        
					 $("a[rel^='prettyPhoto']").prettyPhoto({
	             animation_speed: 'fast',
	             slideshow: 5000,
	             autoplay_slideshow: false,
	             opacity: 0.80,
	             show_title: true,
	             theme: 'ligh_square',
	             overlay_gallery: false,
	             social_tools: false
	       
	         });
	         
					$('#nav-outline > li > a').live('click', function() {        
						$(this).parent().find('ul').slideToggle();      
					});
	         
					$('.has-popover').popover();
		 	     
		 	     getTwitters('tweet', { 
			        id: 'xtext', 
			        count: 5,
			        includeRT: true,
			        enableLinks: true, 
			        clearContents: true,
			        template : '"%text%" - %time% by <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">@%user_screen_name%</a><br/><br/>'
			     });
	         
	         var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		 	     po.src = 'https://apis.google.com/js/plusone.js';
		 	     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-3' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li class="active"><a href="7languages.html">7 Languages</a></li>
						<li ><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://xtend-lang.org">Xtend</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
				</div>
				<!--/.nav-collapse -->
		        <div class="btn-group pull-right">
		          <g:plusone href="http://www.xtext.org"></g:plusone>
		        </div>
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<div id="header_wrapper" class="container">
	<ul id="nav-outline">
		<li>&nbsp;</li>
		<li style="color : #333;">General Overview</li>
		<li><a href="#introduction">Introduction</a>
	<ul>	<li><a href="#_0">It's just two steps</a></li>
	</ul>	</li>
		<li><a href="#common_requirements">Common Requirements</a>
	<ul>	<li><a href="#installation">Getting the Code</a></li>
	</ul>	</li>
		<li><a href="#xtend_primer">A Short Xtend Primer</a>
		</li>
		<li>&nbsp;</li>
		<li style="color : #333;">The 7 Languages</li>
		<li><a href="#scripting">Scripting Language</a>
	<ul>	<li><a href="#scripting_solution">Overview</a></li>
		<li><a href="#scripting_running">Running the Example</a></li>
		<li><a href="#scripting_grammar">Grammar</a></li>
		<li><a href="#scripting_inferrer">Translation to Java</a></li>
	</ul>	</li>
		<li><a href="#builddsl">Build Language</a>
	<ul>	<li><a href="#builddsl_solution">Overview</a></li>
		<li><a href="#builddsl_running">Running the Example</a></li>
		<li><a href="#builddsl_grammar">Grammar</a></li>
		<li><a href="#builddsl_inferrer">Translation to Java</a></li>
		<li><a href="#builddsl_validation">Validation</a></li>
		<li><a href="#builddsl_imports">Static Imports</a></li>
		<li><a href="#builddsl_library">Operator Overloading</a></li>
		<li><a href="#builddsl_launch">Run as... Integration</a></li>
	</ul>	</li>
		<li><a href="#mongoDB">DSL for MongoDB</a>
	<ul>	<li><a href="#mongo_solution">Overview</a></li>
		<li><a href="#mongo_running">Running the Example</a></li>
		<li><a href="#mongo_grammar">Grammar</a></li>
		<li><a href="#mongo_inferrer">Translation to Java</a></li>
		<li><a href="#mongo_nameProvider">Qualified Name Provider</a></li>
		<li><a href="#mongo_validation">Validation</a></li>
		<li><a href="#mongo_visual">IDE Enhancements</a></li>
	</ul>	</li>
		<li><a href="#guice">DSL for Guice</a>
	<ul>	<li><a href="#guice_solution">Overview</a></li>
		<li><a href="#guice_running">Running the Example</a></li>
		<li><a href="#guice_grammar">Grammar</a></li>
		<li><a href="#guice_inferrer">Translation to Java</a></li>
		<li><a href="#guice_additons">Additional Aspects</a></li>
		<li><a href="#guice_beyond">Beyond This Example</a></li>
	</ul>	</li>
		<li><a href="#httpRouting">Http Routing Language</a>
	<ul>	<li><a href="#routing_solution">Overview</a></li>
		<li><a href="#routing_running">Running the Example</a></li>
		<li><a href="#routing_grammar">Grammar</a></li>
		<li><a href="#routing_inferrer">Translation to Java</a></li>
		<li><a href="#routing_additons">Additional Aspects</a></li>
	</ul>	</li>
		<li><a href="#template">Template Language</a>
	<ul>	<li><a href="#templates_solution">Overview</a></li>
		<li><a href="#templates_running">Running the Example</a></li>
		<li><a href="#templates_details">Implementation</a></li>
		<li><a href="#templates_grammar">Grammar</a></li>
		<li><a href="#templates_inferrer">Translation to Java</a></li>
		<li><a href="#templates_additons">Additional Aspects</a></li>
	</ul>	</li>
		<li><a href="#tortoise">Little Tortoise</a>
	<ul>	<li><a href="#tortoise_solution">Overview</a></li>
		<li><a href="#tortoise_running">Running the Example</a></li>
		<li><a href="#tortoise_grammar">Grammar</a></li>
		<li><a href="#tortoise_inferrer">Translation to Java</a></li>
		<li><a href="#tortoise_interpreter">Interpreter</a></li>
		<li><a href="#tortoise_additons">Literal Classes</a></li>
	</ul>	</li>
	</ul>
</div>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="introduction" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Introduction
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Building a domain-specific language (DSLs) for structural parts of an application has always been rather 
							easy with Xtext. But structure alone is not sufficient in many cases. When it comes to the behavioral parts users 
							often fall back to implementing them in Java, because expressions and statements are hard to get right and extremely complex and 
							therefore costly to implement.
						</p>
						<p>
							This document introduces and explains a new API, which allows to reuse predefined language constructs such as type references, 
							annotations and full-featured expressions anywhere in your languages. You not only reuse the grammar but the full implementation 
							including a compiler, interpreter, the whole type system and a tight IDE integration. And the best part is, that it is 
							relatively easy to do so.
						</p>
						<!--  section -->
						<section id="_0" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">It's just two steps</h2>
						<p>
							To get a fully working and compiling language you only need to do two things.
						</p>
						<!-- subsection -->
						<section id="_1" style="padding-top: 68px; margin-top: -68px;">
						<h3>Write the grammar</h3>
						<p>
							Using the traditional Xtext grammar language you freely describe the syntax of your language. The specialty for JVM
							languages is, that you inherit from an abstract grammar (org.eclipse.xtext.xbase.XbaseWithAnnotations) which predefine the syntax
							for the reusable parts. You do not need to use them all or actually any of them and you can of course chnge the syntax or add new
							concepts.
						</p>
						</section>
						<!-- subsection -->
						<section id="_2" style="padding-top: 68px; margin-top: -68px;">
						<h3>Map to Java</h3>
						<p>
							Having the grammar defined, you now need to tell Xtext what your language concepts mean in terms of Java constructs. 
							For that you use a special API, called the JvmModelInferrer, where you can create any number of Java classes, interfaces etc.
							from your languages constructs. This hook not only defines how your language is translated to Java, but also defines 
							the scope of used expressions. The expressions from your language 'live' in the context you give them in this hook.
							If you for instance want an expression to have access to certain local variables, just put it into a method with appropriate 
							parameters or use instance fields if that works better.
						</p>
						<p>
							This hook also reveals your DSL constructs to other JVM languages. The Java type system is used as a common hub to 
							integrate arbitrary languages with each other. You can for instance call <a href="#template">templates</a> directly from a <a href="#scripting">script</a>
							and vice versa. You do not even need to generate the equivalent Java code, everything is based on the Java types you
							create in the model inferrer.
						</p>
						<p>
							To better communicate the power and flexibility of these two abstractions, we have built seven example languages using on them.
							We have built:
						</p>
						<p>
							</p>
							<ul>
								<li><a href="#scripting">A simple scripting language</a></li>
								<li><a href="#builddsl">A Grade-like build DSL</a></li>
								<li><a href="#mongoDB">A DSL for statically-typed MongoDB documents</a></li>
								<li><a href="#guice">A Guice modules DSL</a></li>
								<li><a href="#httpRouting">A Playframework-like HTTP routing language</a></li>
								<li><a href="#template">A template language</a></li>
								<li><a href="#tortoise">A Logo-like programming environment for educational purposes</a></li>
							</ul>
							<p>
						</p>
						<p>
							Each language still is very simple and focuses on the value a DSL can add to the respective 
							scenario. It is meant to give you an idea of what is possible without being a full practical solution.
							Yet the languages are flexible and come with powerful core abstractions.
							We also covered different technical aspects of customization to the language infrastructure. Some langauges
							have special import logic, others have special syntax coloring, outline views or content assist.
							The new API for JVM languages does not mean that anything is hidden away and not customizable.
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="common_requirements" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Common Requirements
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							To run any of the examples, you will need <a href="http://www.eclipse.org/downloads">Eclipse 4.2 or higher</a>
							for your platform. In addition, you have to install <a href="http://www.xtend-lang.org/download.html">Xtend</a>
							and of course <a href="http://www.xtext.org/download.html">Xtext 2.3</a>.
						</p>
						<p>
							If you prefer a simple all-inclusive installation, consider downloading the latest
							<a href="http://download.itemis.com/distros">itemis distribution</a>.
						</p>
						<p>
							Additional requirements are mentioned in the <strong>Running the Example</strong> section of each chapter.
						</p>
						<!--  section -->
						<section id="installation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Getting the Code</h2>
						<p>
							You can get the source code for all languages from the github repository at
							<a href="https://github.com/xtext-dev/seven-languages-xtext.git">https://github.com/xtext-dev/seven-languages-xtext</a>.
							The repository contains two folders <strong>languages</strong> and <strong>examples</strong>. Download the plug-ins from <strong>languages</strong> into
							the root workspace and the <strong>examples</strong> into the runtime workspace spawned from the root one using
							<strong>Run &gt; Run Configurations... &gt; Eclipse Application &gt; Run (&lt;language&gt;)</strong>.
						</p>
						<p>
							Each language consists of several Eclipse projects
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td><strong>org.xtext.&lt;language&gt;</strong></td>
							<td>The base infrastructure</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.ui</strong></td>
							<td>The editor based on Eclipse</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.tests</strong></td>
							<td>Tests for the language</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.lib</strong></td>
							<td>Runtime library</td>
							</tr>
							<tr><td><strong>org.xtext.&lt;language&gt;.example</strong></td>
							<td>Examples for using the language</td>
							</tr>
							</table>
							<p>
							 
							We do not provide all plug-ins for all languages.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="xtend_primer" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							A Short Xtend Primer
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Any general code in the examples is implemented in <a href="http://www.xtend-lang.org">Xtend</a>. Xtend is 
							a more expressive and less verbose way to implement Java applications. It is 100% interoperable with Java APIs and 
							compiles to readable Java code. In addition, it uses the same expressions that we use in our example languages.
							In fact it is built with the same API you will learn through in this document, so this should also give you a taste of 
							how powerful JVM-languages built with Xtext can actually be.
						</p>
						<p>
							Xtend is designed to be easy to learn for Java developers. In this section we will shortly describe
							the most important language features needed in our examples. For a full description of the Xtend language, 
							please consult the <a href="http://www.xtend-lang.org/documentation">Xtend documentation</a>.
						</p>
						<p>
							Just like a Java file, an Xtend file starts with a <code class="prettyprint lang-xtend">package</code> declaration and an <code class="prettyprint lang-xtend">import</code>
							section followed by one or more classes. Semicolons are optional and classes are <code class="prettyprint lang-xtend">public</code> by default.
							Xtend classes can extend super classes and implement interfaces just like Java. It does not make any difference 
							whether they were originally declared in Xtend or in Java.
						</p>
						<p>
							<a name="xtend_property"></a>
							 
							JavaBean properties can be accessed directly by their name. The access will be automatically mapped to 
							the appropriate accessor method. That means you can write
							</p>
							<pre class="prettyprint lang-xtend linenums">
println(foo.bar)      // instead of println(foo.getBar())
foo.bar = baz         // instead of foo.setBar(baz)
foo.fooBars += foobar // instead of foo.getFooBars().add(foobar)</pre>
							<p>
							
							Empty parentheses on method calls can be skipped.
						</p>
						<p>
							<a name="xtend_methods"></a>
						</p>
						<p>
							Methods are introduced with the keyword <code class="prettyprint lang-xtend">def</code> or <code class="prettyprint lang-xtend">override</code> if they override/implement
							a super type's method. They are public if not specified otherwise. The value of the last expression is returned
							if no explicit return expression is used and the method's return type is not <code class="prettyprint lang-xtend">void</code>.
						</p>
						<p>
							<a name="xtend_variables"></a>
						</p>
						<p>
							Variables are declared with the keywords <code class="prettyprint lang-xtend">val</code> (final) or <code class="prettyprint lang-xtend">var</code> (non-final).
							Field declarations can use the same syntax or the same as in Java.
						</p>
						<p>
							<a name="xtend_typeinferrence"></a>
						</p>
						<p>
							Xtend is statically typed, but you do not have to specify the type in a declaration if it can be inferred
							from the context:
							</p>
							<pre class="prettyprint lang-xtend linenums">
val x = newArrayList('foo', 'bar', 'baz') // x is of type List&lt;String&gt;
def foo() {  // equivalent to  def int foo()...
  1
}</pre>
							<p>
						</p>
						<p>
							<a name="xtend_extension"></a>
							
							The methods of fields marked as <code class="prettyprint lang-xtend">extension</code> are callable in extension syntax. That means,
							you can put the first argument in front as if it were the receiver of the call, e.g.
							</p>
							<pre class="prettyprint lang-xtend linenums">
// assume the class Foo defines a method foo(Baz)
extension Foo

def bar(Baz baz) {
  baz.foo  // calls _foo.foo(baz)
}</pre>
							<p>
							
							Static methods can be put on the extension scope with a static extension import, e.g.
							</p>
							<pre class="prettyprint lang-xtend linenums">
import static extension java.util.Collections.*
...
val foo = singleton('foo') // calls Collections.&lt;String&gt;singleton('foo')</pre>
							<p>
						</p>
						<p>
							<a name="xtend_it"></a>
							
							In addition to Java's <code class="prettyprint lang-xtend">this</code>, you can define another implicit receiver variable named <code class="prettyprint lang-xtend">it</code>.
							As with <code class="prettyprint lang-xtend">this</code>, you can skip <code class="prettyprint lang-xtend">it</code> in feature calls, i.e.
							</p>
							<pre class="prettyprint lang-xtend linenums">
class Foo {
  def foo(Bar it) {
    foo // will call it.foo() or if it doesn't exist this.foo()
  }
}</pre>
							<p>
						</p>
						<p>
							<a name="xtend_lambda"></a>
							
							Xtend provides lambda expressions. These are anonymous functions in square brackets. 
							</p>
							<pre class="prettyprint lang-xtend linenums">
[String foo, String bar | foo + bar]  
  // a function (String foo, String bar) { foo + bar }</pre>
							<p>
							
							<a name="xtend_lambda_coercion"></a>
							
							As this is a bit bulky, there are more rules to make working with lambdas more attractive:
							</p>
							<ol>
								<li>When a lambda expression is the last argument in a method call, it can be put behind the closing parenthesis.</li>
								<li>Lambdas are automatically coerced to interfaces with a single function. Parameter types will be
								inferred.</li>
								<li>If you skip the declaration of the only parameter, it will be implicitly called <code class="prettyprint lang-xtend">it</code>.</li>
							</ol>
							<p>
							
							</p>
							<pre class="prettyprint lang-xtend linenums">
new Thread [ println("Hello concurrent world") ] 
  // lambda will be coerced to a Runnable
val list = newArrayList('fooooo', 'fo', 'foo')
list.sortBy[ length ]   
  // lambda is coerced into a function (String)=&gt;Comparable
  // equivalent to list.sortBy[Comparable it | it.length]</pre>
							<p>
						</p>
						<p>
							<a name="xtend_templates"></a>
							
							Also noteworthy is the template expression, which allows to define interpolated multi-line string literals.
							In addition, the template expressions has intelligent whitespace handling and supports a special <code class="prettyprint lang-xtend">FOR</code> and 
							<code class="prettyprint lang-xtend">IF</code> construct, which is far better readable in this context.
						</p>
						<p>
							We most often use this expression in the examples to generate some synthetic Java boilerplate code. Here is
							an example from the <a href="#httpRouting">http routing language</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
'''
  String url =  request.getRequestURL().toString();
  &laquo;FOR route : routes&raquo;
    {
      java.util.regex.Matcher _matcher = _pattern&laquo;route.index&raquo;.matcher(url);
      if (_matcher.find()) {
        &laquo;FOR variable : route.url.variables&raquo;
            String &laquo;variable.name&raquo; = _matcher.group(&laquo;variable.index + 1&raquo;);
        &laquo;ENDFOR&raquo;
        &laquo;IF route.condition != null&raquo;
          if (&laquo;route.nameOfRouteMethod&raquo;Condition(request, response
            &laquo;FOR v : route.url.variables 
             BEFORE ", " 
             SEPARATOR ", "&raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;))
        &laquo;ENDIF&raquo;
        &laquo;route.nameOfRouteMethod&raquo;(request, response
          &laquo;FOR v : route.url.variables&raquo;, &laquo;v.name&raquo;&laquo;ENDFOR&raquo;);
      }
    }
  &laquo;ENDFOR&raquo;
'''</pre>
							<p>
						</p>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="scripting" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Scripting Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The scripting language allows to write code without any preludes such as package, class or method declarations.
							Just open a fresh file and start coding. It's the simplest of the seven languages and is therefore a good starting point.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/scripting_screenshot.png" alt="" width="590" height="443">
							</div>
							<p>
						</p>
						<!--  section -->
						<section id="scripting_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							As you can see the language is straight forward: All you can do is write expressions and imports in any order.
							The expressions you see are the same available in Xtend and they are defined in its own grammar (called Xbase).
							They are syntactically very close to Java, but feature a lot of modern concepts, like lambda expressions
							and operator overloading. They support local type inference so you do not have to write types everyhwere
							like in Java, but the expressions are still statically-typed. 
							For a Java developer, the code should be self-explanatory. The Xbase expression language is exhaustively 
							covered in the <a href="http://www.xtext.org/documentation">Xtext documentation</a>.
						</p>
						<p>
							A script is compiled to a Java class with one main method. That is the script
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-scripting linenums">
println('Hello World!')</pre>
							<p>
						</p>
						<p>
							gets compiled to the following Java source code
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
package my.first;

public class Application {
  public static void main(String[] args) {
    System.out.println("Hello World!");
  }
}</pre>
							<p>
						</p>
						<p>
							Note that the core language infrastructure such as the parser, linker and compiler is not Eclipse-dependent,
							but the compilation is integrated with Eclipse for convenience reasons. All 7 languages can be parsed, copiled and executed
							without Eclipse. We could also make use of the interpreter which might make more sense for a sxcripting language.
							How to use and integrated the interpreter is explained in the sectiondescribing the <a href="#tortoise"></a> language.
						</p>
						</section>
						<!--  section -->
						<section id="scripting_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							Make sure you have the projects <strong>org.xtext.scripting</strong> and <strong>org.xtext.scripting.ui</strong> in your workspace.
							Then start a new Eclipse by choosing <strong>Run &gt; Run Configurations... &gt; Eclipse Application &gt; Run (org.xtext.scripting)</strong>.
							Import the project <strong>org.xtext.scripting.examples</strong> into your workspace using the <strong>Import existing projects
							into workspace</strong> wizard.
						</p>
						</section>
						<!--  section -->
						<section id="scripting_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							To build language with Xtext, you first have to define a grammar. As opposed to other parser generators,
							an Xtext grammar defines both, the lexical structure of the language and an object model (aka AST) that is build during parsing. 
							For more detailed description of the Xtext grammar language, please see the <a href="http://www.xtext.org/documentation">Xtext documentation</a>.
						</p>
						<p>
							The grammar for our DSL is rather simple. We inherit from <code class="prettyprint lang-xtend">org.eclipse.xtext.xbase.Xbase</code> to get the
							syntax of the expressions. As we want to refer to the type 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XBlockExpression.html"><abbr title="org.eclipse.xtext.xbase.XBlockExpression">XBlockExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XBlockExpression.java">(src)</a>, we have to import Xbase's Ecore model. The single type 
							inferred from this grammar goes into the Ecore model <code class="prettyprint lang-xtend">simpleExpressions</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.scripting.Scripting with org.eclipse.xtext.xbase.Xbase

generate scripting "http://www.xtext.org/scripting/Scripting"
import "http://www.eclipse.org/xtext/xbase/Xbase"

Script returns XBlockExpression:
  {Script} 
  // return an object of type Script which is a subtype of XBlockExpression
  ((expressions+=XExpressionInsideBlock | imports+=Import) ';'?)*;

Import:
  'import' importedNamespace=QualifiedNameWithWildcard;

QualifiedNameWithWildcard:
  QualifiedName '.*'?;</pre>
							<p>
						</p>
						<p>
							The main rule <strong>Script</strong> is defined to produce an object of type <code class="prettyprint lang-xtend">Script</code> which is a subtype of <code class="prettyprint lang-xtend">XBlockExpression</code>. 
							A block expression simply consists of any number of expressions. The rule <code class="prettyprint lang-xtend">XExpressionInsideBlock</code> is defined in the
							super grammar. Usually block expressions are surrounded by curly braces, but of course we do not
							want to force anybody to write curly braces at the beginning and the end of a simple script.
						</p>
						<p>
							In addition to expressions you can have any number of imports. Xtext has a very simple way to let you
							define imports, all you need to do is name a feature <code class="prettyprint lang-xtend">importedNamespace</code> and it will be interpreted
							as a namespace import. For JVM languages you might want to have additional functionality, like static
							imports which is explained in the section about the <a href="#builddsl">build DSL</a>.
						</p>
						</section>
						<!--  section -->
						<section id="scripting_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							To make our language executable, we have to define how its concepts relate to Java concepts. In Xtext, this
							is defined in the so called <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer">IJvmModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java">(src)</a>. The language
							generator automatically generates an Xtend stub for it. Nevertheless, it is up to the language developer to 
							implement the <code class="prettyprint lang-xtend">infer()</code> method.
						</p>
						<p>
							This hook is not only used to explain how to generate Java code, but also to give expressions a proper
							scope and to make your DSL constructs visible by other JVM languages. The Java type system is used as
							a common hub to integrate arbitrary languages.
						</p>
						<p>
							The inferrer is written in Xtend, if you are not yet familiar with it, you should read at least the 
							<a href="#xtend_primer">Xtend Primer</a> first.
						</p>
						<p>
							The JVM model inferrer code for the scripting language looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class ScriptingJvmModelInferrer extends AbstractModelInferrer {
  
  @Inject extension JvmTypesBuilder

  def dispatch void infer(Script script, 
                          IJvmDeclaredTypeAcceptor acceptor, 
                          boolean isPreIndexingPhase) {
    val className = script.eResource.URI.trimFileExtension.lastSegment
    acceptor.accept(script.toClass(className)).initializeLater [
      // the class gets one main method
      members += script.toMethod('main', script.newTypeRef('void')) [
        parameters += script.toParameter("args", 
            script.newTypeRef('java.lang.String')).addArrayTypeDimension)
        setStatic(true)
        // Associate the script as the body of the main method
        body = script
      ]
    ]
  }
}</pre>
							<p>
						</p>
						<p>
							It maps each script to one Java class with a main method. Note the use of <code class="prettyprint lang-xtend">script</code> as a receiver
							for all the factory methods. When creating a Java element, you need to pass a context so Xtext knows
							what the origin of a Java element is. This is used throughout the workbench for featurs like find references,
							call hierarchies, rename refactoring and more.
						</p>
						<p>
							As the whole script is an expression it is associated with the body of the main method. That association is important 
							since it defines the scope of the expression, which includes what variables, fields and methods are visible and what type is expected.
						</p>
						<p>
							In this case <code class="prettyprint lang-xtend">void</code> is expected, so you would get an error when using a return expression. Also the
							parameter <code class="prettyprint lang-xtend">args</code> defined in the main method is now on the scope. So you could write the following script:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-scripting linenums">
for (arg : args)
  println('-- '+arg)</pre>
							<p>
						</p>
						<p>
							As you can imagine, this is fairly powerful way to put things on the scope implicitly.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="builddsl" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Build Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Build tools likle Ant or Gradle decompose the build process into a set of tasks. A task can stand for
							a compilation, copying some files, bundling, running tests etc. The order of execution is calculated from 
							the dependencies of the tasks define.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/builddsl_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							This example show how to create a build DSL with Xtext. We leverage the full power of Xbase inside the
							bodies of the tasks, and manage command line parameters as well as task dependencies.
						</p>
						<!--  section -->
						<section id="builddsl_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							The above screenshot shows an examplary build script. A script has a couple of parameters. The 
							tasks define dependencies to other tasks. What happens if the task is executed is defined in a block
							within curly braces.
						</p>
						<p>
							A build script can be run from the command line, assigning values to the parameters in the syntax
							<code class="prettyprint lang-xtend">myscript --&lt;paramName&gt; &lt;value&gt;</code>.
						</p>
						<p>
							We have put most functionality of the language in the runtime library: Detecting the order of execution,
							parsing parameters, etc. The language itself concentrates on the structural parts, and leaves the actions
							to Xbase. With this approach, it has proven beneficial to allow additional library methods to be added
							via the extension method mechanism. So we do not ship a library of tasks as e.g. Ant does.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the runtime workspace, open the <strong>BuildExample.build</strong> in the editor. The example project comes with 
							some sample java code to compile in the <strong>example-project</strong> folder. Choose <strong>Run as &gt; Build Task</strong> from the context
							menu of any task to execute it.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The grammar of the DSL is once again quite slim:
							 
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.builddsl.BuildDSL with org.eclipse.xtext.xbase.Xbase

generate build "http://www.xtext.org/builddsl"

BuildFile:
  ("package" name=QualifiedName)?
  imports+=ImportDeclaration*
  declarations+=Declaration*;

ImportDeclaration:
  'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedNameWithWildCard:
  QualifiedName '.*'?;

Declaration:
  Task | Parameter;

Parameter:
  'param' type=JvmTypeReference? name=ValidID ('=' init=XExpression)?;

Task:
  'task' name=ValidID 
  ('depends' depends+=[Task|ValidID] (',' depends+=[Task|ValidID])*)?
  action=XBlockExpression;</pre>
							<p>
						</p>
						<p>
							First there is the usual package delaration and <strong>Import</strong> stuff. It is followed by the <strong>Declarations</strong>.
							A <strong>Declaration</strong> can be a <strong>Task</strong> or a <strong>Parameter</strong>. A <strong>Parameter</strong> can declare a type and an initialization
							expression. <strong>Tasks</strong> define dependencies on other tasks by means of an Xtext cross-reference. They also
							contain an action, which is a <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XBlockExpression.html"><abbr title="org.eclipse.xtext.xbase.XBlockExpression">XBlockExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/emf-gen/org/eclipse/xtext/xbase/XBlockExpression.java">(src)</a> from Xbase, thus everthing 
							is possible within a task.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							For each <strong>BuildFile</strong> we create a Java class that extends the library class 
							<abbr title="org.xtext.builddsl.lib.BuildScript">BuildScript</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/BuildScript.xtend">(src)</a>. We generate a main method allowing to execute the script as
							a Java application with command line parameters. The use of <code class="prettyprint lang-java">Sytem.exit</code> allows to return error codes
							to the caller.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
package sample</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
package sample;
...
public class SimpleBuild extends BuildScript {
...
  public static void main(final String[] args) {
    SimpleBuild script = new SimpleBuild();
    if (script.showHelp(args)) {
      System.exit(HELP);
    }
    System.exit(script.doBuild(args));
  }
...
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The respective inferrer code looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class BuildDSLJvmModelInferrer extends AbstractModelInferrer {

  @Inject extension JvmTypesBuilder
  @Inject ITypeProvider typeProvider

  def dispatch void infer(BuildFile file, 
                          IJvmDeclaredTypeAcceptor acceptor, 
                          boolean isPreIndexingPhase) {
    val fqn = file.javaClassName
    val scriptName = Strings::lastToken(fqn, ".")
    acceptor.accept(file.toClass(fqn)).initializeLater [
      superTypes += file.newTypeRef(typeof(BuildScript))
...      
      val stringArray = 
          file.newTypeRef(typeof(String)).addArrayTypeDimension
      members += file.toMethod("main", file.newTypeRef(Void::TYPE)) [
        parameters += toParameter("args", stringArray)
        setStatic(true)
        body = [ append('''
          &laquo;scriptName&raquo; script = new &laquo;scriptName&raquo;();
          if (script.showHelp(args)) {
            System.exit(HELP);
          }
          System.exit(script.doBuild(args));
        ''') ]
      ]
    ]
...</pre>
							<p>
						</p>
						<p>
							Each <strong>Task</strong> becomes a method in the Java class. A <abbr title="org.xtext.builddsl.lib.DependsOn">@DependsOn</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/DependsOn.java">(src)</a> annotation
							communicates the dependencies to the runtime. The superclass will scan for such annotations and execute
							the dependencies in the right order.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
task print depends prepare {
  print(name)
}</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@DependsOn("prepare")
protected void print() {
  InputOutput.&lt;String&gt;print(this.name);
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The annotation part may be interesting, so here is the snippet from the inferrer:
							 
							</p>
							<pre class="prettyprint lang-xtend linenums">
// a method for the actual task body
members += file.tasks.map[ task | toMethod(task.methodName, task.newTypeRef(Void::TYPE)) [
  visibility = JvmVisibility::PROTECTED
  annotations += task.toAnnotation(typeof(DependsOn)) =&gt; [
    values += eINSTANCE.createJvmStringAnnotationValue =&gt; [
      values += task.depends.map[name]
    ]
  ]
  body = task.action
]]</pre>
							<p>
						</p>
						<p>
							Finally, we create a field with the <abbr title="org.xtext.builddsl.lib.Param">@Param</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/Param.java">(src)</a> annotation from each <strong>Parameter</strong>. 
							The superclass will make the so marked fields initializable from command line arguments.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
param name = 'World'</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@Param
public String name = "World";</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The type can be skipped. If there is an initialization expression, the parameter's type is inferred using
							the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/typing/ITypeProvider.html"><abbr title="org.eclipse.xtext.xbase.typing.ITypeProvider">ITypeProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/typing/ITypeProvider.java">(src)</a>. If nothing is specified, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> 
							is assumed. In the inferrer, this looks like:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject ITypeProvider typeProvider
...
val type = declaredParameter.type 
  ?: typeProvider.getType(declaredParameter.init)
  ?: file.newTypeRef(typeof(String))</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_validation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Validation</h2>
						<p>
							When <strong>Tasks</strong> are depending on each other, cycles will break the computation of the execution order.
							There is a check for this constraint in the validator <abbr title="org.xtext.builddsl.validation.BuildDSLValidator">BuildDSLValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl/src/org/xtext/builddsl/validation/BuildDSLValidator.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class BuildDSLValidator extends XbaseJavaValidator {
...
  @Check
  def void checkNoRecursiveDependencies(Task task) {
    task.findDependentTasks [ cycle |
      if (cycle.size == 1) {
        error('''The task '&laquo;task.name&raquo;' cannot depend on itself.''', 
            cycle.head, DECLARATION__NAME, CYCLIC_DEPENDENCY)
      } else {
        error('''There is a cyclic dependency that involves tasks &laquo;
                cycle.map[name].join(", ")&raquo;''', 
              cycle.head, DECLARATION__NAME, CYCLIC_DEPENDENCY)
      }
    ]
  }
...</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_imports" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Static Imports</h2>
						<p>
							It is very likely that users want to add their own functionality, e.g. to format a file. To facilitate
							that, all imports in the build DSL are automatically static extension imports, too. That means, the static
							methods of an imported type are callable in <a href="#xtend_extension">extension syntax</a>. This is accomplished
							by binding our own <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/scoping/featurecalls/StaticImplicitMethodsFeatureForTypeProvider.html"><abbr title="org.eclipse.xtext.xbase.scoping.featurecalls.StaticImplicitMethodsFeatureForTypeProvider">StaticImplicitMethodsFeatureForTypeProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/scoping/featurecalls/StaticImplicitMethodsFeatureForTypeProvider.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class AllImportsAreStaticFeatureProvider 
    extends StaticImplicitMethodsFeatureForTypeProvider {

  override getVisibleTypesContainingStaticMethods(
      Iterable&lt;JvmTypeReference&gt; hierarchy) {
    val buildFile = context.contents.get(0) as BuildFile
    val importedTypes = &lt;String&gt;newArrayList
    for (importDeclaration : buildFile.imports) {
      val importedTypeOrPackage = importDeclaration.importedNamespace
      if (!importedTypeOrPackage.endsWith(".*")) {
        importedTypes += importedTypeOrPackage
      }
    }
    val result = Maps::newLinkedHashMap(
      super.getVisibleTypesContainingStaticMethods(hierarchy))
    for (entry : result.entrySet) {
      val copy = Sets::newLinkedHashSet(entry.getValue)
      copy += importedTypes
      entry.value = copy
    }
    return result
  }
}</pre>
							<p>
						</p>
						<p>
							We also ship some predefined extension classes to enhance the Java classes <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html"><abbr title="java.io.File">File</abbr></a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>
							and <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html"><abbr title="java.lang.Class">Class</abbr></a>. These are bound in a customized 
							<abbr title="org.xtext.builddsl.scoping.BuildDSLExtensionClassNameProvider">BuildDSLExtensionClassNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl/src/org/xtext/builddsl/scoping/BuildDSLExtensionClassNameProvider.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class BuildDSLExtensionClassNameProvider extends ExtensionClassNameProvider {
  override simpleComputeExtensionClasses() {
    super.simpleComputeExtensionClasses =&gt; [
      put(typeof(File), typeof(FileExtensions))
      put(typeof(String), typeof(FileExtensions))
      put(typeof(Class), typeof(ClassExtensions))
    ]
  }
}</pre>
							<p>
						</p>
						<p>
							As always, the new implementations have to be bound in the <abbr title="org.xtext.builddsl.BuildDSLRuntimeModule">BuildDSLRuntimeModule</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl/src/org/xtext/builddsl/BuildDSLRuntimeModule.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class BuildDSLRuntimeModule 
    extends org.xtext.builddsl.AbstractBuildDSLRuntimeModule {
...
  public Class&lt;? extends ExtensionClassNameProvider&gt; 
      bindExtensionClassNameProvider() {
    return BuildDSLExtensionClassNameProvider.class;
  }
  
  public Class&lt;? extends StaticImplicitMethodsFeatureForTypeProvider&gt; 
      bindStaticImplicitMethodsFeatureForTypeProvider() {
    return AllImportsAreStaticFeatureProvider.class;
  }
...</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_library" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Operator Overloading</h2>
						<p>
							As we expect a build language to deal with files and directories a lot, we have extended the syntax 
							around these in the <abbr title="org.xtext.builddsl.lib.FileExtensions">FileExtensions</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.lib/src/org/xtext/builddsl/lib/FileExtensions.xtend">(src)</a>. We leverage the fact that Xbase 
							allows to overload operators by means of library extensions. The following examples show how to avoid 
							the noisy constructor calls to <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html"><abbr title="java.io.File">File</abbr></a>:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-builddsl linenums">
val dir = 'someDir'.file
val file = dir / 'fileName.txt'
val theSameFile = 'someDir' / 'fileName.txt'</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
final File dir = FileExtensions.file("someDir");
final File file = FileExtensions.operator_divide(dir, "fileName.txt");
final File theSameFile = FileExtensions.operator_divide(
    "someDir", 
    "fileName.txt");</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The compiler replaces operators with method calls to methods named <code class="prettyprint lang-xtend">operator_&lt;operatorName&gt;()</code>.
							These have to be callable on the left operand, i.e. be a method of the left operands type or be added
							as an extension to the left operand type. In this case, we use the latter approach, as <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html"><abbr title="java.io.File">File</abbr></a>
							as well as <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> are sealed types. To learn more about operators and overloading
							them please consult the <a href="documentation.html#Xbase_Expressions_Operators">Xtext documentation</a>.
						</p>
						</section>
						<!--  section -->
						<section id="builddsl_launch" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Run as... Integration</h2>
						<p>
							To facilitate executing build scripts from wihtin Java, we have extended Eclipse's launch support. The
							respective classes are <abbr title="org.xtext.builddsl.ui.launch.BuildDSLLaunchDelegate">BuildDSLLaunchDelegate</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.ui/src/org/xtext/builddsl/ui/launch/BuildDSLLaunchDelegate.xtend">(src)</a>,
							<abbr title="org.xtext.builddsl.ui.launch.BuildDSLLaunchShortcut">BuildDSLLaunchShortcut</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.ui/src/org/xtext/builddsl/ui/launch/BuildDSLLaunchShortcut.xtend">(src)</a> and 
							<abbr title="org.xtext.builddsl.ui.launch.BuildDSLLaunchTabGroup">BuildDSLLaunchTabGroup</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.builddsl.ui/src/org/xtext/builddsl/ui/launch/BuildDSLLaunchTabGroup.xtend">(src)</a>. Describing all the details would be a bit
							lengthy but it is uite straight-forward if you are familiar with the launching API.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="mongoDB" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							DSL for MongoDB
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							<a href="http://www.mongodb.org">MongoDB</a> is a very popular document-based database management system. 
							In mongoDB, database entries (AKA <strong>documents</strong>) have fields, which are essentially <strong>(key, value)</strong> pairs.
							MongoDB is schema free, i.e. there are no rules, which fields have to be defined and of what type they are.
							This allows for very flexible and heterogeneous data structures and maps perfectly with JSON.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/mongobeans_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							OTOH, Java is statically typed: The available types, their field names and field types, are known and validated 
							at compile time. The JavaBeans convention defines how instances can be manipulated. the standard mongoDB Java 
							driver reflects mongoDB's schema freeness by providing mongo documents as raw Java maps. This results in some 
							major annoyances: 
							</p>
							<ul>
								<li>You can ask a <a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> for the value of a specific field, but you cannot be sure 
								that the returned <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html"><abbr title="java.lang.Object">Object</abbr></a> is of some expected type. You are losing Java's compile
								time type checks for your domain elements and the generic code becomes hard to read.</li>
								<li>Additional behavior of the domain elements that would usually go into methods of your entity classes has 
								to be defined by external helper classes.</li>
								<li>Constructing a graph of nested generic maps looks pretty bulky and inconvenient in Java and breaks with 
								the JavaBeans conventions.</li>
							</ul>
							<p>
						</p>
						<!--  section -->
						<section id="mongo_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							In this project, we have created a small DSL <strong>mongoBeans</strong> based on Xtext that allows to create basic 
							entity classes that are backed by mongoDB objects but provide a statically typed JavaBeans API. Think of 
							the language as a description how to map mongoDB documents to JavaBeans, in analogy to well known object 
							relational mappers.
						</p>
						<p>
							An example mongoBeans file looks like this:
							</p>
							<pre class="prettyprint lang-mongobeans linenums">
import java.util.*

package org.musicdb {
    // a mongo bean
    Artist {
        String name    // single valued property
        Album* albums  // array property
        // an operation
        Iterable&lt;Track&gt; getOevre() {
            albums.map[track].flatten
        }
    }

    // another mongo bean
    Album {
        String title 
        int year 
        // inline definition of a mongo bean
        Track {        
            String title
            int seconds
        }* tracks
    }
}</pre>
							<p>
						</p>
						<p>
							For each <strong>MongoBean</strong> definition in a <strong>MongoFile</strong> file, we generate a Java class that wraps a 
							<a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a>. The class provides statically typed getter and setter methods for all 
							defined <strong>MongoProperties</strong>. In the implementation of these accessor methods we delegate to the wrapped
							<a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> and do all the casting and conversion work. For the <code class="prettyprint lang-xtend">Artist</code> in the 
							above example, this would look like
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class Artist implements IMongoBean {

  private DBObject _dbObject;  
  ...
  public String getName() {
    return (String) _dbObject.get("name");
  }
  
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  ...
}</pre>
							<p>
						</p>
						<p>
							By using the generating Java code, the rest of the application can use a safe, statically typed and 
							JavaBeans conformant API to access the data model. In addition, <strong>MongoBeans</strong> can define <strong>MongoOperations</strong>, 
							which are translated to Java methods. We can use <strong>MongoProperties</strong> as well as Java types inside the 
							operations' bodies.
						</p>
						<p>
							Client code could then look like this:
							</p>
							<pre class="prettyprint lang-java linenums">
Artist john = new Artist();
john.setName("John Coltrane");
Album album = new Album();
album.setTitle("A Love Supreme");
john.getAlbums().add(album);
Track...  // create some tracks and add them to the album
 
System.out.println(john.getName() + "'s Oevre");
for(Track track: john.getOevre()) 
  System.out.println(track.getTitle());

DBCollection dbCollection = ... // standard mongoDB driver code
dbCollection.save(john.getDBObject())</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="mongo_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In addition to the <a href="#common_requirements">common requirements</a>, you need the 
							<a href="http://www.mongodb.org/downloads">mongoDB implementation</a> for your platform. We have included 
							the mongoDB Java driver from <a href="http://download.eclipse.org/tools/orbit/downloads/">Eclipse Orbit</a> 
							in the code base.
						</p>
						<p>
							Import the projects into an Eclipse workspace and run the launch config 
							<strong>Run (org.eclipse.xtext.mongobeans)</strong>. Import the example plug-in into the new workspace and run 
							<code class="prettyprint lang-xtend">MusicDBXtendTest</code> as a JUnit test.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The complete mongoBeans grammar looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.mongobeans.MongoBeans with org.eclipse.xtext.xbase.Xbase

generate mongoBeans "http://www.eclipse.org/xtext/mongobeans/MongoBeans"

MongoFile:
  elements+=AbstractElement*;

Import:
  'import' importedNamespace=QualifiedNameWithWildcard;

AbstractElement:
  Import | PackageDeclaration | MongoBean;

PackageDeclaration:
  'package' name=QualifiedName '{'
    elements+=AbstractElement*
  '}';

MongoBean:
  name=ValidID '{'
    features+=AbstractFeature*
  '}';

AbstractFeature:
  MongoOperation | MongoProperty;

MongoProperty:
  (type=JvmTypeReference | inlineType=MongoBean) (many?='*')? name=ValidID;

MongoOperation:
  =&gt;(returnType=JvmTypeReference name=ValidID '(') 
    (parameters+=FullJvmFormalParameter 
    	(',' parameters+=FullJvmFormalParameter)*)? 
  ')' 
  body=XBlockExpression;

QualifiedNameWithWildcard:
  QualifiedName (".*")?;</pre>
							<p>
						</p>
						<p>
							The grammar inherits from the grammar of <code class="prettyprint lang-xtend">Xbase</code> in order to allow Xbase expressions and references to Java 
							elements. A <strong>MongoFile</strong> contains any number of <strong>AbstractElements</strong>, which can be <strong>PackageDeclarations</strong>,
							<strong>Imports</strong> or <strong>MongoBeans</strong>. <strong>Imports</strong> use Xtext's naming convention <code class="prettyprint lang-xtend">importedNamespace</code> to automatically 
							shorten qualified names of matching elements. Note that as opposed to Java, <strong>PackageDeclarations</strong> can be nested.     
							<strong>MongoBeans</strong> define statically typed MongoProperties, which can be single-valued or multi-valued denoted by an 
							<code class="prettyprint lang-xtend">*</code> following the type name. The type of a <strong>MongoProperty</strong> can also be defined inline. <strong>MongoBeans</strong> can 
							also define <strong>MongoOperations</strong>. The body of such an operation is an <strong>XBlockExpression</strong> from Xbase.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							The JVM model inference is implemented in the <abbr title="org.xtext.mongobeans.jvmmodel.MongoBeansJvmModelInferrer">MongoBeansJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/jvmmodel/MongoBeansJvmModelInferrer.xtend">(src)</a>.
							As the generated code is quite rich, this is the most complex component of this language.
						</p>
						<p>
							For each <strong>MongoBean</strong>, we create a Java class implementing the interface <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>.
							This interface is the first type of a small runtime library that has to be on the classpath at runtime.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
package org.musicdb {
  Artist { ...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
package org.musicdb;
...
public class Artist implements IMongoBean {  ...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code responsible for this section looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
@Inject extension IQualifiedNameProvider  
...
def dispatch void infer(MongoFile file, 
                        IJvmDeclaredTypeAcceptor acceptor, 
                        boolean isPreIndexingPhase) {
  for(bean : file.eAllOfType(typeof(MongoBean))) {
       acceptor.accept(bean.toClass(bean.fullyQualifiedName))
         .initializeLater([
           documentation = bean.documentation
           superTypes += newTypeRef(bean, 'org.xtext.mongobeans.IMongoBean')
... // calling various methods to create Java members
    // from the AbstractFeatures
         ])
  }
}</pre>
							<p>
						</p>
						<p>
							First, it finds all elements of type <strong>MongoBean</strong> in the given <strong>MongoFile</strong>. For each of these, it creates a new 
							Java class. Then the documentation is copied and the interface <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>
							is added to the supertypes. This will also insert a Java import at the appropriate location.
						</p>
						<p>
							Each <strong>MongoBean</strong> wraps a <a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a>, which is represented as a Java field with a 
							getter. There are two constructors, one for a given <a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> and one that 
							creates a new one. We have to store the class name in the DB object, if we want to be able to restore
							JavaBeans from query results.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
Artist { ...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public class Artist implements IMongoBean { 
  private DBObject _dbObject;
  
  public DBObject getDbObject() {
    return this._dbObject;
  }

  public Artist(final DBObject dbObject) {
    this._dbObject = dbObject;
  }
  
  public Artist() {
    _dbObject = new BasicDBObject();
    _dbObject.put(JAVA_CLASS_KEY, "org.musicdb.Artist");
  }
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code does this in two separate methods: One for the property <code class="prettyprint lang-xtend">_dbObject</code> and another
							for the constructors.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addDbObjectProperty(JvmDeclaredType 
                                  inferredType, 
                                  MongoBean bean) {
  inferredType.members += bean.toField('_dbObject', 
      newTypeRef(bean, 'com.mongodb.DBObject'))
  inferredType.members += bean.toGetter('dbObject', '_dbObject',
      newTypeRef(bean, 'com.mongodb.DBObject'))
}

def protected addConstructors(JvmDeclaredType inferredType, 
                              MongoBean bean) {
  inferredType.members += bean.toConstructor [
    documentation = '''...'''
    parameters += toParameter("dbObject", 
        newTypeRef(bean, 'com.mongodb.DBObject'))
    body = [
      append('''
        this._dbObject = dbObject;
      ''')
    ]
  ]
  inferredType.members += bean.toConstructor [
    documentation = '''...'''
    body = [
      append('''
        _dbObject = new com.mongodb.BasicDBObject();
        _dbObject.put(JAVA_CLASS_KEY, "&laquo;inferredType.identifier&raquo;");
      ''')
    ]
  ]
}</pre>
							<p>
						</p>
						<p>
							Next on our list are the getters and setters delegating to the <code class="prettyprint lang-xtend">_dbObject</code>. We have to handle four
							cases: Properties with a type that can be handled by the mongoDB Java-driver directly (most primitive types,
							<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html"><abbr title="java.util.Date">Date</abbr></a>, etc.), <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>
							properties, and their respective multi-valued counterparts:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
...
  String name     // primitive property
  Artist friend   // bean-type property
  String* aliases // multi-valued primitive property
  Album* albums   // multi-valued bean-type property
...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
...
  public String getName() {
    return (String) _dbObject.get("name");
  }
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  
  public Artist getFriend() {
    return WrappingUtil.wrapAndCast(
        (DBObject) _dbObject.get("friend"));
  }
  public void setFriend(final Artist friend) {
     _dbObject.put("friend", WrappingUtil.unwrap(friend));
  }
  
  public List&lt;String&gt; getAliases() {
    return (List&lt;String&gt;) _dbObject.get("aliases");
  }
  
  private MongoBeanList&lt;Album&gt; _albums;
  public List&lt;Album&gt; getAlbums() {
    if(_albums==null)
      _albums = new MongoBeanList&lt;Album&gt;(_dbObject, "albums");
    return _albums;
  }
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The runtime helper class <abbr title="org.xtext.mongobeans.lib.WrappingUtil">WrappingUtil</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/WrappingUtil.xtend">(src)</a> does the conversion between 
							<a href="http://api.mongodb.org/java/2.6/com/mongodb/DBObject.html"><abbr title="com.mongodb.DBObject">DBObject</abbr></a> and <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a>. For multi-valued <strong>MongoProperties</strong>
							we need getters only. If they have a primitive type, they can be handled by the Java-driver directly. Multi-valued 
							<strong>MongoBean</strong> typed properties require a special <abbr title="org.xtext.mongobeans.lib.MongoBeanList">MongoBeanList</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/MongoBeanList.xtend">(src)</a> to automatically 
							wrap/unwrap the elements.
						</p>
						<p>
							The corresponding inferrer code does not show anything particularly new so we skip most of it for brevity. To detect 
							whether a type is an <abbr title="org.xtext.mongobeans.lib.IMongoBean">IMongoBean</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.lib/src/org/xtext/mongobeans/lib/IMongoBean.java">(src)</a> or a primitive mongoDB type, we use the last helper 
							class <abbr title="org.xtext.mongobeans.jvmmodel.MongoTypes">MongoTypes</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/jvmmodel/MongoTypes.xtend">(src)</a>. The following snippet shows the inference of the getter for
							multi-valued properties:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addListAccessor(JvmDeclaredType inferredType,
                              MongoProperty property) {
  if(isMongoPrimitiveType(property.jvmType)) {
    inferredType.members += property.toMethod(
      'get' + property.name.toFirstUpper, 
       newTypeRef(property, 'java.util.List', 
         property.jvmType.asWrapperTypeIfPrimitive)
    ) [
...
    ]    
  } else {
    inferredType.members += property.toField(
      '_' + property.name, newTypeRef(property,
        'org.xtext.mongobeans.MongoBeanList', property.jvmType))
    inferredType.members += property.toMethod(
      'get' + property.name.toFirstUpper,
      newTypeRef(property, 'java.util.List', property.jvmType)
    ) [
 ...</pre>
							<p>
						</p>
						<p>
							Last but not least, we infer Java methods for <strong>MongoOperations</strong>.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-mongobeans linenums">
...
  Iterable&lt;Track&gt; getOevre() {
      albums.map[tracks].flatten
  }
...</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
...
  public Iterable&lt;Track&gt; getOevre() {
    // some java code you really don't care about 
    // but it should just do the right thing
  }
...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code for this particular task is surprisingly simple, as we can directly associate the
							body of the <strong>MongoOperation</strong>  to the generated Java method. The Xbase compiler will automatically 
							transform that to Java.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addMethod(JvmDeclaredType inferredType, 
                        MongoOperation operation) {
  inferredType.members += operation.toMethod(operation.name, 
      operation.returnType) [
    documentation = operation.documentation
    for(parameter: operation.parameters)
      parameters += parameter.toParameter(parameter.name, 
          parameter.parameterType)
    body = operation.body
  ]
}</pre>
							<p>
						</p>
						<p>
							That was a lot of code, but because it is the essence of this language we hope it has been worthwhile.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_nameProvider" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Qualified Name Provider</h2>
						<p>
							By default, the qualified name of an element is calculated by concatening all the simple names of its 
							containers with a dot. In our example, the <strong>MongoBean</strong> <code class="prettyprint lang-xtend">Track</code> would consequently be named 
							<code class="prettyprint lang-xtend">org.musicdb.Album.track.Track</code>. To ignore properties and beans on the path, we implemented our own
							<abbr title="org.xtext.mongobeans.scoping.MongoQualifiedNameProvider">MongoQualifiedNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/scoping/MongoQualifiedNameProvider.xtend">(src)</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoQualifiedNameProvider extends XbaseQualifiedNameProvider {
  
  def qualifiedName(MongoBean mongoBean) {
    val packageDeclaration = 
      mongoBean.getContainerOfType(typeof(PackageDeclaration))
    if(packageDeclaration != null) 
      packageDeclaration.fullyQualifiedName.append(mongoBean.name)
    else
      return QualifiedName::create(mongoBean.name)
  }
}</pre>
							<p>
						</p>
						<p>
							To make the framework pick up our customization, we have to add a binding in the respective 
							Guice module <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/MongoBeansRuntimeModule.java">(src)</a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
@Override
public Class&lt;? extends IQualifiedNameProvider&gt; bindIQualifiedNameProvider() {
  return MongoQualifiedNameProvider.class;
}</pre>
							<p>
						</p>
						<p>
							See the <a href="http://www.xtext.org/documentation">Xtext documentation</a> to learn more about Xtext's 
							dependency injection.
						</p>
						</section>
						<!--  section -->
						<section id="mongo_validation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Validation</h2>
						<p>
							The Java driver for mongoDB cannot map all Java types to mongoDB types. To enforce that constraint, 
							we have added the <abbr title="org.xtext.mongobeans.validation.MongoBeansValidator">MongoBeansValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans/src/org/xtext/mongobeans/validation/MongoBeansValidator.xtend">(src)</a>. It also checks for missing types 
							and avoids name collisions in the generated code with the implicitly defined property <code class="prettyprint lang-xtend">dbObject</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansValidator extends XbaseJavaValidator {
...
  @Inject extension MongoTypes mongoTypes
  
  @Check def checkMongoProperty(MongoProperty it) {
    if (name == 'dbObject') 
      error("Illegal property name 'dbObject'", 
            ABSTRACT_FEATURE__NAME, 
            ILLEGAL_PROPERTY_NAME, 
            '_' + name)
    if (type != null) {
      if (!type.isMongoType)
        error('Only MongoBeans and mappable types are allowed',
              MONGO_PROPERTY__TYPE, ILLEGAL_TYPE)
    } else if (inlineType == null) {
      error('Type must be set', ABSTRACT_FEATURE__NAME, MISSING_TYPE)
    }
  }
...</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="mongo_visual" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">IDE Enhancements</h2>
						<p>
							The validator from the previous section raises an error <code class="prettyprint lang-xtend">ILLEGAL_PROPERTY_NAME</code> when a property is named <strong>dbObject</strong>.
							We have implemented a quick fix to replace the invalid name:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansQuickfixProvider extends XbaseWithAnnotationsQuickfixProvider {

  @Fix(MongoBeansValidator::ILLEGAL_PROPERTY_NAME)
  def void capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
    acceptor.accept(issue, 
        'Rename to ' + issue.data.head, 
        '''Rename property to &laquo;issue.data.head&raquo;.''', 
        null) [
      xtextDocument.replace(issue.offset, issue.length, issue.data.head)
    ]
  }
}</pre>
							<p>
						</p>
						<p>
							To improve the language IDE visually, we have tuned the 
							outline <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.ui/src/org/xtext/mongobeans/ui/outline/MongoBeansOutlineTreeProvider.xtend">(src)</a> a bit
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansOutlineTreeProvider extends DefaultOutlineTreeProvider {
  // don't show children of operations
  def _isLeaf(MongoOperation operation) {
    true
  }
  
  // show inline declared MongoBeans
  def _createChildren(IOutlineNode parentNode, MongoProperty property) {
    if(property.inlineType != null)
      parentNode.createNode(property.inlineType)
  }
  
  def _isLeaf(MongoProperty property) {
    property.inlineType == null
  }
}</pre>
							<p>
						</p>
						<p>
							and the label provider <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.mongobeans.ui/src/org/xtext/mongobeans/ui/labeling/MongoBeansLabelProvider.xtend">(src)</a> as well:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class MongoBeansLabelProvider extends XbaseLabelProvider {
...  
  override image(Object element) {
    // icons are stored in the 'icons' folder of this project
    switch element {
      MongoBean: 'Letter-B-blue-icon.png'
      MongoProperty: 'Letter-P-orange-icon.png'
      MongoOperation: 'Letter-O-red-icon.png'
      Import: 'imp_obj.gif'
      PackageDeclaration: 'package_obj.gif'
      default:
        super.image(element)
    }
  }</pre>
							<p>
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="guice" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							DSL for Guice
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The Guice DSL is a little language that lets you define Guice modules 
							in a readable and declarative way.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/guicemodules_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<!--  section -->
						<section id="guice_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							Guice is a great dependency injection container, which instead uses Java types and
							annotations to declare and refer to injection points. You could for instance have the following
							field:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
@Inject
										  @Named("properties") Map&lt;String,String&gt; properties;</pre>
							<p>
						</p>
						<p>
							A module is used to explain to the framework what instance to inject into such injection points.
							For that Guice comes with a fluent interface API written in Java and a couple of tricks (e.g. TypeLiteral) to
							make the configuration as readable and maintainable as possible.
						</p>
						<p>
							You could for instance declare the following module:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class MyModule implements Module {
	@Override
	public void configure(Binder binder) {
		Map&lt;String,String&gt; properties = Maps.newHashMap();
		properties.put("debugLevel", "info");
		
		binder.bind(new TypeLiteral&lt;Map&lt;String,String&gt;&gt;(){})
			.annotatedWith(Names.named("properties"))
			.toInstance(properties);
	}
}</pre>
							<p>
						</p>
						<p>
							The big advantage of using Java over an external text or XML file, is that you can leverage
							the IDE and the type checking. We want to have that. The downside is that you have to trick (i.e. TypeLiteral) a lot in
							order to have an ok syntax. Also since the configuration is 'hidden' in a method implementation and not
							really declarative you cannot validate a Guice module at compile time.
						</p>
						<p>
							The Guice DSL described in this section let's you describe aboves module like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-guice linenums">
MyModule {
	@Named("properties") Map&lt;String,String&gt; to-instance newHashMap('debugLevel' -&gt; 'info')
}</pre>
							<p>
						</p>
						<p>
							This not only uses the exact same syntax one uses in any injection points, but also opens up all kinds
							of possibilities for static analysis. Usually the instantiation of a Guice injector at runtime takes up qute some time
							, because all the very helpful validation is done at that time. A language like the one described in this section can
							potentially do all theses analysis at compile time, minimizing the start up time.
						</p>
						</section>
						<!--  section -->
						<section id="guice_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the example located in the project <strong>org.xtext.guicemodules.examples</strong> two modules are declared, one
							for a possible runtime scenarion and one for a test scenarion (yes, you sometimes want a module for tests).
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-guice linenums">
import com.acme.*
import com.acme.impl.*

com.acme.RuntimeModule {
	bind DataProvider to FileDataProvider
	bind @DataFile String to-instance 'my-data.txt'
}

com.acme.TestModule mixin RuntimeModule {
	bind DataProvider to-instance [| 'dummy-data' ]
	bind LoggingService to BufferedLoggingService
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="guice_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The grammar is less than 30 lines long. It allows to declare any number of imports using the import mechanism
							already described in <a href="#scripting_grammar"></a>. A module can 'mixin' any number of other modules, which allows
							to reuse existing modules but override keys with different bindings. The mixin feature is described as a 
							crossreference to another <code class="prettyprint lang-xtend">ModuleAST</code>. Cross references are covered in detail in the <a href="http://www.eclipse.org/Xtext/documentation.html#cross_reference">Xtext documentation</a>.
						</p>
						<p>
							The language allows to bind keys to other keys and to instances. Other concepts like binding to providers
							is something you could do, but wouldn't help in getting the idea across. Everybody is encouraged to fork
							this first prototype and build something really useful ;-).
						</p>
						<p>
							Instead of extending the grammar <code class="prettyprint lang-xtend">org.eclipse.xtext.xbase.Xbase</code> the grammar <code class="prettyprint lang-xtend">org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations</code>
							is extended which adds full support for annotations. You just have to refer to the rule <code class="prettyprint lang-xtend">XAnnotation</code>
							as it is done in the rule <code class="prettyprint lang-xtend">KeyAST</code>. Btw. it's sometimes a good idea to suffix (or prefix) the AST
							node types to avoid confusion when working with a library where concepts are named similarly.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.guicemodules.GuiceModules 
	with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
 
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
generate guiceModules "http://www.xtext.org/guicemodules/GuiceModules"
  
ModulesAST :
	imports+=ImportAST*
	modules+=ModuleAST*;

ModuleAST :
	name=QualifiedName ('mixin' mixins+=[ModuleAST|QualifiedName] (',' mixins+=[ModuleAST|QualifiedName])*)? 
	'{'
		bindings+=BindingAST*
	'}'
;

BindingAST:
	'bind' from=KeyAST ('to' to=KeyAST | 'to-instance' toInstance=XExpression)?;

KeyAST:
	annotation=XAnnotation? type=JvmTypeReference;

ImportAST:
	'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedNameWithWildCard:
	QualifiedName '.*'?;</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="guice_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							A module is mapped to a single java class. The 'mixin' modules are not translated to Java inheritance
							but to a delegation approach. So a module like the following:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-guice linenums">
MyModule mixin OtherModule { 
}</pre>
							<p>
						</p>
						<p>
							Is translated to a Java class like :
							</p>
							<pre class="prettyprint lang-java linenums">
public class MyModule implements Module {

  private OtherModule otherModule = new OtherModule();

  public void configure(final Binder binder) {
    configure(binder, new java.util.HashSet&lt;com.google.inject.Key&lt;?&gt;&gt;());
  }
  
  public void configure(final Binder bind, final Set&lt;Key&lt;? extends Object&gt;&gt; usedKeys) {
    try {
    	testModule.configure(bind, usedKeys);
    } catch (Exception e) {
    	throw new RuntimeException(e);
    }
    
  }
}</pre>
							<p>
						</p>
						<p>
							As you can see, the language simply leverages the nice equals/hashcode implementation of guice's <a href="http://google-guice.googlecode.com/svn/trunk/javadoc/com/google/inject/Key.html"><abbr title="com.google.inject.Key">Key</abbr></a>
							to implement the override semantics of mixed in modules.
						</p>
						</section>
						<!--  section -->
						<section id="guice_additons" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Additional Aspects</h2>
						<p>
							Addtionally customized things: validation, scoping, code completion ...
						</p>
						</section>
						<!--  section -->
						<section id="guice_beyond" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Beyond This Example</h2>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="httpRouting" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Http Routing Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							There are several different frameworks out there like <a href="https://github.com/playframework/Play20/wiki/ScalaRouting">Play</a>
							to support HttpRoutes.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/httprouting_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							Normally they are defined in a special format in a separated central file. In most of the cases there is no tooling except a normal text/XML editor. 
							The only way to decide which route matches is the URL with different wildcards and placeholders. 
							The order of the routes defined in the file is important to decide which matches first. There is no support to access parts of the URL while the mapping is done.
							In most of the cases you might want to have full control via expressions to decide which action should be called. 
							Normally concrete classes are used directly in the route definition to point to an action that should be triggered. That's not really reusable in different scenarios and dependency injection is what you would really like to use.
						</p>
						<!--  section -->
						<section id="routing_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							In this project, we have created a small DSL base on <a href="http://www.xtext.org">Xtext</a> that allows to create routing with full support of expressions and access to the URL while the routing is done.
							The result is a javax.servlet.http.HttpServlet that has methods for the different routes with optional conditions and <a href="http://code.google.com/p/google-guice">Guice</a> bindings. Depending on the order in the file, the pattern and the conditions the respective method is called. 
							Eventually, we do only have a single <code class="prettyprint lang-xtend">javax.servlet.http.HttpServlet</code> containing the logic for routing implemented in Java. 
							To define routes you'll have to create a file with the extension '.route'. The first part of a route defines the type (GET, POST, PUT, DELETE or HEAD) of the route and the pattern.
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* ...</code>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">:id</code> means a placeholder for a word</li>
								<li><code class="prettyprint lang-xtend">:rest*</code> means match everything to the rest of the url</li>
							</ul>
							<p>
							
							Then you have the possibility to define a condition like:
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ...</code>
							Here you have access to id and rest statically typed to String. The servlet will provide the value of the placeholder or wildcard when the mapping takes place. 
							An optional annotated Guice-key could be used after the condition or pattern to get an instance of that type/interface and trigger an operation. 
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass-&gt;doSomething(Integer::parseInt(id))</code>
							You'll see that there is access to all features of the bound type/interface with access to the placeholders or wildcard values from the URL.
							If you want to call static methods there is no need for a Guice-key. 
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass::doSomethingStatic(id)</code>
							In both cases you have the possibility to feed the methods with an expression.
						</p>
						<p>
							To map that to Java we have to clarify what concepts we have and where we should hook in.
							First of all a <code class="prettyprint lang-xtend">javax.servlet.http.HttpServlet</code> has exactly one method for each request type (GET,
							POST, ...). Within these methods we'll have to call our routing logic. A route describes a pattern, a condition, a guice-key and a call of an action. So a pattern should be translated to a field as regular expression. This helps to match the URL and extract the values out of
							the given URL from the request. A condition should be a method with a boolean returntype where the request and the values of the variables from the URL-pattern are handled in as parameters. 
							The guice-key should be a field annotated with whatever is specified by
							the user and @Inject to tell Guice to inject an implementation here. 
							There is one more need for a method to wrap the action call with same parameters as the condition.
							Now we have everything to fill in our logic inside of the global method of the HttpServlet. First of
							all we have to match the URL, extract the values for the variables and establish local variables for
							that. If there is a condition we have to establish a guard for the action call. Only when the pattern
							matches the URL and the condition is true the call should be triggered. Otherwise a following route should
							be evaluated in the same way.
						</p>
						<!-- subsection -->
						<section id="routing_statistics" style="padding-top: 68px; margin-top: -68px;">
						<h3>Some Stats</h3>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>Language name</td>
							<td>HttpRouting</td>
							</tr>
							<tr><td>Xtext Grammar</td>
							<td>39 LOC, 8 rules, 1 Enum</td>
							</tr>
							<tr><td>Xtext extensions</td>
							<td>6 classes</td>
							</tr>
							<tr><td>Execution</td>
							<td>Java code generator</td>
							</tr>
							<tr><td>Hardest Part</td>
							<td>Handle regular expressions :-)</td>
							</tr>
							</table>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="routing_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							You'll need Eclipse 3.5 or higher, Xtext 2.3 and Xtend 2.3. The Servlet-API on the class path of your project.
							Import the projects into an Eclipse workspace and run the launch config
							<strong>Run (org.eclipse.xtext.httprouting)</strong>. Now you may start with a new JavaProject or just import the project
							org.eclipse.httprouting.example. You'll see that the Servlet-API ist already included in the example.
						</p>
						</section>
						<!--  section -->
						<section id="routing_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The Routing DSL extends org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations to make use of expressions
							predefined by <a href="http://www.eclipse.org/Xtext/#xbase">Xbase</a> plus support for Annotations.
							<code class="prettyprint lang-xtext">grammar org.xtext.httprouting.Route with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations</code>
							</p>
							<pre class="prettyprint lang-xtext linenums">
Import:
	'import' importedType=[types::JvmType|QualifiedName];</pre>
							<p>
							
							The Route DSL defines imports by using crossreferences. This makes it possible to use contentassist here
							and it is clear that the imported type exist.
							</p>
							<pre class="prettyprint lang-xtext linenums">
Route:
	requestType=RequestType url=URL condition=Condition? (key=Key call=RouteFeatureCall | call=XFeatureCall);
	
URL:
	{URL} "/" (ID ("." ID)? | variables+=Variable) ("/" (ID ("." ID)? | variables+=Variable))*;
	
Variable:
	":" name=ID (wildcard?="*")?;
	
Condition:
	"when" expression=XExpression;
	
Key:
	annotations+=XAnnotation? type=JvmTypeReference;</pre>
							<p>
							
							A Route has a type followed by an URL-pattern that can define variables. A variable could be a placeholder
							':id' or a wildcard ':name*'. After the URL-pattern matches an optional condition can point out if the
							route matches. Here you'll have the full support Xbase offers with access to the defined variables.
						</p>
						<p>
							One special thing here is that we can point to an action-implementation in different ways. 
							One is to define a guice-key with an optinal annotation to specialize a
							binding and access an available feature of the type directly after that. The other is to have a static
							method call on a type. The difference between RouteFeatureCall and XFeatureCall is that RouteFeatureCall
							does not allow a static method call.If you would like to see the difference on a grammar level please
							compare XFeatureCall and RouteFeatureCall with each other.
						</p>
						</section>
						<!--  section -->
						<section id="routing_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							For each <strong>RouteFile</strong>, we create a Java class extending the class <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a>.
							The generated Java classes rely on the Servelet-API to work, so it has to be on the classpath.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td><code class="prettyprint lang-routing"></code></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
package org.xtext.httpRouting;
...
@SuppressWarnings("serial")
public class HttpMapperServlet extends HttpServlet {
 ...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code responsible for this section looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
				superTypes += model.newTypeRef("javax.servlet.http.HttpServlet")
   				annotations += model.toAnnotation(typeof(SuppressWarnings), "serial")
		... // calling various methods to create Java members with from the Routes
         ])
}</pre>
							<p>
						</p>
						<p>
							For each Route a URL-pattern should end in a compiled regular expression pattern stored in a field.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td><code class="prettyprint lang-routing">GET /client/foo/:id</code></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
private static Pattern pattern0 = Pattern.compile("/client/foo/(\\w+)");</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code responsible for this section looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		val routes = model.routes
   				var routeCounter = 0
   				for (route : routes) {
   					if (route.url != null) {
		   				addRoutePatternField(route, routeCounter)
		   				...
	   				}
					routeCounter = routeCounter + 1
   				}
		... //
         ])
}

def protected addRoutePatternField(JvmDeclaredType servlet, Route route, int routeCounter) {
		val patternField = route.url.toField("_pattern" + routeCounter , route.newTypeRef(typeof(Pattern))) [
			setStatic(true)
			setInitializer [
				append('Pattern.compile("')
				append(getRegExPattern(NodeModelUtils::getNode(route.url).text.trim, route.url.variables))
				append('")')
			]
		]
		servlet.members += patternField
   	}
...
def getRegExPattern(String originalPattern, List&lt;Variable&gt; variables) {
	var pattern = originalPattern
	for(variable : variables){
		if(variable.wildcard)
			pattern = pattern.replaceAll("(:" + variable.name + "\\*)", "(.+)")
		else
			pattern = originalPattern.replaceAll("(:" + variable.name + ")", "(\\\\\\\\w+)")
	}
	pattern
}
...</pre>
							<p>
						</p>
						<p>
							As we know the name of each variable we can replace the variable from the URL with a regualr expression
							with the same meaning to match the URL that has be routed. As we do not have a element in our model where
							the complete URL-pattern is stored we have to use the NodeModel to get the text behind the URL-pattern.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td><code class="prettyprint lang-routing">GET /client/foo/:id when id=='42'</code></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public boolean doGet0Condition(final HttpServletRequest request, final String id) {
   boolean _equals = Objects.equal(id, "42");
   return _equals;
 }</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							For each Route a condition should end in a method with a boolean return type. Each variable value should
							be handled in as a parameter. Same is true for the <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html"><abbr title="javax.servlet.http.HttpServletRequest">HttpServletRequest</abbr></a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...

def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		val routes = model.routes
   				var routeCounter = 0
   				for (route : routes) {
   					if (route.url != null) {
   						...
		   				addRouteConditionMethod(route, routeCounter)
		   				...
	   				}
					routeCounter = routeCounter + 1
   				}
		... //
         ])
}

def protected addRouteConditionMethod(JvmDeclaredType servlet, Route route, int routeCounter) {
	if (route.condition != null &amp;&amp; route.condition.expression != null) {
	   	val name = route.nameOfRouteMethod(routeCounter)
		servlet.members += route.toMethod(name + "Condition", route.newTypeRef(Boolean::TYPE)) [
			parameters += route.toParameter("request", route.newTypeRef(HTTP_REQUEST))
			for (variable : route.url.variables){
				parameters += variable.toParameter(variable.name, route.newTypeRef(typeof(String)))
			}
			body = route.condition.expression
		]
	}
}

def nameOfRouteMethod(Route route, int i) {
		"_do" + route.type.literal.toLowerCase.toFirstUpper + i
	}</pre>
							<p>
						</p>
						<p>
							The expression defined in the condition ends up in the body of the new create method. That implies that
							all things sourrounding the method (fields, methods and parameters) are accessable within the expression.
							Isn't that cool. ;-)
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@Inject
@Named(value = "ActionClassName")
private ActionClass key0;</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							For each Route a guice-key should end in a field with the defined annotations on it plus @Inject. As a guice-key is optional we have to make sure that route has a key. Now we create a field and add the
							annotations to it.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
			val routes = model.routes
			var routeCounter = 0
			for (route : routes) {
				if (route.url != null) {
	   				...
   					addRouteKeyField(route, routeCounter)
	   				...
   				}
				routeCounter = routeCounter + 1
			}
		...
         ])
}
...
def protected addRouteKeyField(JvmDeclaredType servlet, Route route, int routeCounter) {
		if (route.hasValidKey){
			servlet.members += route.key.toField("_key" + routeCounter, route.key.type) =&gt; [
				annotations += route.toAnnotation(typeof(Inject))
				route.key.annotations.translateAnnotationsTo(it)
			]
		}
   	}
...
def hasValidKey(Route route){
	route.key != null &amp;&amp; route.key.type != null &amp;&amp; !(route.key.type instanceof JvmVoid)
}</pre>
							<p>
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass-&gt;doSomething(Integer::parseInt(id))</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public boolean doGet0Condition(final HttpServletRequest request, final String id) {
    boolean _equals = Objects.equal(id, "42");
    return _equals;
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							For each Route an action call should end in a method where the guice-key (if there is one) and the variables
							should be handle in as parameters. The only special thing here is that the parameter that represents
							the guice-key is named 'it'. That implies that 'it' becomes the implicite reciever and the features of
							the type behind the guice-key are accessable without pointing out that 'it' is the reciever. Wow that's
							so easy...
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		val routes = model.routes
		var routeCounter = 0
		for (route : routes) {
			if (route.url != null) {
   				...
   				addRouteMethod(route, routeCounter)
			}
			routeCounter = routeCounter + 1
   		}
		... //
         ])
}
...
def protected addRouteMethod(JvmDeclaredType servlet, Route route, int routeCounter) {
   		val name = route.nameOfRouteMethod(routeCounter)
		servlet.members += route.toMethod(name, route.newTypeRef(Void::TYPE)) [
			documentation = route.documentation
			if (route.hasValidKey)
				parameters += route.key.toParameter("it", route.key.type)
			parameters += route.toParameter("request", route.newTypeRef(HTTP_REQUEST))
			for (variable : route.url.variables) {
				parameters += variable.toParameter(variable.name, route.newTypeRef(typeof(String)))
			}
			body = route.call
		]
   	}
...
def hasValidKey(Route route){
	route.key != null &amp;&amp; route.key.type != null &amp;&amp; !(route.key.type instanceof JvmVoid)
}</pre>
							<p>
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass-&gt;doSomething(Integer::parseInt(id))</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public void doGet(final HttpServletRequest request, final HttpServletResponse response) {
	String url =  request.getRequestURI();
	Matcher matcher0 = pattern0.matcher(url);
	if(matcher0.find()){
			String id =matcher0.group(1);
			if(doGet0Condition(request, id))
			doGet0(key0,request, id);
    }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							Now we have to put our logic in the global methods of <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a>. First
							of all we have to establish several methods for the corresponding request types. As an example for GET
							the method <code class="prettyprint lang-java">public void doGet(final HttpServletRequest request, final HttpServletResponse response)</code>
							is responsible to handle such requests. So we have two challanges: estalish a method for each request
							type and put the logic in there for the routes that fits for that type.
							Inside of the method we'll have to match the URL from the request to the pattern and extract the values
							for the variables from the URL-pattern. Then we'll have to establish a guard to respect the condition.
							After that we'll finally call the action with the given values of the variables.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...	
			addMethod("doGet", model, routes,RequestType::GET)
			addMethod("doPost", model, routes,RequestType::POST)
			addMethod("doPut", model, routes,RequestType::PUT)
			addMethod("doDelete", model, routes,RequestType::DELETE)
			addMethod("doHead", model, routes,RequestType::HEAD)
			])
}
def protected addMethod(JvmDeclaredType servlet, String name, EObject element, Iterable&lt;Route&gt; routes, RequestType filterType) {
   		servlet.members += element.toMethod(name,element.newTypeRef(Void::TYPE)) [
			parameters += element.toParameter("request", element.newTypeRef(HTTP_REQUEST))
			parameters += element.toParameter("response", element.newTypeRef("javax.servlet.http.HttpServletResponse"))
			body = [
				var x = 0
				if (routes.exists[e | e.requestType == filterType])
					append('String url =  request.getRequestURL().toString();').newLine
				for (route : routes) {
					if (route.requestType == filterType) {
						if (route.url != null) {
							append(element.newTypeRef(typeof(Matcher)).type)
							append(''' _matcher&laquo;x&raquo; = _pattern&laquo;x&raquo;.matcher(url);''')
							newLine
							val variables = route.url.variables
						    append('''if (_matcher&laquo;x&raquo;.find()) {''').newLine
					    	for (variable : variables) {
								append('''		String &laquo;variable.name&raquo; = _matcher&laquo;x&raquo;.group(&laquo;variables.indexOf(variable) + 1&raquo;);''')
								newLine
							}
							if (route.condition != null) {
								append('''		if (&laquo;route.nameOfRouteMethod(x)&raquo;Condition(request''')
				   				append('''&laquo;FOR v : route.url.variables BEFORE ", " SEPARATOR ", "&raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;''')
				   				append('''))''')
				   				newLine
				   			}
							append('''			&laquo;route.nameOfRouteMethod(x)&raquo;(''')
							if(route.hasValidKey)
								append('''_key&laquo;x&raquo;,''')
							append('''request''')
			   				append('''&laquo;FOR v : route.url.variables BEFORE ", " SEPARATOR ", " &raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;''')
			   				append(''');''')
			   				newLine
							append('''}''')
							newLine
						}
					}
					x = x + 1
				}
			]
		]
   	}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="routing_additons" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Additional Aspects</h2>
						<p>
							With the Grammar and the inferrer mentioned in the sections above the DSL is funtional and does excatly
							what we want but there are several things we should customize to have a nice tool-support.
							</p>
							<ul>
								<li>First of all there are several things we do not want to have in the contentassist</li>
								<li>The outline is really ugly when the elements do not have a name</li>
								<li>There is a need for validation in the URL-pattern defintion</li>
							</ul>
							<p>
							
							So lets concentrate on the things in the contentassist. The inferred methods and fields have syntetic names
							and from the context of a condition or an action call we do not want to see the inferred things at all.
							So for that reason we have to customize the code and tweak the <abbr title="org.xtext.httprouting.jvmmodel.RouteJvmModelInferrer">RouteJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting/src/org/xtext/httprouting/jvmmodel/RouteJvmModelInferrer.xtend">(src)</a>. All inferred fields and methods
							that we don't wanna see in the contentassist are prefixed with an underscore. Now we have the possibility
							to filter out proposals with this prefix in <abbr title="org.xtext.httprouting.ui.contentassist.RouteProposalProvider">RouteProposalProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/contentassist/RouteProposalProvider.java">(src)</a>.
							The other thing is that in case of a guice-Key we introduce a parameter with the name 'it'. This means that
							all features of the type behind it are visible without writing it in front of the call. Good thing but
							we do not want 'it' as itself in the contentassist. Let's just filter that one out in <abbr title="org.xtext.httprouting.ui.contentassist.RouteProposalProvider">RouteProposalProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/contentassist/RouteProposalProvider.java">(src)</a>.
						</p>
						<p>
							To tweak the outline for the routes you'll some customized labels in <abbr title="org.xtext.httprouting.ui.labeling.RouteLabelProvider">RouteLabelProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/labeling/RouteLabelProvider.xtend">(src)</a>.
							For some objects we do not wanna see a node in the outline at all so there is a need fo a custom <abbr title="org.xtext.httprouting.ui.outline.RouteOutlineTreeProvider">RouteOutlineTreeProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/outline/RouteOutlineTreeProvider.xtend">(src)</a>.
						</p>
						<p>
							To give the user feedback while the routes are defined we can establish validation. You'll find a validation
							in <abbr title="org.xtext.httprouting.validation.RouteJavaValidator">RouteJavaValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.httprouting/src/org/xtext/httprouting/validation/RouteJavaValidator.xtend">(src)</a> where we raise an error when a placeholder
							is defined after a wildcard in the URL.
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="template" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Template Language
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Some introdcution
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/template_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							Motivation
							Why
						</p>
						<!--  section -->
						<section id="templates_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							Why a DSL
							How about expressions
							DSL example, Java example, Client code example (if appropriate)
						</p>
						<p>
							Approx 2 pages upto here
						</p>
						</section>
						<!--  section -->
						<section id="templates_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							Details on how to run it: Prerequisites, additional plugins...
						</p>
						</section>
						<!--  section -->
						<section id="templates_details" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Implementation</h2>
						</section>
						<!--  section -->
						<section id="templates_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.template.Template with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

generate template 'http://www.itemis.de/xtl/XTL'
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

TemplateFile:
	'&lt;!--''&laquo;' 
		('package' package=QualifiedName)? 
		imports+=Import* 
		params+=Parameter* 
		body=RichString;

Import:
	'import' importedNamespace=QualifiedName;

Parameter:
	annotations+=XAnnotation* 
	'param' type=JvmTypeReference? name=ID ('=' defaultexp=XExpression)?;

RichString returns xbase::XBlockExpression:
	{RichString}  
	expressions+=RichStringLiteral 
	(expressions+=RichStringPart expressions+=RichStringLiteral)*;

RichStringLiteral returns xbase::XStringLiteral:
	{RichStringLiteral} value=TEXT;

RichStringPart returns xbase::XExpression:
	XExpressionInsideBlock |
	RichStringForLoop |
	RichStringIf;

RichStringForLoop returns xbase::XForLoopExpression:
	{RichStringForLoop}
	"FOR" declaredParam=JvmFormalParameter ':' forExpression=XExpression
		eachExpression=RichString
	"ENDFOR";

RichStringIf returns xbase::XIfExpression:
	{RichStringIf}
	"IF" if=XExpression
		then=RichString
	(else=RichStringElseIf | "ELSE" else=RichString)?
	"ENDIF";
	
RichStringElseIf returns xbase::XIfExpression:
	{RichStringIf}
	"ELSEIF"if=XExpression
		then=RichString
	(else=RichStringElseIf | "ELSE" else=RichString)?;

terminal TEXT : '&raquo;' (!'&laquo;')* (EOF|'&laquo;');</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="templates_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						</section>
						<!--  section -->
						<section id="templates_additons" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Additional Aspects</h2>
						<p>
							Addtionally customized things: validation, scoping, code completion ...
						</p>
						</section>
					</div>
				</div>
			</section>
			<!-- chapter -->
			<section id="tortoise" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							Little Tortoise
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							Do you remember the programming language <a href="http://en.wikipedia.org/wiki/Logo_%28programming_language%29">Logo</a>? 
							Logo was used in computer science classes to teach children how to program. In fact, it was a adaptation of LISP!
							But the remarkable part was the so called <strong>turtle</strong>, a graphical cursor that can be given commands to move and turn, 
							thereby drawing lines.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/tortoise_screenshot.png" alt="" width="590" height="441">
							</div>
							<p>
						</p>
						<p>
							The goal is a language to control a turtle drawing an image. Technically, this example will teach you how to adapt 
							and use the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter">XbaseInterpreter</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a> for your own languages.
						</p>
						<!--  section -->
						<section id="tortoise_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Overview</h2>
						<p>
							We have build a language that allows to define <strong>Programs</strong> and <strong>SubPrograms</strong>. Each of these has a body
							which can contain any number of expressions. In addition to the standard Xbase expressions, we are able
							to issue commands to the tortoise. Here is an example explaining the concepts in comments:
							 
							</p>
							<pre class="prettyprint lang-tortoise linenums">
// Program: Haus vom Nikolaus
begin
  val length = 150                // local variable
  val diagonal = length * sqrt(2) // all Math.* methods are available
  lineWidth = 2                   // assignment of a property
  square(length)                  // call to a SubProgram
  turnRight(45)                   // call to a command method
  lineColor = blue                // all ColorConstants.* are available
  forward(diagonal)
  turnLeft(90)
  lineColor = red
  forward(diagonal / 2)
  turnLeft(90)
  forward(diagonal / 2)
  turnLeft(90)
  lineColor = blue
  forward(diagonal)
end  // main program

sub square           // a subprogram
  int length         // parameter
begin
  for (i : 1..4) {   // loop-expression from Xbase 
    forward(length)
    turnRight(90) 
  }
end  // sub square</pre>
							<p>
						</p>
						<p>
							The main trick about our solution is to <strong>not</strong> bake in the turtle commands into the language itself, but
							define it in the runtime library. This way, the language stays as slim as can be and additions can be easily
							added without the need to regenerate the whole language infrastructure.
						</p>
						<p>
							The core of the runtime library is the class <abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a>. You can
							think of it as of our only domainmodel class: It keeps the current state of the tortoise and allows to
							modify it using methods. Here is an excerpt of its code:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class Tortoise {
  double angle
  double x
  double y
  @Property int delay = 200

  boolean isPaint = true
  @Property int lineWidth
  @Property Color lineColor

  List&lt;ITortoiseEvent$Listener&gt; listeners = newArrayList()
...</pre>
							<p>
						</p>
						<p>
							When a method changes the state of the tortoise, an event is thrown. These events are consumed
							by a GEF based view and turned into animations of a <abbr title="org.xtext.tortoiseshell.lib.view.TortoiseFigure">TortoiseFigure</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/view/TortoiseFigure.xtend">(src)</a>. This
							loose coupling of model and view allows for easier testing.
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							In the runtime Eclipse, open the <strong>Tortoise View</strong> <strong>(Window &gt; Show View &gt; Other &gt; Xtext &gt; TortoiseView)</strong>.
							Then open one of the example files in <strong>org.eclipse.xtext.tortoiseshell.examples</strong>. 
							The <strong>Program</strong> is interpreted on editor activation and on save. An additional toggle button <strong>Step Mode</strong> 
							in the <strong>Tortoise View</strong> allows to execute the code live from the editor upto the carret's current line.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/Pythagoras.png" alt="Tortoise takes a rest after running the Pythagoras example" width="651" height="546">
							</div>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Grammar</h2>
						<p>
							The grammar very short. Once again, we inherit from the Xbase language to have nice Java integration
							and rich expressions. A user can define a <strong>Program</strong> which can have <strong>SubPrograms</strong> with parameters. The 
							<strong>Executable</strong> rule is never called, but defines a common supertype for <strong>Program</strong> and <strong>SubProgram</strong> which 
							will hold their common member <code class="prettyprint lang-xtend">body</code>. A <strong>Body</strong> is an <strong>XBlockExpression</strong> from Xbase, but with the 
							keywords <code class="prettyprint lang-xtend">begin</code> and <code class="prettyprint lang-xtend">end</code> instead of the curly braces.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.tortoiseshell.TortoiseShell
  with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/xtext/xbase/Xbase"
generate tortoiseShell "http://www.xtext.org/tortoiseshell/TortoiseShell"

Program :
  body=Body
  subPrograms+=SubProgram*;
  
SubProgram:
  'sub' name=ValidID
  (parameters += FullJvmFormalParameter)*
  body=Body;

Body returns XBlockExpression:
  {XBlockExpression}
  'begin'
  (expressions+=XExpressionInsideBlock ';'?)*
  'end';
  
Executable:
  Program | SubProgram;</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Translation to Java</h2>
						<p>
							With the tortoise commands defined as methods in the runtime library class 
							<abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a>, we have to infer a Java class that inherits from this. 
							Within this class, we create a method for each <strong>Program</strong> and <strong>SubProgram</strong>. The resulting code looks 
							like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class TortoiseShellJvmModelInferrer extends AbstractModelInferrer {
  public static val INFERRED_CLASS_NAME = 'MyTortoiseProgram'
  
  @Inject extension JvmTypesBuilder
  
  def dispatch void infer(Program program, 
                          IJvmDeclaredTypeAcceptor acceptor, 
                          boolean isPreIndexingPhase) {
    acceptor.accept(program.toClass(INFERRED_CLASS_NAME)).initializeLater [
      superTypes += program.newTypeRef(typeof(Tortoise))
      if(program.body != null)
        members += program.toMethod("main", 
            program.newTypeRef(Void::TYPE)) [
          body = program.body
        ]
      for(subProgram: program.subPrograms)
        members += subProgram.toMethod(subProgram.name, 
            program.newTypeRef(Void::TYPE)) [
          for(functionParameter: subProgram.parameters)
            parameters += functionParameter.toParameter(
                functionParameter.name, functionParameter.parameterType)
          body = subProgram.body
        ]
    ]
  }
 }</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_interpreter" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Interpreter</h2>
						<p>
							The Xbase languge library does not only provide a compiler that generates Java code, but also an 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html">interpreter</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a>. This has been adapted to
							to execute our <strong>Programs</strong>.
						</p>
						<p>
							After all an interpreter is just a big visitor. For each expression type, it has an evaluation method,
							that recursively calls the evaluation methods for the subexpressions for its arguments. The methods
							also pass an execution context storing all temporary state such as local variables.
						</p>
						<p>
							The first thing we have to cope with is the mixture of existing Java methods (from the super class
							<abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a>) and inferred ones. While the former are evaluated
							via Java reflection, we need special treatment for the latter. The idea is to bind an instance of 
							<abbr title="org.xtext.tortoiseshell.lib.Tortoise">Tortoise</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell.lib/src/org/xtext/tortoiseshell/lib/Tortoise.xtend">(src)</a> to <code class="prettyprint lang-xtend">this</code> and intercept calls to the inferred 
							methods to execute them directly. This is accomplished by overriding the method
						</p>
						<p>
							<code class="prettyprint lang-xtend">invokeOperation</code>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension IJvmModelAssociations
 
override protected invokeOperation(JvmOperation operation, 
                                   Object receiver, 
                                   List&lt;Object&gt; argumentValues) {
  val executable = operation.sourceElements.head
  if(executable instanceof Executable) {
    val context = createContext
    context.newValue(XbaseScopeProvider::THIS, tortoise)
    var index = 0
    for(param: operation.parameters) {
      context.newValue(QualifiedName::create(param.name), 
                       argumentValues.get(index))
      index = index + 1  
    }
    evaluate((executable as Executable).body, context, 
             CancelIndicator::NullImpl)
  } else {
    super.invokeOperation(operation, receiver, argumentValues)
  }
}</pre>
							<p>
						</p>
						<p>
							One thing you have to know about the Java inferrence is that when creating Java elements using the
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder">JvmTypesBuilder</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">(src)</a>, the infrastructure stores the information which 
							elements have been inferred from which source elements. To navigate these traces, we use the the Xbase service
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations">IJvmModelAssociations</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.java">(src)</a>. So to detect wheter a 
							<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmOperation.html"><abbr title="org.eclipse.xtext.common.types.JvmOperation">JvmOperation</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java">(src)</a> is inferred, we check whether it has a source element.
							If so, we have to setup an exection context binding <code class="prettyprint lang-xtend">this</code> and the parameters as local variables and then 
							execute the method's body using the interpreter.
						</p>
						<p>
							To start the interpretation we have to do almost the same: Setup the execution context and then evaluate
							the <strong>Program's</strong> body. The respective code is
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override run(Tortoise tortoise, EObject program, int stopAtLine) {
  if(tortoise != null &amp;&amp; program != null) {
    this.tortoise = tortoise
    this.stopAtLine = stopAtLine
    try {
      program.jvmElements.filter(typeof(JvmOperation)).head
        ?.invokeOperation(null, Collections::emptyList)
    } catch (StopLineReachedException exc) {
      // ignore
    }
  }
}</pre>
							<p>
						</p>
						<p>
							The <abbr title="org.xtext.tortoiseshell.interpreter.StopLineReachedException">StopLineReachedException</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell/src/org/xtext/tortoiseshell/interpreter/TortoiseShellInterpeter.xtend">(src)</a> is part of the <strong>Step Mode</strong>.
							It is thrown when the execution reaches the line <code class="prettyprint lang-xtend">stopAtLine</code>, thus terminating the current execution.
							The throwing code is
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
override protected internalEvaluate(XExpression expression, 
                                    IEvaluationContext context, 
                                    CancelIndicator indicator) {
  val line = NodeModelUtils::findActualNodeFor(expression)?.startLine
  if(line-1 == stopAtLine)
    throw new StopLineReachedException
  super.internalEvaluate(expression, context, indicator)
}</pre>
							<p>
						</p>
						</section>
						<!--  section -->
						<section id="tortoise_additons" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Literal Classes</h2>
						<p>
							To make the static methods and fields of <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Math.html"><abbr title="java.lang.Math">Math</abbr></a> and <a href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/draw2d/ColorConstants.html"><abbr title="org.eclipse.draw2d.ColorConstants">ColorConstants</abbr></a>
							callable directly, we provided the <abbr title="org.xtext.tortoiseshell.scoping.TortoiseShellExtensionClassNameProvider">TortoiseShellExtensionClassNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell/src/org/xtext/tortoiseshell/scoping/TortoiseShellExtensionClassNameProvider.xtend">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
class TortoiseShellExtensionClassNameProvider extends 
  StaticImplicitMethodsFeatureForTypeProvider$ExtensionClassNameProvider {

  override protected computeLiteralClassNames() {
    super.computeLiteralClassNames =&gt; [
      it += "java.lang.Math"
      it += "org.eclipse.draw2d.ColorConstants" 
    ]  
  }
}</pre>
							<p>
						</p>
						<p>
							To overcome a small issue in the interpreter we also had to implement the 
							<abbr title="org.xtext.tortoiseshell.scoping.TortoiseShellIdentifiableSimpleNameProvider">TortoiseShellIdentifiableSimpleNameProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/languages/org.xtext.tortoiseshell/src/org/xtext/tortoiseshell/scoping/TortoiseShellIdentifiableSimpleNameProvider.xtend">(src)</a>.
						</p>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3>Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">Xtext</a> on Twitter</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
	<script type="text/javascript" src="google-code-prettify/lang-common.js"></script><script type="text/javascript">
		registerLanguage('grammar|import|generate|terminal|enum|returns|with|hidden|as|current|fragment|EOF', 'xtext');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'xbase');
		registerLanguage('module|var|auto-inject|auto|inject|import|true|false', 'mwe2');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|package|import', 'mongobeans');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|sub|begin|end', 'tortoise');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|GET|POST|PUT|DELETE|HEAD|import|when', 'routing');
		registerLanguage('super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'scripting');
		registerLanguage('to-instance|bind|to|mixin|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'guice');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return|package|import|param|task|depends', 'builddsl');
	</script>
</body>
</html>
