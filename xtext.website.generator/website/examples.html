<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtext - Language Development Made Easy!</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages">
	<meta name="author" content="Sven Efftinge">
	<style>
		#header_wrapper {
			padding-top: 10px;
			/* 60px to make the container go all the way to the bottom of the topbar */
		}
		
		code.prettyprint {
	        padding: 0px;
	        background-color: white;
			border: none;
	    }
	</style>
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet">
	<link href="css/bootstrap-responsive.css" rel="stylesheet">
	<link rel="stylesheet" href="css/style.css">
	<link rel="stylesheet" href="css/shield-responsive.css">
	
	<link
		href='http://fonts.googleapis.com/css?family=Vollkorn:400italic,400'
		rel='stylesheet' type='text/css'>
	<link
		href='http://fonts.googleapis.com/css?family=Lato:400,400italic,900italic'
		rel='stylesheet' type='text/css'>
	<script
		src="js/twitter.js"
		type="text/javascript">
	        </script>
	<script type="text/javascript">
	            getTwitters('tweet', { 
	                id: 'xtext', 
	                count: 5,
	                includeRT: true,
	                enableLinks: true, 
	                clearContents: true,
	                template: '"%text%" <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">%time%</a><br/><br/>'
	            });
	        </script>
	
	
	<script src="js/jquery-1.7.1.min.js"></script>
	<link rel="stylesheet" media="screen" href="css/prettyPhoto.css" />
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
	<script type="text/javascript">
	            $(document).ready(function() {
	           
	                $('a[data-rel]').each(function() {
	                    $(this).attr('rel', $(this).data('rel'));
	                });
	                $("a[rel^='prettyPhoto']").prettyPhoto({
	                    animation_speed: 'fast',
	                    slideshow: 5000,
	                    autoplay_slideshow: false,
	                    opacity: 0.80,
	                    show_title: true,
	                    theme: 'ligh_square',
	//                     'pp_default', /* light_rounded / dark_rounded / light_square / dark_square / facebook */
	                    overlay_gallery: false,
	                    social_tools: false
	              
	                });
	            });
	            
	        $(function() {      
	    	$('#outline > li > a').live('click', function() {        
	    		$(this).parent().find('ul').slideToggle();      
	    	});    
	        });
	        </script>
	        
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body onload="prettyPrint()">
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
	
	
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li class="active"><a href="examples.html">Examples</a></li>
						<li ><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
	
				</div>
				<!--/.nav-collapse -->
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
		<!--Container-->
	<div id="header_wrapper" class="container" >
		<div class="inner">
			<div class="container">
				<div class="page-heading"><h1>Documentation</h1></div>
			</div> <!-- /.container -->
		</div> <!-- /inner -->
	</div>
	<div id="page">  
		<div class="inner">
			<div id="maincontainer" class="container">
				<!-- chapter -->
				<section id="introduction" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								Seven Languages by Seven Weaklings
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<p>
								Why?
							</p>
							<p>
								The seven languages are
								<ul>
									<li><a href="#mongo">mongoBeans</a>: JavaBeans-like statically typed access to mongoDB documents</li>
									<li><a href="#routing">HttpRouting</a>: HttpRoutes with full support of expressions</li>
									<li><a href="#templates">Templates</a>:</li>
									<li><a href="#guice">GuiceModules</a>:</li>
									<li><a href="#cradle">Cradle</a>:</li>
									<li><a href="#tortoise">TortoiseShell</a>: A logo like programming environment for educational purposes</li>
									<li><a href="#tba">T.B.A.</a>: A language that is yet to be invented.</li>
								</ul>
							</p>
							<!--  section -->
							<section id="common_requirements" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Common Requirements</h2>
							<p>
								To run any of the examples, you will need <a href="http://www.eclipse.org/download">Eclipse 3.6 or higher</a>
								for your platform. In addition, you have to install <a href="http://www.xtext.org">Xtext 2.3</a> and 
								<a href="http://www.xtend-lang.org">Xtend 2.3</a>. Both of these are also available on the official 
								<a href="">Eclipse Juno Update Site</a> 
							</p>
							<p>
								If you prefer a simple all-inclusive installation, consider downloading the latest
								<a href="http://download.itemis.com/distros">itemis distribution</a>.
							</p>
							<p>
								Additional requirements are mentioned in the <strong>Running the Example</strong> section of each chapter.
							</p>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="mongo" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								MongoBeans
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<p>
								<a href="http://www.mongodb.org">MongoDB</a> is a very popular document-based database management system. 
								In mongoDB, database entries (AKA <strong>documents</strong>) have fields, which are essentially <strong>(key, value)</strong> pairs.
								MongoDB is schema free, i.e. there are no rules which fields have to be defined and of what type they are.
								This allows for very flexible and heterogenous data structures and maps perfectly with JSON. 
							</p>
							<!--  section -->
							<section id="mongo_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								Java is statically typed: The available types, their field names and field types, are known and validated 
								at compile time. The JavaBeans convention defines how instances can be manipulated. 
							</p>
							<p>
								OTOH, the standard mongoDB Java driver reflects mongoDB's schema freeness by providing mongo documents as 
								raw Java maps. This results in some major annoyances: First, you loose the benefit from Java's static typing. 
								You can ask a <a href=""><abbr title="com.mongodb.DBObject">DBObject</abbr></a> <a href="">(src)</a>
								 for the value of a specific field, but you cannot be sure 
								that the returned <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html"><abbr title="java.lang.Object">Object</abbr></a> <a href="">(src)</a>
								 is of some expected type. As database entities are likely to 
								play a major role in your application, having them implemented as a generic <a href=""><abbr title="com.mongodb.DBObject">DBObject</abbr></a> <a href="">(src)</a>
								
								will likely result poorly readable and unsafe code. Second, additional behavior that would usually go into 
								methods of your entity classes has to be defined by external helper classes. Third, constructing a graph of 
								nested generic maps looks pretty bulky and inconventient in Java and breaks with the JavaBeans conventions.
							</p>
							</section>
							<!--  section -->
							<section id="mongo_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								In this project, we have created a small DSL <strong>mongoBeans</strong> based on Xtext that allows to create basic 
								entity classes that are backed by mongoDB objects but provide a statically typed JavaBeans API. Think of 
								the language as a description how to map mongoDB documents to JavaBeans, in analogy to well known object 
								relational mappers.
							</p>
							<p>
								An example mongoBeans file looks like this:
								<pre class="prettyprint lang-mongobeans linenums">
import java.util.*

package org.musicdb {
    // a mongo bean
    Artist {
        String name    // single valued property
        Album* albums  // array property
        // an operation
        Iterable&lt;Track&gt; getOevre() {
            albums.map[track].flatten
        }
    }

    // another mongo bean
    Album {
        String title 
        int year 
        // inline definition of a mongo bean
        Track {        
            String title
            int seconds
        }* tracks
    }
}</pre>
							</p>
							<p>
								From each <strong>MongoBean</strong> definition in a <strong>MongoFile</strong> file, we generate a Java class that wraps a 
								<a href=""><abbr title="com.mongodb.DBObject">DBObject</abbr></a> <a href="">(src)</a>
								. The class provides statically typed getter and setter methods for all 
								defined <strong>MongoProperties</strong>. In the implementation of these accessor methods we delegate to the wrapped
								<a href=""><abbr title="com.mongodb.DBObject">DBObject</abbr></a> <a href="">(src)</a>
								 and do all the casting and conversion work. For the <code class="prettyprint lang-xtend">Artist</code> in the 
								above example, this would look like
							</p>
							<pre class="prettyprint lang-java linenums">
public class Artist implements IMongoBean {

  private DBObject _dbObject;  
  ...
  public String getName() {
    return (String) _dbObject.get("name");
  }
  
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  ...
}</pre>
							<p>
								By generating Java code, the rest of the application can use a safe, statically typed and JavaBeans 
								conformant API to access the datamodel. In addition, <strong>MongoBeans</strong> can define <strong>MongoOperations</strong> 
								which are translated to Java methods. By using the expression library Xbase, we can use 
								<strong>MongoProperties</strong> as well as Java types inside the operations' bodies. 
							</p>
							<p>
								Client code could then look like this:
								<pre class="prettyprint lang-java linenums">
Artist john = new Artist();
john.setName("John Coltrane");
Album album = new Album();
album.setTitle("A Love Supreme");
john.getAlbums().add(album);
Track...  // create some tracks and add them to the album 
System.out.println(john.getName() + "'s Oevre");
for(Track track: john.getOevre()) 
	System.out.println(track.getTitle());
DBCollection dbCollection = ... // standard mongoDB driver code
dbCollection.save(john.getDBObject())</pre>
							</p>
							<!-- subsection -->
							<section id="mongo_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>Language name</td>
								<td>mongoBeans</td>
								</tr>
								<tr><td>Author</td>
								<td>Jan Koehnlein</td>
								</tr>
								<tr><td>Xtext Grammar</td>
								<td>27 LOC, 9 rules</td>
								</tr>
								<tr><td>Xtext extensions</td>
								<td>6 classes</td>
								</tr>
								<tr><td>Execution</td>
								<td>Java code generator</td>
								</tr>
								<tr><td>Runtime library</td>
								<td>4 classes</td>
								</tr>
								<tr><td>Hardest part</td>
								<td>Finding a project name w/o politically incorrect connotation</td>
								</tr>
								</table>
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="mongo_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								In addtion to the <a href="#common_requirements">common requirements</a>, you need the 
								<a href="http://www.mongodb.org/downloads">mongoDB implementation</a> for your platform. We have included 
								the mongoDB Java driver from <a href="http://download.eclipse.org/tools/orbit/downloads/">Eclipse Orbit</a> 
								in the code base. 
							</p>
							<p>
								Import the projects into an Eclipse workspace and run the launch config 
								<strong>Run (org.eclipse.xtext.mongobeans)</strong>. Import the example plug-in into the new workspace and run 
								<code class="prettyprint lang-xtend">MusicDBXtendTest</code> as a JUnit test.
							</p>
							</section>
							<!--  section -->
							<section id="mongo_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="mongo_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							<p>
								The complete mongoBenas grammar looks like this: 
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.mongobeans.MongoBeans with org.eclipse.xtext.xbase.Xbase

generate mongoBeans "http://www.eclipse.org/xtext/mongobeans/MongoBeans"

MongoFile:
  elements+=AbstractElement*;

Import:
  'import' importedNamespace=QualifiedNameWithWildcard;

AbstractElement:
  Import | PackageDeclaration | MongoBean;

PackageDeclaration:
  'package' name=QualifiedName '{'
    elements+=AbstractElement*
  '}';

MongoBean:
  name=ValidID '{'
    features+=AbstractFeature*
  '}';

AbstractFeature:
  MongoOperation | MongoProperty;

MongoProperty:
  (type=JvmTypeReference | inlineType=MongoBean) (many?='*')? name=ValidID;

MongoOperation:
  =&gt;(returnType=JvmTypeReference name=ValidID '(') 
    (parameters+=FullJvmFormalParameter (',' parameters+=FullJvmFormalParameter)*)? 
  ')' 
  body=XBlockExpression;

QualifiedNameWithWildcard:
  QualifiedName (".*")?;</pre>
							<p>
								The grammar inherits from the grammar of <code class="prettyprint lang-xtend">Xbase</code> in order to allow references to Java elements and Xbase 
								expressions. A <strong>MongoFile</strong> contains any number of <strong>AbstractElements</strong>, which can be <strong>PackageDeclarations</strong>,
								<strong>Imports</strong> or <strong>MongoBeans</strong>. <strong>Imports</strong> use Xtext's naming convention <code class="prettyprint lang-xtend">importedNamespace</code> to automatically 
								shorten qualified names of matching elements. Note that as opposed to Java, <strong>PackageDeclarations</strong> can be nested.     
								<strong>MongoBeans</strong> define statically typed MongoProperties, which can be single-valued or array-valued denoted by an 
								<code class="prettyprint lang-xtend">*</code> following the type name. The type of a <strong>MongoProperty</strong> can also be defined inline. <strong>MongoBeans</strong> can 
								also define <strong>MongoOperations</strong>. Instead of defining all possible expressions for the body of an operation, we 
								leverage Xtext's expression language library Xbase. 
							</p>
							</section>
							<!-- subsection -->
							<section id="mongo_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							<p>
								In the end, we want to generate Java code from our mongoBeans files. With Xbase, that means to map our
								DSL concepts to Java concepts. This approach provides very detailed information and allows for better tooling
								than traditional model-to-text code generation. It also enables mixing Java and DSL concepts, e.g. in
								operation bodies.
							</p>
							<p>
								The transformation is implemented in the <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/mongobeans/jvmmodel/MongoBeansJvmModelInferrer.html"><abbr title="org.eclipse.xtext.mongobeans.jvmmodel.MongoBeansJvmModelInferrer">MongoBeansJvmModelInferrer</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/mongobeans/jvmmodel/MongoBeansJvmModelInferrer.java">(src)</a>
								.
								It is written in the programming language <a href="http://www.xtend-lang.org">Xtend</a>, which is Java-like
								but has a far more convenient syntax. As the generated code is quite rich, this is the most complex component
								of mongoBeans.
							</p>
							<p>
								In the following, we describe what happens in the <a href=""><abbr title="org.xtext.mongobeans.jvmmodel.MongoBeansJvmModelInferrer">MongoBeansJvmModelInferrer</abbr></a> <a href="">(src)</a>
								.
								For each <strong>MongoBean</strong>, we create a Java class implementing the interface <a href=""><abbr title="org.xtext.mongobeans.IMongoBean">IMongoBean</abbr></a> <a href="">(src)</a>
								.
								This interface is the first type of our small runtime library. The generated Java classes rely on this
								library to work, so it has to be on the classpath.
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-mongobeans linenums">
package org.musicdb {
  Artist { ...</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
package org.musicdb;
...
public class Artist implements IMongoBean {  ...</pre></td>
								</tr>
								</table>
							</p>
							<p>
								The inferrer code responsible for this section looks like this:
								<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
@Inject extension IQualifiedNameProvider  
...
def dispatch void infer(MongoFile file, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
  for(bean : file.eAllOfType(typeof(MongoBean))) {
       acceptor.accept(bean.toClass(bean.fullyQualifiedName))
         .initializeLater([
           documentation = bean.documentation
           superTypes += newTypeRef(bean, 'org.xtext.mongobeans.IMongoBean')
... // calling various methods to create Java members with from the MongoFeatures
         ])
  }
}</pre>
							</p>
							<p>
								First, finds all elements of type <strong>MongoBean</strong> in the given <strong>MongoFile</strong>. For each of these, create a new 
								Java class using the method <code class="prettyprint lang-xtend">toClass</code>. A speciality of Xtend is that this method comes from another 
								object, in this case of type <code class="prettyprint lang-xtend">JvmTypesBuilder</code>. By having this injected as an 
								<code class="prettyprint lang-xtend">extension</code>, all its methods can be called on the first argument, in this case the <code class="prettyprint lang-xtend">bean</code>. 
								So <code class="prettyprint lang-xtend">bean.toClass(...)</code> is nothing else but <code class="prettyprint lang-xtend">_jvmtypesBuilder.toClass(bean, ...)</code>. Analogously, the 
								method <code class="prettyprint lang-xtend">fullyQualifiedName</code> comes actually from the injected 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/naming/IQualifiedNameProvider.html"><abbr title="org.eclipse.xtext.naming.IQualifiedNameProvider">IQualifiedNameProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java">(src)</a>
								. Please consult the 
								<a href="http://www.xtend-lang.org/documentation">Xtend</a> documentation for more information on extension methods.
							</p>
							<p>
								The so created Java class is passed to the <code class="prettyprint lang-xtend">acceptor</code> as one of the results of the method. In a second
								phase it is filled with members, which is implemented in a lambda expression passed to <code class="prettyprint lang-xtend">initializeLater</code>.
								This lambda spans the content of the square brackets. It has a single implicit parameter <code class="prettyprint lang-xtend">it</code>,
								that is the freshly created Java class from the first phase. As <code class="prettyprint lang-java">this</code> in Java, <code class="prettyprint lang-xtend">it</code>
								must not be specified as the receiver of a feature call. So the following <code class="prettyprint lang-xtend">documentation</code> actually
								refers to <code class="prettyprint lang-xtend">it.documentation</code>. In Xtend, you can use assignments instead of calling setters, so after
								all <code class="prettyprint lang-xtend">documentation = bean.documentation</code> is equivalent to <code class="prettyprint lang-xtend">it.setDocumentation(bean.documentation)</code>
								or even <code class="prettyprint lang-xtend">it.setDocumentation(_jvmTypesBuilder.getDocumention(bean))</code>. Analogously, <pre class="prettyprint lang-xtend linenums">
superTypes +=
...</pre> calls <code class="prettyprint lang-xtend">it.getSuperTypes().add(...)</code>. By using <pre class="prettyprint lang-xtend linenums">
_jvmTypesBuilder.newTypeRef(bean,
String)</pre> we create a reference to the existing interface <a href=""><abbr title="org.xtext.mongobeans.IMongoBean">IMongoBean</abbr></a> <a href="">(src)</a>
								. This
								will also insert a Java import at the appropriate location. 
							</p>
							<p>
								Each <strong>MongoBean</strong> wraps a <a href=""><abbr title="com.mongodb.DBObject">DBObject</abbr></a> <a href="">(src)</a>
								 which is represented as a Java field with a 
								getter. There are two constructors, one for a given <a href=""><abbr title="com.mongodb.DBObject">DBObject</abbr></a> <a href="">(src)</a>
								 and one that 
								creates a new one. We have to store the class name in the DB object, if we want to be able to restore
								JavaBeans from query results.
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-mongobeans linenums">
Artist { ...</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
public class Artist implements IMongoBean { 
  private DBObject _dbObject;
  
  public DBObject getDbObject() {
    return this._dbObject;
  }

  public Artist(final DBObject dbObject) {
    this._dbObject = dbObject;
  }
  
  public Artist() {
    _dbObject = new BasicDBObject();
    _dbObject.put(JAVA_CLASS_KEY, "org.musicdb.Artist");
  }
...</pre></td>
								</tr>
								</table>
							</p>
							<p>
								The inferrer code does this in two separate methods: One for the property <code class="prettyprint lang-xtend">_dbObject</code> and another
								for the constructors. Once again, we are using extension methods from the 
								<code class="prettyprint lang-xtend">JvmTypesBuilder</code> and the shortcut syntax to access setters. Also note the closures to
								initialize the bodies of the constructors. We could just have appended a multi-line string, but in order
								to get the imports in the generated code right we are using the helper method <code class="prettyprint lang-xtend">appendTypeRef()</code>.
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addDbObjectProperty(JvmDeclaredType inferredType, MongoBean bean) {
  inferredType.members += bean.toField('_dbObject', newTypeRef(bean, 'com.mongodb.DBObject'))
  inferredType.members += bean.toGetter('dbObject', '_dbObject', newTypeRef(bean, 'com.mongodb.DBObject'))
}
										
def protected addConstructors(JvmDeclaredType inferredType, MongoBean bean) {
  inferredType.members += bean.toConstructor [
    documentation = '''Creates a new &laquo;bean.name&raquo; wrapping the given {@link DBObject}.'''
    parameters += toParameter("dbObject", newTypeRef(bean, 'com.mongodb.DBObject'))
    body = [
      append('this._dbObject = dbObject;')
    ]
  ]
  inferredType.members += bean.toConstructor [
    documentation = '''Creates a new &laquo;bean.name&raquo; wrapping a new {@link BasicDBObject}.'''
    body = [
      append('_dbObject = new ')
      appendTypeRef(bean, 'com.mongodb.BasicDBObject')
      append('();').newLine
      append('''
        _dbObject.put(JAVA_CLASS_KEY, "&laquo;inferredType.identifier&raquo;");
      ''')
    ]
  ]
}</pre>
							<p>
								Next on our list are the getters and setters delegating to the <code class="prettyprint lang-xtend">_dbObject</code>. Let us start with single
								valued <strong>MongoProperties</strong>:
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-mongobeans linenums">
...
    String name
    Artist friend
...</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
...
  public String getName() {
    return (String) _dbObject.get("name");
  }
  
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  
  public Artist getFriend() {
    return WrappingUtil.wrapAndCast((DBObject) _dbObject.get("friend"));
  }
  
  public void setFriend(final Artist friend) {
     _dbObject.put("friend", WrappingUtil.unwrap(friend));
  }
...</pre></td>
								</tr>
								</table>
							</p>
							<p>
								As a Java client would expect the result of <code class="prettyprint lang-xtend">getFriend()</code> should be a <code class="prettyprint lang-xtend">Artist</code>, we have to handle
								<strong>MongoProperties</strong> whose type is a <strong>MongoBean</strong> differently. Note that the generated Java code uses 
								static helper methods to do the wrapping / unwrapping. They are defined in the second runtime class 
								<a href=""><abbr title="org.xtext.mongobeans.WrappingUtil">WrappingUtil</abbr></a> <a href="">(src)</a>
								. To detect whether a type is actually a <strong>MongoBean</strong> or not, we 
								use the helper class <a href=""><abbr title="org.xtext.mongobeans.jvmmodel.MongoTypes">MongoTypes</abbr></a> <a href="">(src)</a>
								 that is also injected as an extension.
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addDelegateAccessors(JvmDeclaredType inferredType, MongoProperty property) {
    inferredType.members += property.toMethod('get' + property.name.toFirstUpper, property.jvmType) [
      documentation = property.documentation
      body = [
        append('return ')
        if(property.jvmType.mongoBean) {
          ...
        } else {
          ...
        } 
      ]
    ]
    inferredType.members += property.toMethod('set' + property.name.toFirstUpper, null) [
      documentation = property.documentation
      parameters += toParameter(property.name, property.jvmType)
      body = [
        append(''' _dbObject.put("&laquo;property.name&raquo;", ''')
        if(property.jvmType.mongoBean) {
          ...
        } else {
          ...
        }
        append(');')
      ]
    ]
  }</pre>
							<p>
								Multi-valued <strong>MongoProperties</strong> with a <strong>MongoBean</strong> type require a special implementation of 
								<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><abbr title="java.util.List">List</abbr></a> <a href="">(src)</a>
								 to automatically wrap/unwrap the elements. That's the third runtime library 
								class <a href=""><abbr title="org.xtext.mongobeans.MongoBeanList">MongoBeanList</abbr></a> <a href="">(src)</a>
								. Note that we need a getter only. For multi-valued
								primitive properties, the Java driver already delivers a <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html"><abbr title="java.util.List">List</abbr></a> <a href="">(src)</a>
								:
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-mongobeans linenums">
...
  String* aliases
    Album* albums
...</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
...
  public List&lt;String&gt; getAliases() {
    return (List&lt;String&gt;) _dbObject.get("aliases");
  }
  
  private MongoBeanList&lt;Album&gt; _albums;
  
  public List&lt;Album&gt; getAlbums() {
    if(_albums==null)
      _albums = new MongoBeanList&lt;Album&gt;(_dbObject, "albums");
    return _albums;
  }
...</pre></td>
								</tr>
								</table>
							</p>
							<p>
								So this is what the inferrer snippet looks like:
								<pre class="prettyprint lang-xtend linenums">
def protected addListAccessor(JvmDeclaredType inferredType, MongoProperty property) {
  if(isMongoPrimitiveType(property.jvmType)) {
    inferredType.members += property.toMethod('get' + property.name.toFirstUpper, 
      newTypeRef(property, 'java.util.List', property.jvmType.asWrapperTypeIfPrimitive)
    ) [
      documentation = property.documentation
      body = [
											...
      ]
    ]    
  } else {
    inferredType.members += property.toField('_' + property.name, newTypeRef(property,
       'org.xtext.mongobeans.MongoBeanList', property.jvmType))
    inferredType.members += property.toMethod('get' + property.name.toFirstUpper,
      newTypeRef(property, 'java.util.List', property.jvmType)
    ) [
											 ...
      ]
    ]
  }
}</pre>
							</p>
							<p>
								Last but not least, we want to create methods for <strong>MongoOperations</strong>. 
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-mongobeans linenums">
...
  Iterable&lt;Track&gt; getOevre() {
      albums.map[tracks].flatten
  }
...</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
...
  public Iterable&lt;Track&gt; getOevre() {
    // some java code you really don't care about but it should just do the right thing
  }
...</pre></td>
								</tr>
								</table>
							</p>
							<p>
								The inferrer code is surprisingly simple, as we can directly associate the body of the <strong>MongoOperation</strong> 
								to the generated Java method. The Xbase compiler will automatically transform that to Java. 
							</p>
							<pre class="prettyprint lang-xtend linenums">
def protected addMethod(JvmDeclaredType inferredType, MongoOperation operation) {
    inferredType.members += operation.toMethod(operation.name, operation.returnType) [
      documentation = operation.documentation
      for(parameter: operation.parameters)
        parameters += parameter.toParameter(parameter.name, parameter.parameterType)
      body = operation.body
    ]
  }</pre>
							<p>
								Puh, that was a lot of code, but because it is the essence of this language we hope it has been worthwhile.
							</p>
							</section>
							<!-- subsection -->
							<section id="mongo_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								We have tweaked the language's infrastructure a bit more. First, we have adapted the 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/naming/IQualifiedNameProvider.html"><abbr title="org.eclipse.xtext.naming.IQualifiedNameProvider">IQualifiedNameProvider</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java">(src)</a>
								. By default, the
								qualified name of an element is calculated by concatening all the simple names of its containers with
								a dot. In our example, the <strong>MongoBean</strong> <code class="prettyprint lang-xtend">Track</code> would consequently be named 
								<code class="prettyprint lang-xtend">org.musicdb.Album.track.Track</code>. To ignore properties and beans on the path, we implemented our own
								<a href=""><abbr title="org.xtext.mongobeans.scoping.MongoQualifiedNameProvider">MongoQualifiedNameProvider</abbr></a> <a href="">(src)</a>
								. Note that we have to add a binding
								in the respective <a href="">Guice module</a> <a href="">(src)</a>
								 to make the framework 
								pick up our customization. See the <a href="http://www.xtext.org/documentation">Xtext documentation</a> for details 
								on dependency injection.
							</p>
							<p>
								Second, the Java driver for mongoDB cannot map all Java types to mongoDB types. To enforce that constraint, 
								we have added the <a href=""><abbr title="org.xtext.mongobeans.validation.MongoBeansValidator">MongoBeansValidator</abbr></a> <a href="">(src)</a>
								. 
							</p>
							<p>
								To improve the language visually, we have tuned the 
								<a href="">outline</a> <a href="">(src)</a>
								 and the 
								<a href="">label providers</a> <a href="">(src)</a>
								 as well. 
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="mongo_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							<p>
								Of course there could be further concepts in the DSL, e.g. transient properties, indices or refeerences. 
								Furthermore, the <a href="">example</a> <a href="">(src)</a>
								 shows how to use Xtend to 
								build a very compact API to create trees of <strong>MongoBean</strong> instances. 
								<a href="">Extension methods</a> <a href="">(src)</a>
								 can also be used to wrap other
								classes of the mongoDB driver.   
							</p>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="routing" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								Http Routing
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<!--  section -->
							<section id="routing_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								There are several different frameworks out there like <a href="https://github.com/playframework/Play20/wiki/ScalaRouting">Play</a>
								to support HttpRoutes.
								Normally they are defined in a special format in a separated central file. In most of the cases there is no tooling except a normal text/XML editor. 
								The only way to decide which route matches is the URL with different wildcards and placeholders. 
								The order of the routes defined in the file is important to decide which matches first. There is no support to access parts of the URL while the mapping is done.
								In most of the cases you might want to have full control via expressions to decide which action should be called. 
								Normally concrete classes are used directly in the route definition to point to an action that should be triggered. That's not really reusable in different scenarios and dependency injection is what you would really like to use.
							</p>
							</section>
							<!--  section -->
							<section id="routing_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								In this project, we have created a small DSL base on <a href="http://www.xtext.org">Xtext</a> that allows to create routing with full support of expressions and access to the URL while the routing is done.
								The result is a javax.servlet.http.HttpServlet that has methods for the different routes with optional conditions and <a href="http://code.google.com/p/google-guice">Guice</a> bindings. Depending on the order in the file, the pattern and the conditions the respective method is called. 
								Eventually, we do only have a single <code class="prettyprint lang-xtend">javax.servlet.http.HttpServlet</code> containing the logic for routing implemented in Java. 
								To define routes you'll have to create a file with the extension '.route'. The first part of a route defines the type (GET, POST, PUT, DELETE or HEAD) of the route and the pattern.
								<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* ...</code>
								<ul>
									<li><code class="prettyprint lang-xtend">:id</code> means a placeholder for a word</li>
									<li><code class="prettyprint lang-xtend">:rest*</code> means match everything to the rest of the url</li>
								</ul>
								
								Then you have the possibility to define a condition like:
								<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ...</code>
								Here you have access to id and rest statically typed to String. The servlet will provide the value of the placeholder or wildcard when the mapping takes place. 
								An optional annotated Guice-key could be used after the condition or pattern to get an instance of that type/interface and trigger an operation. 
								<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass-&gt;doSomething(Integer::parseInt(id))</code>
								You'll see that there is access to all features of the bound type/interface with access to the placeholders or wildcard values from the URL.
								If you want to call static methods there is no need for a Guice-key. 
								<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass::doSomethingStatic(id)</code>
								In both cases you have the possibility to feed the methods with an expression.
							</p>
							<p>
								To map that to Java we have to clarify what concepts we have and where we should hook in.
								First of all a <code class="prettyprint lang-xtend">javax.servlet.http.HttpServlet</code> has exactly one method for each request type (GET,
								POST, ...). Within these methods we'll have to call our routing logic. A route describes a pattern, a condition, a guice-key and a call of an action. So a pattern should be translated to a field as regular expression. This helps to match the URL and extract the values out of
								the given URL from the request. A condition should be a method with a boolean returntype where the request and the values of the variables from the URL-pattern are handled in as parameters. 
								The guice-key should be a field annotated with whatever is specified by
								the user and @Inject to tell Guice to inject an implementation here. 
								There is one more need for a method to wrap the action call with same parameters as the condition.
								Now we have everything to fill in our logic inside of the global method of the HttpServlet. First of
								all we have to match the URL, extract the values for the variables and establish local variables for
								that. If there is a condition we have to establish a guard for the action call. Only when the pattern
								matches the URL and the condition is true the call should be triggered. Otherwise a following route should
								be evaluated in the same way.
							</p>
							<!-- subsection -->
							<section id="routing_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>Language name</td>
								<td>HttpRouting</td>
								</tr>
								<tr><td>Xtext Grammar</td>
								<td>39 LOC, 8 rules, 1 Enum</td>
								</tr>
								<tr><td>Xtext extensions</td>
								<td>6 classes</td>
								</tr>
								<tr><td>Execution</td>
								<td>Java code generator</td>
								</tr>
								<tr><td>Hardest Part</td>
								<td>Handle regular expressions :-)</td>
								</tr>
								</table>
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="routing_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								You'll need Eclipse 3.5 or higher, Xtext 2.3 and Xtend 2.3. The Servlet-API on the class path of your project.
								Import the projects into an Eclipse workspace and run the launch config
								<strong>Run (org.eclipse.xtext.httprouting)</strong>. Now you may start with a new JavaProject or just import the project
								org.eclipse.httprouting.example. You'll see that the Servlet-API ist already included in the example.
							</p>
							</section>
							<!--  section -->
							<section id="routing_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="routing_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							<p>
								The Routing DSL extends org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations to make use of expressions
								predefined by <a href="http://www.eclipse.org/Xtext/#xbase">Xbase</a> plus support for Annotations.
								<code class="prettyprint lang-xtext">grammar org.xtext.httprouting.Route with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations</code>
								<pre class="prettyprint lang-xtext linenums">
Import:
	'import' importedType=[types::JvmType|QualifiedName];</pre>
								The Route DSL defines imports by using crossreferences. This makes it possible to use contentassist here
								and it is clear that the imported type exist.
								<pre class="prettyprint lang-xtext linenums">
Route:
	type=Type url=URL condition=Condition? (key=Key call=RouteFeatureCall | call=XFeatureCall);
	
URL:
	{URL} "/" (ID ("." ID)? | variables+=Variable) ("/" (ID ("." ID)? | variables+=Variable))*;
	
Variable:
	":" name=ID (wildcard?="*")?;
	
Condition:
	"when" expression=XExpression;
	
Key:
	annotations+=XAnnotation? type=JvmTypeReference;</pre>
								A Route has a type followed by an URL-pattern that can define variables. A variable could be a placeholder
								':id' or a wildcard ':name*'. After the URL-pattern matches an optional condition can point out if the
								route matches. Here you'll have the full support Xbase offers with access to the defined variables. 
							</p>
							<p>
								One special thing here is that we can point to an action-implementation in different ways. 
								One is to define a guice-key with an optinal annotation to specialize a
								binding and access an available feature of the type directly after that. The other is to have a static
								method call on a type. The difference between RouteFeatureCall and XFeatureCall is that RouteFeatureCall
								does not allow a static method call.If you would like to see the difference on a grammar level please
								compare XFeatureCall and RouteFeatureCall with each other.
							</p>
							</section>
							<!-- subsection -->
							<section id="routing_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							<p>
								For each <strong>RouteFile</strong>, we create a Java class extending the class <a href=""><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a> <a href="">(src)</a>
								.
								The generated Java classes rely on the Servelet-API to work, so it has to be on the classpath.
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><code class="prettyprint lang-routing"></code></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
package org.xtext.httpRouting;
...
public class HttpMapperServlet extends HttpServlet {
  private final static long serialVersionUID = 1L; ...</pre></td>
								</tr>
								</table>
							</p>
							<p>
								The inferrer code responsible for this section looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
				superTypes+= model.newTypeRef("javax.servlet.http.HttpServlet")
				//private static final long serialVersionUID = 1L;
				members+= model.toField("serialVersionUID", model.newTypeRef("long"))[
					setStatic(true)
					final = true
					setInitializer([
						append('''1L''')
					])
				]
... // calling various methods to create Java members with from the Routes
         ])
}</pre>
							<p>
								For each Route a URL-pattern should end in a compiled regular expression pattern stored in a field.
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><code class="prettyprint lang-routing">GET /client/foo/:id</code></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
private static Pattern pattern0 = Pattern.compile("/client/foo/(\\w+)");</pre></td>
								</tr>
								</table>
							</p>
							<p>
								The inferrer code responsible for this section looks like this:
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		var i = 0
		val routes = model.routes
		for(route : routes){
			if(route.url != null){
				...
				// Field for pattern
				val patternField = route.url.toField("_pattern" + i , model.newTypeRef(typeof(Pattern)))[
					setStatic(true)
					setInitializer([append('''Pattern.compile("&laquo;getRegExPattern(NodeModelUtils::getNode(route.url).text.trim,route.url.variables)&raquo;")''')])
				]
				members+= patternField
			}
			i = i + 1;
		}
		... //
         ])
}
...
def getRegExPattern(String originalPattern, List&lt;Variable&gt; variables) {
	var pattern = originalPattern
	for(variable : variables){
		if(variable.wildcard)
			pattern = pattern.replaceAll("(:" + variable.name + "\\*)", "(.+)")
		else
			pattern = originalPattern.replaceAll("(:" + variable.name + ")", "(\\\\\\\\w+)")
	}
	pattern
}
...</pre>
							<p>
								As we know the name of each variable we can replace the variable from the URL with a regualr expression
								with the same meaning to match the URL that has be routed. As we do not have a element in our model where
								the complete URL-pattern is stored we have to use the NodeModel to get the text behind the URL-pattern.
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><code class="prettyprint lang-routing">GET /client/foo/:id when id=='42'</code></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
public boolean doGet0Condition(final HttpServletRequest request, final String id) {
   boolean _equals = Objects.equal(id, "42");
   return _equals;
 }</pre></td>
								</tr>
								</table>
							</p>
							<p>
								For each Route a condition should end in a method with a boolean return type. Each variable value should
								be handled in as a parameter. Same is true for the <a href=""><abbr title="javax.servlet.http.HttpServletRequest">HttpServletRequest</abbr></a> <a href="">(src)</a>
								.
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...

def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		var i = 0
		val routes = model.routes
		for(route : routes){
			if(route.url != null){
				...
				val name = route.nameOfRouteMethod(i)
				...
				// Method for condition
				if(route.condition != null && route.condition.expression != null){
					members+= route.toMethod(name + "Condition",model.newTypeRef(Boolean::TYPE))[
						parameters += model.toParameter("request",model.newTypeRef(REQUEST))
						for(variable : route.url.variables){
							parameters += variable.toParameter(variable.name, model.newTypeRef(typeof(String)))
						}
						body = route.condition.expression
					]
				}
				...
			}
			i = i + 1;
		}
		... //
         ])
}

def nameOfRouteMethod(Route route, int i) {
		"_do" + route.type.literal.toLowerCase.toFirstUpper + i
	}</pre>
							<p>
								The expression defined in the condition ends up in the body of the new create method. That implies that
								all things sourrounding the method (fields, methods and parameters) are accessable within the expression.
								Isn't that cool. ;-)
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
@Inject
@Named(value = "ActionClassName")
private ActionClass key0;</pre></td>
								</tr>
								</table>
							</p>
							<p>
								For each Route a guice-key should end in a field with the defined annotations on it plus @Inject. As a guice-key is optional we have to make sure that route has a key. Now we create a field and add the
								annotations to it.
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		var i = 0
		val routes = model.routes
		for(route : routes){
			if(route.url != null){
				...
				// Field for guice-key
				if(route.hasValidKey){
					val keyField = route.key.toField("_key" + i, route.key.type)
					keyField.addInjectAnnotation(model)
					route.key.annotations.translateAnnotationsTo(keyField)
					members+= keyField
				}
				...
			}
			i = i + 1;
		}
		...
         ])
}
...
def hasValidKey(Route route){
	route.key != null && route.key.type != null && !(route.key.type instanceof JvmVoid)
}

def addInjectAnnotation(JvmAnnotationTarget target, EObject context){
	val injectAnnotation = context.newTypeRef(typeof(Inject))
	if(injectAnnotation != null && !(injectAnnotation.type instanceof JvmVoid)){
		val inject = typesFactory.createJvmAnnotationReference();
		inject.setAnnotation(injectAnnotation.type as JvmAnnotationType)
		target.annotations += inject
	}
}</pre>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass-&gt;doSomething(Integer::parseInt(id))</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
public boolean doGet0Condition(final HttpServletRequest request, final String id) {
    boolean _equals = Objects.equal(id, "42");
    return _equals;
}</pre></td>
								</tr>
								</table>
							</p>
							<p>
								For each Route an action call should end in a method where the guice-key (if there is one) and the variables
								should be handle in as parameters. The only special thing here is that the parameter that represents
								the guice-key is named 'it'. That implies that 'it' becomes the implicite reciever and the features of
								the type behind the guice-key are accessable without pointing out that 'it' is the reciever. Wow that's
								so easy...
								<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		var i = 0
		val routes = model.routes
		for(route : routes){
			if(route.url != null){
				// Method for action call
				val name = route.nameOfRouteMethod(i)
				members += route.toMethod(name, model.newTypeRef(Void::TYPE))[
				documentation = route.documentation
					if(route.hasValidKey)
						parameters+=route.key.toParameter("it", route.key.type)
					parameters += model.toParameter("request",model.newTypeRef(REQUEST))
					for(variable : route.url.variables){
							parameters += variable.toParameter(variable.name, model.newTypeRef(typeof(String)))
					}
					body = route.call
				]
				...
			}
			i = i + 1;
		}
		... //
         ])
  }
...
def hasValidKey(Route route){
	route.key != null && route.key.type != null && !(route.key.type instanceof JvmVoid)
}</pre>
							</p>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>DSL</td>
								<td><pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass-&gt;doSomething(Integer::parseInt(id))</pre></td>
								</tr>
								<tr><td>Java</td>
								<td><pre class="prettyprint lang-java linenums">
public void doGet(final HttpServletRequest request, final HttpServletResponse response) {
	String url =  request.getRequestURI();
	Matcher matcher0 = pattern0.matcher(url);
	if(matcher0.find()){
			String id =matcher0.group(1);
			if(doGet0Condition(request, id))
			doGet0(key0,request, id);
    }
}</pre></td>
								</tr>
								</table>
							</p>
							<p>
								Now we have to put our logic in the global methods of <a href=""><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a> <a href="">(src)</a>
								. First
								of all we have to establish several methods for the corresponding request types. As an example for GET
								the method <code class="prettyprint lang-java">public void doGet(final HttpServletRequest request, final HttpServletResponse response)</code>
								is responsible to handle such requests. So we have two challanges: estalish a method for each request
								type and put the logic in there for the routes that fits for that type.
								Inside of the method we'll have to match the URL from the request to the pattern and extract the values
								for the variables from the URL-pattern. Then we'll have to establish a guard to respect the condition.
								After that we'll finally call the action with the given values of the variables.
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
				members+= createMethod("doGet", model, routes,Type::GET)
				members+= createMethod("doPost", model, routes,Type::POST)
				members+= createMethod("doPut", model, routes,Type::PUT)
				members+= createMethod("doDelete", model, routes,Type::DELETE)
				members+= createMethod("doHead", model, routes,Type::HEAD)
			])
}
	def createMethod(String name, EObject element, Iterable&lt;Route&gt; routes, Type filterType){
		element.toMethod(name,element.newTypeRef(Void::TYPE))[
			parameters += element.toParameter("request",element.newTypeRef(REQUEST))
			parameters += element.toParameter("response",element.newTypeRef("javax.servlet.http.HttpServletResponse"))
			body = [
				var x = 0
				if(routes.exists(e | e.type== filterType))
					append('''String url =  request.getRequestURI();
					''')
				for(route : routes){
					if(route.type == filterType)
						if(route.url != null){
							append(element.newTypeRef(typeof(Matcher)).type).append(''' _matcher&laquo;x&raquo; = _pattern&laquo;x&raquo;.matcher(url);
							''')
							val variables = route.url.variables
							    append('''if(_matcher&laquo;x&raquo;.find()){
								''')
							for( variable : variables){
									append('''		String &laquo;variable.name&raquo; = _matcher&laquo;x&raquo;.group(&laquo;variables.indexOf(variable) + 1&raquo;);
									''')
								}
								if(route.condition != null){
									append('''		if(&laquo;route.nameOfRouteMethod(x)&raquo;Condition(request''')
									append('''&laquo;FOR v : route.url.variables BEFORE ", " SEPARATOR ", "&raquo;&laquo;v.name&raquo;&laquo;ENDFOR &raquo;''')
									append('''))
									''');
								}
								append('''			&laquo;route.nameOfRouteMethod(x)&raquo;(''')
								if(route.hasValidKey)
									append('''_key&laquo;x&raquo;,''')
								append('''request''')
								append('''&laquo;FOR v : route.url.variables BEFORE ", " SEPARATOR ", " &raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;''')
								append(''');
								''')
								append('''}''');
						}
						x = x + 1
				}

			]
		]
	}</pre>
							</section>
							<!-- subsection -->
							<section id="routing_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								With the Grammar and the inferrer mentioned in the sections above the DSL is funtional and does excatly
								what we want but there are several things we should customize to have a nice tool-support.
								<ul>
									<li>First of all there are several things we do not want to have in the contentassist</li>
									<li>The outline is really ugly when the elements do not have a name</li>
									<li>There is a need for validation in the URL-pattern defintion</li>
								</ul>
								
								So lets concentrate on the things in the contentassist. The inferred methods and fields have syntetic names
								and from the context of a condition or an action call we do not want to see the inferred things at all.
								So for that reason we have to customize the code and tweak the <a href=""><abbr title="org.xtext.httprouting.jvmmodel.RouteJvmModelInferrer">RouteJvmModelInferrer</abbr></a> <a href="">(src)</a>
								. All inferred fields and methods
								that we don't wanna see in the contentassist are prefixed with an underscore. Now we have the possibility
								to filter out proposals with this prefix in <a href=""><abbr title="org.xtext.httprouting.ui.contentassist.RouteProposalProvider">RouteProposalProvider</abbr></a> <a href="">(src)</a>
								.
								The other thing is that in case of a guice-Key we introduce a parameter with the name 'it'. This means that
								all features of the type behind it are visible without writing it in front of the call. Good thing but
								we do not want 'it' as itself in the contentassist. Let's just filter that one out in <a href=""><abbr title="org.xtext.httprouting.ui.contentassist.RouteProposalProvider">RouteProposalProvider</abbr></a> <a href="">(src)</a>
								.
							</p>
							<p>
								To tweak the outline for the routes you'll some customized labels in <a href=""><abbr title="org.xtext.httprouting.ui.labeling.RouteLabelProvider">RouteLabelProvider</abbr></a> <a href="">(src)</a>
								.
								For some objects we do not wanna see a node in the outline at all so there is a need fo a custom <a href=""><abbr title="org.xtext.httprouting.ui.outline.RouteOutlineTreeProvider">RouteOutlineTreeProvider</abbr></a> <a href="">(src)</a>
								.
							</p>
							<p>
								To give the user feedback while the routes are defined we can establish validation. You'll find a validation
								in <a href=""><abbr title="org.xtext.httprouting.validation.RouteJavaValidator">RouteJavaValidator</abbr></a> <a href="">(src)</a>
								 where we raise an error when a placeholder
								is defined after a wildcard in the URL.
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="routing_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							<p>
								Of course the DSL is not complete and there are several types of URL-pattern variables missing but it
								should not be a hard thing to extend this example. To enable DI in the context of a <a href=""><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a> <a href="">(src)</a>
								
								there has to be a wrapper or something like that to create an injector. One really cool thing would be
								to establish and <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XExpression.html"><abbr title="org.eclipse.xtext.xbase.XExpression">XExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/XExpression.java">(src)</a>
								 that handles the complete guice-key and action call stuff with a corresponding
								compiler but this is fare beyond the scope of this example. ;-)
							</p>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="templates" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								Templates
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<!--  section -->
							<section id="templates_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								Motivation
								Why
							</p>
							</section>
							<!--  section -->
							<section id="templates_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								Why a DSL
								How about expressions
								DSL example, Java example, Client code example (if appropriate)
							</p>
							<p>
								Approx 2 pages upto here
							</p>
							<!-- subsection -->
							<section id="templates_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								files touched, LOC, animals harmed, etc 
								can also be funny
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="templates_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								Details on how to run it: Prerequisites, additional plugins... 
							</p>
							</section>
							<!--  section -->
							<section id="templates_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="templates_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							</section>
							<!-- subsection -->
							<section id="templates_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							</section>
							<!-- subsection -->
							<section id="templates_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								Addtionally customized things: validation, scoping, code completion ...
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="templates_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="guice" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								Guice Modules
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<!--  section -->
							<section id="guice_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								Motivation
								Why
							</p>
							</section>
							<!--  section -->
							<section id="guice_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								Why a DSL
								How about expressions
								DSL example, Java example, Client code example (if appropriate)
							</p>
							<p>
								Approx 2 pages upto here
							</p>
							<!-- subsection -->
							<section id="guice_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								files touched, LOC, animals harmed, etc 
								can also be funny
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="guice_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								Details on how to run it: Prerequisites, additional plugins... 
							</p>
							</section>
							<!--  section -->
							<section id="guice_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="guice_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							</section>
							<!-- subsection -->
							<section id="guice_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							</section>
							<!-- subsection -->
							<section id="guice_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								Addtionally customized things: validation, scoping, code completion ...
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="guice_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="cradle" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								Cradle
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<!--  section -->
							<section id="cradle_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								Motivation
								Why
							</p>
							</section>
							<!--  section -->
							<section id="cradle_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								Why a DSL
								How about expressions
								DSL example, Java example, Client code example (if appropriate)
							</p>
							<p>
								Approx 2 pages upto here
							</p>
							<!-- subsection -->
							<section id="cradle_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								files touched, LOC, animals harmed, etc 
								can also be funny
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="cradle_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								Details on how to run it: Prerequisites, additional plugins... 
							</p>
							</section>
							<!--  section -->
							<section id="cradle_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="cradle_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							</section>
							<!-- subsection -->
							<section id="cradle_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							</section>
							<!-- subsection -->
							<section id="cradle_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								Addtionally customized things: validation, scoping, code completion ...
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="cradle_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="tortoise" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								Tortoise Shell
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<p>
								Do you remember the programming language <a href="http://en.wikipedia.org/wiki/Logo_%28programming_language%29">Logo</a>? 
								Logo was used in computer science classes to teach children how to program. In fact, it was a adaptation of LISP!
								But the remarkable part was the so called <strong>turtle</strong>, a graphical cursor that can be given commands to move and turn, 
								thereby drawing lines.
							</p>
							<!--  section -->
							<section id="tortoise_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								The goal is to provide a runtime environment for a langauge that allows to command a turtle to draw an image.
								I admit that there is no real world problem to be solved, apart from the fact that I cannot find my good old logo 
								interpreter. But technically, this example will teach you how to use and adapt the 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter">XbaseInterpreter</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a>
								 for your own language.  
							</p>
							</section>
							<!--  section -->
							<section id="tortoise_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								We have build a language that allows to define <strong>Programs</strong> and <strong>SubPrograms</strong>. Each of these has a body
								which can contain any number of expressions. In addition to the standard Xbase expressions, we are able
								to issue commands to the turtle. Here is an example explaining the concepts in comments:
								 
								<table class="table table-bordered table-condensed">
								<tr><td><pre class="prettyprint lang-tortoise linenums">
// Program: Haus vom Nikolaus
begin
  // local variable
  val length = 100   
  // all Math.* methods are available
  val diagonal = length * sqrt(2)
  // assignment of a property
  lineWidth = 2 
  // call to a SubProgram
  square(length)
  // call to a command method
  turnRight(135)
  // all ColorConstants.* are available
  lineColor = blue 
  forward(diagonal)
  turnLeft(90)
  lineColor = red
  forward(diagonal / 2)
  turnLeft(90)
  forward(diagonal / 2)
  turnLeft(90)
  lineColor = blue
  forward(diagonal)
end

// subprogram with parameter
sub square
  int length
begin
  forward(length)
  turnRight(90) 
  forward(length)
  turnRight(90)
  forward(length)
  turnRight(90)
  forward(length)
end</pre></td>
								<td><div class="thumbnail">
									<img src="images/Nikolaus.png" alt="">
								</div></td>
								</tr>
								</table>
							</p>
							<p>
								The main trick about our solution is not to build in the turtle commands into the language itself, but
								define it in the runtime library. This way, the language stays as slim as can be and additions can be easily
								added without the need to regenerate the whole language infrastructure.
							</p>
							<p>
								The core of the runtime library is the class <a href=""><abbr title="org.xtext.tortoiseshell.runtime.Tortoise">Tortoise</abbr></a> <a href="">(src)</a>
								. You can
								think of it as of our only domainmodel class: It keeps the current state of the tortoise and allows to
								modify it using methods. Here is an excerpt of its code:
							</p>
							<pre class="prettyprint lang-xtend linenums">
class Tortoise {
  double angle
  double x
  double y
  @Property int delay = 200

  boolean isPaint = true
  @Property int lineWidth
  @Property Color lineColor

  List&lt;ITortoiseEvent$Listener&gt; listeners = newArrayList()
...</pre>
							<p>
								We could have used EMF to model the tortoise, but that would have been kind of of overkill for a single
								EClass. When a method that changes the state is called, an event is thrown. These events are consumed
								by a GEF based view and turned into animations of a <a href=""><abbr title="org.xtext.tortoiseshell.runtime.view.TortoiseFigure">TortoiseFigure</abbr></a> <a href="">(src)</a>
								.  
							</p>
							<!-- subsection -->
							<section id="tortoise_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								<table class="table table-bordered table-condensed">
								<tr><td>Language name</td>
								<td>TortoiseShell</td>
								</tr>
								<tr><td>Author</td>
								<td>Jan Koehnlein</td>
								</tr>
								<tr><td>Xtext Grammar</td>
								<td>ridiculously tiny (17 LOC, 3 parser rules (+1 for a nicer Ecore model))</td>
								</tr>
								<tr><td>Xtext extensions</td>
								<td>4 classes</td>
								</tr>
								<tr><td>Execution</td>
								<td>interpreter</td>
								</tr>
								<tr><td>Runtime library</td>
								<td>huge, a lot of fun!</td>
								</tr>
								<tr><td>Hardest part</td>
								<td>Teaching GEF to center a figure</td>
								</tr>
								<tr><td>Animals harmed</td>
								<td>0 (except virtual turtles)</td>
								</tr>
								</table>
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="tortoise_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								You should have installed the <a href="http://www.eclipse.org/gef">Graphical Editing Framework (GEF)</a>. Import the projects 
								into an Eclipse workspace and run the launch config <strong>Run (org.eclipse.xtext.tortoiseshell)</strong>. Import the example plug-in 
								into the new workspace and open one of the example files. Also open the <strong>Tortoise View</strong> <strong>(Window &gt;
								Show View &gt; Other &gt; Xtext &gt; TortoiseView)</strong>. The <strong>Program</strong> is interpreted on save. An additional toggle button <strong>Step Mode</strong> 
								in the <strong>Tortoise View</strong> allows to execute the code live from the editor upto the carret's current line.
							</p>
							<p>
								<div class="thumbnail">
									<img src="images/Pythagoras.png" alt="Tortoise takes a rest after running the Pythagoras example">
								</div>
							</p>
							</section>
							<!--  section -->
							<section id="tortoise_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="tortoise_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							<p>
								The grammar is almost a joke. Once again, we inherit from the Xbase language to have nice Java integration
								and rich expressions. A user can define a <strong>Program</strong> which can have <strong>SubPrograms</strong> with parameters. The <strong>Executable</strong>
								rule is never called, but defines a common supertype for <strong>Program</strong> and <strong>SubProgram</strong> which will define
								their common member <code class="prettyprint lang-xtend">body</code>. A <strong>Body</strong> is an <strong>XBlockExpression</strong> from Xbase, but with the keywords
								<code class="prettyprint lang-xtend">begin</code> and <code class="prettyprint lang-xtend">end</code> instead of the curly braces.
							</p>
							<pre class="prettyprint lang-xtext linenums">
grammar org.xtext.tortoiseshell.TortoiseShell with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/xtext/xbase/Xbase"
generate tortoiseShell "http://www.xtext.org/tortoiseshell/TortoiseShell"

Program :
  body=Body
  subPrograms+=SubProgram*;
  
SubProgram:
  'sub' name=ValidID
  (parameters += FullJvmFormalParameter)*
  body=Body;

Body returns XBlockExpression:
  {XBlockExpression}
  'begin'
  (expressions+=XExpressionInsideBlock ';'?)*
  'end';
  
Executable:
  Program | SubProgram;</pre>
							</section>
							<!-- subsection -->
							<section id="tortoise_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							<p>
								With the tortoise commands in the runtime library class <a href=""><abbr title="org.xtext.tortoiseshell.runtime.Tortoise">Tortoise</abbr></a> <a href="">(src)</a>
								, we 
								have to make sure to infer a Java class that inherits from this. Within this class, we create a method
								for each <strong>Program</strong> and <strong>SubProgram</strong>. The resulting code looks like this:
							</p>
							<p>
								<pre class="prettyprint lang-xtend linenums">
class TortoiseShellJvmModelInferrer extends AbstractModelInferrer {
  public static val INFERRED_CLASS_NAME = 'MyTortoiseProgram'
  @Inject extension JvmTypesBuilder
     def dispatch void infer(Program program, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
       acceptor.accept(program.toClass(INFERRED_CLASS_NAME)).initializeLater[
         superTypes += program.newTypeRef(typeof(Tortoise))
         if(program.body != null)
           members += program.toMethod("main", program.newTypeRef(Void::TYPE)) [
             body = program.body
           ]
         for(subProgram: program.subPrograms)
           members += subProgram.toMethod(subProgram.name, program.newTypeRef(Void::TYPE)) [
             for(functionParameter: subProgram.parameters)
               parameters += functionParameter.toParameter(functionParameter.name, functionParameter.parameterType)
             body = subProgram.body
           ]
       ]
     }
}</pre> 
							</p>
							</section>
							<!-- subsection -->
							<section id="tortoise_interpreter" style="padding-top: 68px; margin-top: -68px;">
							<h3>Interpreter</h3>
							<p>
								The Xbase languge library does not only provide a compiler that generates Java code, but also an 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html">interpreter</a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java">(src)</a>
								. This has been adapted to
								to execute our <strong>Programs</strong>. 
							</p>
							<p>
								In fact, an interpreter is just a big visitor. For each expression type, it has an evaluation method,
								that recursively calls the evaluation methods for the subexpressions forming its parameters. The methods
								also pass an execution context storing all temporary state such as local variables.
							</p>
							<p>
								The first thing we have to cope with is the strange mixture of existing Java methods (from the super class
								<a href=""><abbr title="org.xtext.tortoiseshell.runtime.Tortoise">Tortoise</abbr></a> <a href="">(src)</a>
								) and inferred ones. While the former are evaluated
								via Java reflection, we need special treatment for the latter. The idea is to bind an instance of 
								<a href=""><abbr title="org.xtext.tortoiseshell.runtime.Tortoise">Tortoise</abbr></a> <a href="">(src)</a>
								 to this and intercept calls to the inferred methods to 
								execute them directly. This is accomplished by overriding the method 
							</p>
							<p>
								<code class="prettyprint lang-xtend">invokeOperation</code>:
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension IJvmModelAssociations
 
override protected invokeOperation(JvmOperation operation, Object receiver, List&lt;Object&gt; argumentValues) {
  val executable = operation.sourceElements.head
  if(executable instanceof Executable) {
    val context = createContext
    context.newValue(XbaseScopeProvider::THIS, tortoise)
    var index = 0
    for(param: operation.parameters) {
      context.newValue(QualifiedName::create(param.name), argumentValues.get(index))
      index = index + 1  
    }
    evaluate((executable as Executable).body, context, CancelIndicator::NullImpl)
  } else {
    super.invokeOperation(operation, receiver, argumentValues)
  }
}</pre>
							<p>
								One thing you have to know about the Java inferrence is that when creating Java elements using the
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder">JvmTypesBuilder</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">(src)</a>
								, the infrastructure stores the information which 
								elements have been inferred from which source elements. To navigate these traces, we use the the Xbase service
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.html"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations">IJvmModelAssociations</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.java">(src)</a>
								. So to detect wheter a 
								<a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/common/types/JvmOperation.html"><abbr title="org.eclipse.xtext.common.types.JvmOperation">JvmOperation</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmOperation.java">(src)</a>
								 is inferred, we check whether it has a source element.
								If so, we have to setup an exection context binding <code class="prettyprint lang-xtend">this</code> and the parameters as local variables and then 
								execute the method's body using the interpreter. 
							</p>
							<p>
								To start the interpretation we need to do almost the same: Setup the execution context and then evaluate
								the <strong>Program's</strong> body. The respective code is 
							</p>
							<pre class="prettyprint lang-xtend linenums">
override run(Tortoise tortoise, EObject program, int stopAtLine) {
  if(tortoise != null && program != null) {
    this.tortoise = tortoise
    this.stopAtLine = stopAtLine
    try {
      program.jvmElements.filter(typeof(JvmOperation)).head
        ?.invokeOperation(null, Collections::emptyList)
    } catch (StopLineReachedException exc) {
      // ignore
    }
  }
}</pre>
							<p>
								The <a href=""><abbr title="org.xtext.tortoiseshell.interpreter.StopLineReachedException">StopLineReachedException</abbr></a> <a href="">(src)</a>
								 is part of the <strong>Step Mode</strong>.
								It is thrown when the execution reaches the line <code class="prettyprint lang-xtend">stopAtLine</code>, thus terminating the current execution.
								The throwing code is
							</p>
							<pre class="prettyprint lang-xtend linenums">
override protected internalEvaluate(XExpression expression, IEvaluationContext context, CancelIndicator indicator) {
  val line = NodeModelUtils::findActualNodeFor(expression)?.startLine
  if(line-1 == stopAtLine)
    throw new StopLineReachedException
  super.internalEvaluate(expression, context, indicator)
}</pre>
							</section>
							<!-- subsection -->
							<section id="tortoise_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								To make the static methods and fields of <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Math.html"><abbr title="java.lang.Math">Math</abbr></a> <a href="">(src)</a>
								 and <a href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/draw2d/ColorConstants.html"><abbr title="org.eclipse.draw2d.ColorConstants">ColorConstants</abbr></a> <a href="">(src)</a>
								
								callable directly, we provided the <a href=""><abbr title="org.xtext.tortoiseshell.scoping.TortoiseShellExtensionClassNameProvider">TortoiseShellExtensionClassNameProvider</abbr></a> <a href="">(src)</a>
								.
							</p>
							<p>
								To overcome a small issue in the interpreter we also had to implement the 
								<a href=""><abbr title="org.xtext.tortoiseshell.scoping.TortoiseShellIdentifiableSimpleNameProvider">TortoiseShellIdentifiableSimpleNameProvider</abbr></a> <a href="">(src)</a>
								. 
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="tortoise_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							<p>
								You could at a lot of library stuff, such as methods for drawing primitves like cricles, filled polygons
								etc. It may also be interesting to experiment with multiple turtles and try to programme some game like 
								<a href="http://en.wikipedia.org/wiki/Tron_%28video_game%29">Tron</a>. Of course, there could also be more UI, 
								like for exporting figures. The lesson to learn is that even a language with just a few concepts can become
								very flexible by using powerful libraries. 
							</p>
							</section>
						</div>
					</div>
				</section>
				<!-- chapter -->
				<section id="tba" style="margin-bottom: 50px">
					<div class="row">
						<div class="span10 offset1">
							<h1>
								T.B.A.
							</h1>
							<hr style="margin-top: 5px; margin-bottom: 5px;">
							<!--  section -->
							<section id="tba_motivation" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Problem</h2>
							<p>
								Motivation
								Why
							</p>
							</section>
							<!--  section -->
							<section id="tba_solution" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">A Solution With Xtext</h2>
							<p>
								Why a DSL
								How about expressions
								DSL example, Java example, Client code example (if appropriate)
							</p>
							<p>
								Approx 2 pages upto here
							</p>
							<!-- subsection -->
							<section id="tba_statistics" style="padding-top: 68px; margin-top: -68px;">
							<h3>Some Stats</h3>
							<p>
								files touched, LOC, animals harmed, etc 
								can also be funny
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="tba_running" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Running the Example</h2>
							<p>
								Details on how to run it: Prerequisites, additional plugins... 
							</p>
							</section>
							<!--  section -->
							<section id="tba_details" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">The Solution in Detail</h2>
							<!-- subsection -->
							<section id="tba_grammar" style="padding-top: 68px; margin-top: -68px;">
							<h3>Grammar</h3>
							</section>
							<!-- subsection -->
							<section id="tba_inferrer" style="padding-top: 68px; margin-top: -68px;">
							<h3>Translation to Java</h3>
							</section>
							<!-- subsection -->
							<section id="tba_additons" style="padding-top: 68px; margin-top: -68px;">
							<h3>Additional Aspects</h3>
							<p>
								Addtionally customized things: validation, scoping, code completion ...
							</p>
							</section>
							</section>
							<!--  section -->
							<section id="_beyond" style="margin-top: 20px; padding-top: 0;">
							<h2 style="font-weight: normal;">Beyond This Example</h2>
							</section>
						</div>
					</div>
				</section>
			</div>
		</div>
	</div>
	<div id="extra">
	
		<div class="inner">
	
			<div class="container">
	
				<div class="row">
	
					<div class="span6">
	
						<h3>Quick Links</h3>
	
	
						<ul class="footer-links clearfix">
							<li><a href="#">Support</a></li>
							<li><a href="#">License</a></li>
							<li><a href="#">Terms of Use</a></li>
							<li><a href="#">Privacy Policy</a></li>
						</ul>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
							<li><a href="http://marketplace.eclipse.org/">Eclipse Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
	
					</div>
	
	
					<div class="span6">
	
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">@Xtext</a> Tweets</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
	
	
					</div>
				</div>
	
			</div>
	
		</div>
	
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	
	<script src="js/custom.js" type="text/javascript"></script>
</body>
</html>
