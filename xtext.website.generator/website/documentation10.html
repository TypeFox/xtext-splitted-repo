<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtext - Language Development Made Easy!</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages">
	<meta name="author" content="Sven Efftinge">
	<style>
		#header_wrapper {
			padding-top: 10px;
			/* 60px to make the container go all the way to the bottom of the topbar */
		}
		
		code.prettyprint {
	        padding: 0px;
	        background-color: white;
			border: none;
	    }
	</style>
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
					prettyPrint();
	         
					 $('a[data-rel]').each(function() {
	             $(this).attr('rel', $(this).data('rel'));
	         });
	        
					 $("a[rel^='prettyPhoto']").prettyPhoto({
	             animation_speed: 'fast',
	             slideshow: 5000,
	             autoplay_slideshow: false,
	             opacity: 0.80,
	             show_title: true,
	             theme: 'ligh_square',
	             overlay_gallery: false,
	             social_tools: false
	       
	         });
	         
					$('#nav-outline > li > a').live('click', function() {        
						$(this).parent().find('ul').slideToggle();      
					});
	         
					$('.has-popover').popover();
		 	     
		 	     getTwitters('tweet', { 
			        id: 'xtext', 
			        count: 5,
			        includeRT: true,
			        enableLinks: true, 
			        clearContents: true,
			        template : '"%text%" - %time% by <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">@%user_screen_name%</a><br/><br/>'
			     });
	         
	         var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		 	     po.src = 'https://apis.google.com/js/plusone.js';
		 	     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
	
	      <div class="btn-group pull-right">
	        <g:plusone href="http://www.xtext.org"></g:plusone>
	      </div>
	
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li ><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
	
				</div>
				<!--/.nav-collapse -->
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<div id="header_wrapper" class="container">
	<div class="inner">
		<div class="container">
			<div class="page-heading"><h1>Documentation</h1></div>
		</div> <!-- /.container -->
	</div> <!-- /inner -->
	<ul id="nav-outline">
		<li>&nbsp;</li>
		<li style="color : #333;">Getting Started</li>
		<li><a href="documentation.html#FirstFiveMinutes">5 Minutes Tutorial</a>
	<ul>	<li><a href="documentation.html#NewProject">Creating A New Xtext Project</a></li>
		<li><a href="documentation.html#RunWorkflow">Generating The Language Infrastructure</a></li>
		<li><a href="documentation.html#TestingTheEditor">Try The Editor</a></li>
		<li><a href="documentation.html#Conclusion">Conclusion</a></li>
	</ul>	</li>
		<li><a href="documentation1.html#DomainModelWalkThrough">15 Minutes Tutorial</a>
	<ul>	<li><a href="documentation1.html#_0">Create A New Xtext Project</a></li>
		<li><a href="documentation1.html#_1">Write Your Own Grammar</a></li>
		<li><a href="documentation1.html#_2">Generate Language Artifacts</a></li>
		<li><a href="documentation1.html#_3">Run the Generated IDE Plug-in</a></li>
		<li><a href="documentation1.html#_4">Second Iteration: Adding Packages and Imports</a></li>
	</ul>	</li>
		<li><a href="documentation2.html#DomainmodelNextSteps">15 Minutes Tutorial - Extended</a>
	<ul>	<li><a href="documentation2.html#TutorialCodeGeneration">Writing a Code Generator With Xtend</a></li>
		<li><a href="documentation2.html#TutorialUnitTests">Unit Testing the Language</a></li>
		<li><a href="documentation2.html#TutorialValidation">Creating Custom Validation Rules</a></li>
	</ul>	</li>
		<li><a href="documentation3.html#JvmDomainmodel">Five simple steps to your JVM language</a>
	<ul>	<li><a href="documentation3.html#_5">Step One: Create A New Xtext Project</a></li>
		<li><a href="documentation3.html#_6">Step Two: Write the Grammar</a></li>
		<li><a href="documentation3.html#_7">Step Three: Generate Language Artifacts</a></li>
		<li><a href="documentation3.html#_8">Step Four: Define the Mapping to JVM Concepts</a></li>
		<li><a href="documentation3.html#_9">Step Five : Try the Editor!</a></li>
	</ul>	</li>
		<li>&nbsp;</li>
		<li style="color : #333;">Reference Documentation</li>
		<li><a href="documentation4.html#Overview">Overview</a>
	<ul>	<li><a href="documentation4.html#_10">What is Xtext?</a></li>
		<li><a href="documentation4.html#_11">How Does It Work?</a></li>
		<li><a href="documentation4.html#_12">Xtext is Highly Configurable</a></li>
		<li><a href="documentation4.html#_13">Who Uses Xtext?</a></li>
		<li><a href="documentation4.html#_14">Who is Behind Xtext?</a></li>
		<li><a href="documentation4.html#DSL">What is a Domain-Specific Language</a></li>
	</ul>	</li>
		<li><a href="documentation5.html#grammarLanguage">The Grammar Language</a>
	<ul>	<li><a href="documentation5.html#statemachine">A First Example</a></li>
		<li><a href="documentation5.html#syntax">The Syntax</a></li>
		<li><a href="documentation5.html#metamodelInference">Ecore Model Inference</a></li>
		<li><a href="documentation5.html#grammarMixins">Grammar Mixins</a></li>
		<li><a href="documentation5.html#_15">Common Terminals</a></li>
	</ul>	</li>
		<li><a href="documentation6.html#configuration">Configuration</a>
	<ul>	<li><a href="documentation6.html#generator">The Language Generator</a></li>
		<li><a href="documentation6.html#dependencyInjection">Dependency Injection in Xtext with Google Guice</a></li>
	</ul>	</li>
		<li><a href="documentation7.html#runtime_concepts">Runtime Concepts</a>
	<ul>	<li><a href="documentation7.html#runtimeSetup">Runtime Setup (ISetup)</a></li>
		<li><a href="documentation7.html#equinoxSetup">Setup within Eclipse-Equinox (OSGi)</a></li>
		<li><a href="documentation7.html#_16">Logging</a></li>
		<li><a href="documentation7.html#validation">Validation</a></li>
		<li><a href="documentation7.html#linking">Linking</a></li>
		<li><a href="documentation7.html#scoping">Scoping</a></li>
		<li><a href="documentation7.html#valueconverter">Value Converter</a></li>
		<li><a href="documentation7.html#serialization">Serialization</a></li>
		<li><a href="documentation7.html#formatting">Formatting (Pretty Printing)</a></li>
		<li><a href="documentation7.html#fragmentProvider">Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)</a></li>
		<li><a href="documentation7.html#encoding">Encoding in Xtext</a></li>
	</ul>	</li>
		<li><a href="documentation8.html#ide_concepts">IDE Concepts</a>
	<ul>	<li><a href="documentation8.html#labelProvider">Label Provider</a></li>
		<li><a href="documentation8.html#contentAssist">Content Assist</a></li>
		<li><a href="documentation8.html#quickfixes">Quick Fixes</a></li>
		<li><a href="documentation8.html#templates">Template Proposals</a></li>
		<li><a href="documentation8.html#outline">Outline View</a></li>
		<li><a href="documentation8.html#hyperlinking">Hyperlinking</a></li>
		<li><a href="documentation8.html#highlighting">Syntax Coloring</a></li>
		<li><a href="documentation8.html#refactoring">Rename Refactoring</a></li>
	</ul>	</li>
		<li><a href="documentation9.html#Xbase">Xtext and Java</a>
	<ul>	<li><a href="documentation9.html#_17">Plug-in Setup</a></li>
		<li><a href="documentation9.html#jvmtypes">Referring to Java Elements using JVM Types</a></li>
		<li><a href="documentation9.html#xbaseJavaReferences">Referring to Java Types Using Xbase</a></li>
		<li><a href="documentation9.html#xbaseInferredType">Inferring a JVM Model</a></li>
		<li><a href="documentation9.html#xbaseExpressions">Using Xbase Expressions</a></li>
		<li><a href="documentation9.html#xbaseLanguageRef_Introduction">Xbase Language Reference</a></li>
	</ul>	</li>
		<li><a href="documentation10.html#MWE2">MWE2</a>
	<ul style="display: block;">	<li><a href="documentation10.html#MWE2Exampe">Examples</a></li>
		<li><a href="documentation10.html#MWE2LanguageReference">Language Reference</a></li>
		<li><a href="documentation10.html#MWE2SyntaxReference">Syntax Reference</a></li>
	</ul>	</li>
		<li><a href="documentation11.html#emf_integration">Integration with EMF and Other EMF Editors</a>
	<ul>	<li><a href="documentation11.html#model_metamodel">Model, Ecore Model, and Ecore</a></li>
		<li><a href="documentation11.html#emf_codegen">EMF Code Generation</a></li>
		<li><a href="documentation11.html#xtext_resource">XtextResource Implementation</a></li>
		<li><a href="documentation11.html#gmf_integration">Integration with GMF Editors</a></li>
	</ul>	</li>
		<li>&nbsp;</li>
		<li style="color : #333;">Appendix</li>
		<li><a href="documentation12.html#migrating_from_1_0_x">Migrating from Xtext 1.0.x to 2.0</a>
	<ul>	<li><a href="documentation12.html#_18">Take the Shortcut</a></li>
		<li><a href="documentation12.html#_19">Migrating Step By Step</a></li>
		<li><a href="documentation12.html#_20">Now go for then new features</a></li>
	</ul>	</li>
		<li><a href="documentation13.html#migrating_from_0_7">Migrating from Xtext 0.7.x to 1.0</a>
	<ul>	<li><a href="documentation13.html#_21">Migrating Step By Step</a></li>
	</ul>	</li>
		<li>&nbsp;</li>
		<li style="color : #333;">Additional Resources
		<li><a href="documentation/2.3.0/Documentation.pdf">Documentation <img src="images/pdf_icon.gif"></a>
		<li><a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/">API Documentation (JavaDoc)</a>
	</ul>
</div>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="MWE2" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span8 offset3">
						<h1 style="padding-top: 30px;">
							MWE2
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<p>
							The Modeling Workflow Engine 2 (MWE2) is a rewritten backwards 
							compatible implementation of the Modeling Workflow Engine (MWE). It 
							is a declarative, externally configurable generator engine. Users 
							can describe arbitrary object compositions by means of a simple, 
							concise syntax that allows to declare object instances, attribute 
							values and references. One use case - that's where the name had its 
							origins - is the definition of workflows. Such a workflow consists 
							usually of a number of components that interact with each other. 
							There are components to read EMF resources, to perform 
							operations (transformations) on them and to write them back or to generate 
							any number of other artifacts out of the information. Workflows are 
							typically executed in a single JVM. However there are no constraints 
							the prevent implementors to provide components that spawn multiple 
							threads or new processes.
						</p>
						<!--  section -->
						<section id="MWE2Exampe" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Examples</h2>
						<p>
							Let's start with a couple of examples to demonstrate some usage 
							scenarios for MWE2. The first example is a simple <code class="prettyprint lang-mwe2">HelloWorld</code> 
							module that does nothing but print a message to standard out. The 
							second module is assembled of three components that read an Ecore 
							file, transform the contained classifier-names to upper-case and 
							serialize the resource back to a new file. The last example uses 
							the life-cycle methods of the <a href="http://download.eclipse.org/modeling/emft/mwe/javadoc/2.3/org/eclipse/emf/mwe2/runtime/workflow/IWorkflowComponent.html"><abbr title="org.eclipse.emf.mwe2.runtime.workflow.IWorkflowComponent">IWorkflowComponent</abbr></a> <a href="https://github.com/eclipse/mwe/blob/v2.3.0/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/workflow/IWorkflowComponent.java">(src)</a> 
							to print the execution time of the workflow.
						</p>
						<!-- subsection -->
						<section id="MWE2HelloWorld" style="padding-top: 68px; margin-top: -68px;">
						<h3>The Simplest Workflow</h3>
						<p>
							The arguably shortest MWE2 module may look like the following 
							snippet:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module HelloWorld 

SayHello {
  message = "Hello World!"
}</pre>
							<p>
						</p>
						<p>
							It configures a very simple workflow component with a message 
							that should be printed to <code class="prettyprint lang-java">System.out</code> when the workflow is 
							executed. The module begins with a declaration of its name. It must 
							fulfill the Java conventions for fully qualified class-names. That's 
							why the module <code class="prettyprint lang-mwe2">HelloWorld</code> has to be placed into the default 
							package of a Java source folder. The second element in the module is 
							the class-name <code class="prettyprint lang-java">SayHello</code> which introduces the root element of the 
							module. The interpreter will create an instance of the given 
							type and configure it as declared between the curly braces. E.g. the 
							assignment <code class="prettyprint lang-mwe2">message = "Hello World!"</code> in the module will be 
							interpreted as an invocation of the <code class="prettyprint lang-java">setMessage(String)</code> on the 
							instantiated object. As one can easily imagine, the implementation 
							of the class <code class="prettyprint lang-java">SayHello</code> looks straight forward:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
import org.eclipse.emf.mwe2.runtime.workflow.IWorkflowComponent;
import org.eclipse.emf.mwe2.runtime.workflow.IWorkflowContext;

public class SayHello implements IWorkflowComponent {

  private String message = "Hello World!";
  public void setMessage(String message) {
    this.message = message;
  }
  public String getMessage() {
    return message;
  }

  public void invoke(IWorkflowContext ctx) {
    System.out.println(getMessage());
  }

  public void postInvoke() {}
  public void preInvoke() {}
}</pre>
							<p>
						</p>
						<p>
							It looks like a simple POJO and that's the philosophy behind MWE2. 
							It is easily possible to assemble completely independent objects in 
							a declarative manner. To make the workflow executable with the 
							<a href="http://download.eclipse.org/modeling/emft/mwe/javadoc/2.3/org/eclipse/emf/mwe2/launch/runtime/Mwe2Runner.html"><abbr title="org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner">Mwe2Runner</abbr></a> <a href="https://github.com/eclipse/mwe/blob/v2.3.0/plugins/org.eclipse.emf.mwe2.launch/src/org/eclipse/emf/mwe2/launch/runtime/Mwe2Runner.java">(src)</a>, the component 
							<code class="prettyprint lang-mwe2">SayHello</code> must be nested in a root 
							workflow:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module HelloWorld 

Workflow {
  component = SayHello {
    message = "Hello World!"
  }
}</pre>
							<p>
						</p>
						<p>
							The package <code class="prettyprint lang-java">org.eclipse.emf.mwe2.runtime.workflow</code> of the class <a href="http://download.eclipse.org/modeling/emft/mwe/javadoc/2.3/org/eclipse/emf/mwe2/runtime/workflow/Workflow.html"><abbr title="org.eclipse.emf.mwe2.runtime.workflow.Workflow">Workflow</abbr></a> <a href="https://github.com/eclipse/mwe/blob/v2.3.0/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/workflow/Workflow.java">(src)</a> 
							is implicitly imported in MWE2 modules to make the the modules more 
							concise. The execution result of this workflow will be revealed 
							after a quick <strong>Run As .. -&gt; MWE2 Workflow</strong> in the console as
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
Hello World!</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2SimpleTransformation" style="padding-top: 68px; margin-top: -68px;">
						<h3>A Simple Transformation</h3>
						<p>
							The following workflow solves the exemplary task to rename every 
							<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/ecore/EClassifier.html"><abbr title="org.eclipse.emf.ecore.EClassifier">EClassifier</abbr></a> <a href="https://github.com/eclipse/emf/blob/R2_8_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java">(src)</a> in an <strong>*.ecore</strong> file.
							It consists of three components that read, modify and write the model file:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module Renamer
Workflow {
  component = ResourceReader {
        uri = "model.ecore"
  }
  component = RenamingTransformer {}
  component = ResourceWriter {
        uri = "uppercaseModel.ecore"
  }
}</pre>
							<p>
						</p>
						<p>
							The implementation of these components is surprisingly simple. It is easily possible to create
							own components even for minor operations to automate a process.
						</p>
						<p>
							The <code class="prettyprint lang-java">ResourceReader</code> simply reads the file with the given 
							<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/common/util/URI.html"><abbr title="org.eclipse.emf.common.util.URI">URI</abbr></a> <a href="https://github.com/eclipse/emf/blob/R2_8_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">(src)</a> and stores it in a so called
							<strong>slot</strong> of the workflow context. A slot can be understood as a dictionary or map-entry.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class ResourceReader extends WorkflowComponentWithSlot {
  private String uri;
  public void invoke(IWorkflowContext ctx) {
    ResourceSet resourceSet = new ResourceSetImpl();
    URI fileURI = URI.createFileURI(uri); 
    Resource resource = resourceSet.getResource(fileURI, true);
    ctx.put(getSlot(), resource);
  }
  
  public void setUri(String uri) {
    this.uri = uri;
  }
  public String getUri() {
    return uri;
  }
}</pre>
							<p>
						</p>
						<p>
							The actual transformer takes the model from the slot and modifies it. It simply iterates the content
							of the resource, identifies each <a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/ecore/EClassifier.html"><abbr title="org.eclipse.emf.ecore.EClassifier">EClassifier</abbr></a> <a href="https://github.com/eclipse/emf/blob/R2_8_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java">(src)</a> and sets its name.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class RenamingTransformer extends WorkflowComponentWithSlot {
  private boolean toLowerCase = false;
  public void invoke(IWorkflowContext ctx) {
    Resource resource = (Resource) ctx.get(getSlot());
    EcoreUtil.resolveAll(resource);
    Iterator&lt;Object&gt; contents = EcoreUtil.getAllContents(resource, true);
    Iterator&lt;EClassifier&gt; iter = 
        Iterators.filter(contents, EClassifier.class);
    while(iter.hasNext()) {
      EClassifier classifier = (EClassifier) iter.next();
      classifier.setName(isToLowerCase() 
          ? classifier.getName().toLowerCase()
          : classifier.getName().toUpperCase());
    }
  }

  public void setToLowerCase(boolean toLowerCase) {
    this.toLowerCase = toLowerCase;
  }
  public boolean isToLowerCase() {
    return toLowerCase;
  }
}</pre>
							<p>
						</p>
						<p>
							After the model has been modified it should be written to a new file. That's what the 
							<code class="prettyprint lang-mwe2">ResourceWriter</code> does. It actually takes the resource from the given <strong>slot</strong> and saves it with
							the configured <a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/common/util/URI.html"><abbr title="org.eclipse.emf.common.util.URI">URI</abbr></a> <a href="https://github.com/eclipse/emf/blob/R2_8_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">(src)</a>:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class ResourceWriter extends WorkflowComponentWithSlot {
  private String uri;
  public void invoke(IWorkflowContext ctx) {
    Resource resource = (Resource) ctx.get(getSlot());
    URI uri = URI.createFileURI(getUri());
    uri = resource.getResourceSet().getURIConverter().normalize(uri);
    resource.setURI(uri);
    try {
      resource.save(null);
    } catch (IOException e) {
      throw new WrappedException(e);
    }
  }

  public void setUri(String uri) {
    this.uri = uri;
  }
  public String getUri() {
    return uri;
  }
}</pre>
							<p>
						</p>
						<p>
							Last but not least, the common supertype for those components looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public abstract class WorkflowComponentWithSlot 
      implements IWorkflowComponent {
  private String slot = "model";
  public void setSlot(String slot) {
    this.slot = slot;
  }
  public String getSlot() {
    return slot;
  }
  
  public void postInvoke() {}
  public void preInvoke() {}
}</pre>
							<p>
						</p>
						<p>
							Each of the mentioned implementations is rather simple and can be done in a couple of minutes. 
							Many tedious tasks that developers face in their daily work can be addressed by a chain of rather
							simple components. MWE2 can be used to automate these tasks with minimum effort.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2Stopwatch" style="padding-top: 68px; margin-top: -68px;">
						<h3>A Stop-Watch</h3>
						<p>
							The last example demonstrates how to combine the MWE2 concepts to create a simple stop-watch that
							allows to measure the execution time of a set of components. The idea is to add the very same stop-watch
							twice as a component to a workflow. It will measure the time from the first pre-invoke to the last
							post-invoke event and print the elapsed milliseconds to the console.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
public class StopWatch implements IWorkflowComponent {
  private long start;
  private boolean shouldStop = false;
  public void invoke(IWorkflowContext ctx) {}

  public void postInvoke() {
    if (shouldStop) {
      long elapsed = System.currentTimeMillis() - start;
      System.out.println("Time elapsed: " + elapsed + " ms");
    }
    shouldStop = true;
  }

  public void preInvoke() {
    start = System.currentTimeMillis();
  }
}</pre>
							<p>
						</p>
						<p>
							Clients who want to leverage this kind of stop-watch may use the following pattern. The instance of the
							class <code class="prettyprint lang-java">StopWatch</code> has to be added as the first component and the last component to a workflow. 
							Every component in-between will be measured. In this case, it is another workflow that does not need know 
							about this decoration. The idea is to use a local identifier for the instantiated <code class="prettyprint lang-java">StopWatch</code> 
							and reuse this one at the end to receive the post-invoke life-cycle event twice.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module MeasuredWorkflow

Workflow {
  component = StopWatch: stopWatch {}
  component = @OtherWorkflow {}
  component = stopWatch
}</pre>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="MWE2LanguageReference" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Language Reference</h2>
						<p>
							MWE2 has a few well defined concepts which can be combined to 
							assemble arbitrary object graphs in a compact and declarative 
							manner.
						</p>
						<p>
							</p>
							<ul>
								<li>A MWE2 file defines a <code class="prettyprint lang-mwe2">module</code> which exposes its root <code class="prettyprint lang-mwe2">component</code> as reusable artifact.</li>
								<li><code class="prettyprint lang-mwe2">Properties</code> can be used to extract reusable, configurable parts of the workflow.</li>
								<li>Components are mapped to plain vanilla <strong>Java objects</strong>. Arbitrary <code class="prettyprint lang-java">setABC(..)</code> and <code class="prettyprint lang-java">addXYZ(..)</code> methods 
								    are used to configure them.</li>
							</ul>
							<p>
						</p>
						<p>
							Let's consider the follow short example module and <code class="prettyprint lang-java">SampleClass</code> to 
							explain these concepts.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Example

import java.util.*

SampleClass {
  singleValue = 'a string'
  multiValue = ArrayList {}
  child = {}
}</pre>
							<p>
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-java linenums">
package com.mycompany;

import java.util.List;

public class SampleClass {
  public void setSingleValue(String value) {..}
  public void addMultiValue(List&lt;?&gt; value) {..}
  public void addChild(SampleClass value) {..}
}</pre>
							<p>
						</p>
						<!-- subsection -->
						<section id="MWE2JavaReferences" style="padding-top: 68px; margin-top: -68px;">
						<h3>Mapping to Java Classes</h3>
						<p>
							The module <code class="prettyprint lang-mwe2">com.mycompany.Example</code> defines a root component of 
							type <code class="prettyprint lang-java">com.mycompany.SampleClass</code>. It is possible to use the simple 
							class-name because MWE2 uses the very same visibility rules as the 
							Java compiler. Classes that are in the same package as the module 
							can be referenced by their simple name. The same rule applies for 
							classes from the <code class="prettyprint lang-java">java.lang</code> package. For convenience reasons is the 
							package <code class="prettyprint lang-java">org.eclipse.emf.mwe2.runtime.workflow</code> implicitly imported 
							as well as it exposes some library workflow components. However, the
							imports are more flexible then in Java since MWE2-imports can be relative, e.g. 
							the <code class="prettyprint lang-java">import java.*</code> resolves the reference <code class="prettyprint lang-java">util.ArrayList</code> to 
							<code class="prettyprint lang-java">java.util.ArrayList</code>.
						</p>
						<p>
							The root instance of type <code class="prettyprint lang-java">SampleClass</code> has to be configured 
							after it has been created. Therefore the method <code class="prettyprint lang-java">setSingleValue</code> 
							will be called at first. The given parameter is 
							<code class="prettyprint lang-java">'a string'</code>. The method is identified by its name which starts with 
							<code class="prettyprint lang-java">set</code>. To allow to assign multi-value properties, MWE provides 
							access to methods called <code class="prettyprint lang-java">add*</code> as well.
						</p>
						<p>
							If the right side of the assignment in the workflow file does not 
							define a class explicitly, its type is inferred from the method 
							parameter. The line <code class="prettyprint lang-mwe2">child = {}</code> is equivalent to 
							<code class="prettyprint lang-mwe2">child = SampleClass {}</code> and creates a new instance of <code class="prettyprint lang-java">SampleClass</code>.
						</p>
						<p>
							MWE2 ships with nice tool support. The editor will provide 
							content assist for the allowed types and highlight incompatible 
							assignments. The available properties for Java classes will be 
							proposed as well.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2Module" style="padding-top: 68px; margin-top: -68px;">
						<h3>Module</h3>
						<p>
							As MWE2 modules have a fully qualified name, it is possible to refer
							to them from other modules. The type of the module is derived from
							the type of its root component. The <code class="prettyprint lang-mwe2">com.mycompany.Example</code> can be
							assigned at any place where a <code class="prettyprint lang-java">com.mycompany.SampleClass</code> is expected.
						</p>
						<p>
							Let's create a second module <code class="prettyprint lang-mwe2">com.mycompany.Second</code> like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.sub.Second

import com.mycompany.*

SampleClass {
  child = @Example {}
}</pre>
							<p>
						</p>
						<p>
							The <code class="prettyprint lang-mwe2">child</code> value will be assigned to an instance of <code class="prettyprint lang-java">SampleClass</code> 
							that is configured as in the first example workflow. This enables
							nice composition and a very focused, reusable component design.
						</p>
						<p>
							As the same rules apply in MWE2 like in Java, the module 
							<code class="prettyprint lang-mwe2">com.mycompany.sub.Second</code> has to be defined in a file called 
							<strong>Second.mwe2</strong> in the package <code class="prettyprint lang-java">com.mycompany.sub</code>. The import semantic
							for other modules is the same as for classes. The import statement
							allows to refer to <code class="prettyprint lang-mwe2">com.mycompany.Example</code> with a shortened name.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2Properties" style="padding-top: 68px; margin-top: -68px;">
						<h3>Properties</h3>
						<p>
							MWE2 allows to extract arbitrary information into properties to 
							ensure that these pieces are not cluttered around the workflow and 
							to allow for easier external customization. The exemplary component 
							definition was only changed slightly by introducing a property 
							<code class="prettyprint lang-mwe2">value</code>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Example

var value = 'a string'

SampleClass {
  singleValue = value
}</pre>
							<p>
						</p>
						<p>
							The type of the property will be derived from the default value 
							similar to the mechanism that is already known from <code class="prettyprint lang-java">set</code>- and 
							<code class="prettyprint lang-java">add</code>-methods. If no default value is given, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a> will
							be assumed. However, properties are not limited to strings. The 
							second built in type is boolean via the familiar literals <code class="prettyprint lang-mwe2">true</code> and
							<code class="prettyprint lang-mwe2">false</code>. More flexibility is available via actual component literals.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Example

var childInstance = SampleClass {
                      singleValue = "child"
                    }

SampleClass {
  child = childInstance
}</pre>
							<p>
						</p>
						<p>
							If one wants to define string properties that are actual reusable
							parts for other properties, she may use defined variables inside other
							literals like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
var aString = "part"
var anotherString = "reuse the ${part} here"</pre>
							<p>
						</p>
						<p>
							This is especially useful for file paths in workflows as one would
							usually want to define some common root directories only once in the
							workflow and reuse this fragment across certain other file locations.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2Mandatory" style="padding-top: 68px; margin-top: -68px;">
						<h3>Mandatory Properties</h3>
						<p>
							It is not always feasible to define default values for properties. 
							That is where mandatory properties come into play. Modules define their
							interface not only via their fully qualified name and the type of the
							root component but also by means of the defined properties.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Example

var optional = 'a string'
var mandatory

SampleClass {
  singleValue = optional
  child = {
    singleValue = mandatory
  }
}</pre>
							<p>
						</p>
						<p>
							This version of the example module exposes two externally assignable
							properties. The second one has no default value assigned and is 
							thereby considered to be mandatory. The mandatory value must be assigned
							if we reuse <code class="prettyprint lang-mwe2">org.mycompany.Example</code> in another module like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Second

var newMandatory

@Example {
  mandatory = "mandatoryValue"
  optional = newMandatory
}</pre>
							<p>
						</p>
						<p>
							Note that it is even possible to reuse another module as the root
							component of a new module. In this case we set the mandatory 
							property of <code class="prettyprint lang-mwe2">Example</code> to a specific constant value while the previously
							optional value is now redefined as mandatory by means of a new property
							without a default value.
						</p>
						<p>
							It is not only possible to define mandatory properties for MWE2 
							modules but for classes as well. Therefore MWE2 ships with the 
							<a href="http://download.eclipse.org/modeling/emft/mwe/javadoc/2.3/org/eclipse/emf/mwe2/runtime/Mandatory.html"><abbr title="org.eclipse.emf.mwe2.runtime.Mandatory">Mandatory</abbr></a> <a href="https://github.com/eclipse/mwe/blob/v2.3.0/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/Mandatory.java">(src)</a> annotation. If a <code class="prettyprint lang-java">set</code>- or <code class="prettyprint lang-java">add</code>-method is marked as
							<a href="http://download.eclipse.org/modeling/emft/mwe/javadoc/2.3/org/eclipse/emf/mwe2/runtime/Mandatory.html"><abbr title="org.eclipse.emf.mwe2.runtime.Mandatory">Mandatory</abbr></a> <a href="https://github.com/eclipse/mwe/blob/v2.3.0/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/Mandatory.java">(src)</a>, the module validation will fail if no value was assigned
							to that feature.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2NamedComponents" style="padding-top: 68px; margin-top: -68px;">
						<h3>Named Components</h3>
						<p>
							Properties are not the only way to define something that can be reused.
							It is possible to assign a name to any instantiated component whether it's
							created from a class literal or from another component. This allows
							to refer to previously created and configured instances. Named instances
							can come handy for notification and call-back mechanisms or more general
							in terms of defined life-cycle events.
						</p>
						<p>
							If we wanted to assign the created instance to a property of itself,
							we could use the following syntax:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Example

SampleClass : self {
  child = self
}</pre>
							<p>
						</p>
						<p>
							A named component can be referenced immediately after its creation but
							it is not possible to use forward references in a MWE2 file.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2AutoInject" style="padding-top: 68px; margin-top: -68px;">
						<h3>Auto Injection</h3>
						<p>
							Existing modules or classes often expose a set of properties that 
							will be assigned to features of its root component or set- and add- 
							methods respectively. In many cases its quite hard to come up with 
							yet another name for the very same concept which leads to the situation
							where the properties itself have the very same name as the component's
							feature. To avoid the overall repetition of assignments, MWE2 offers
							the possibility to use the <code class="prettyprint lang-mwe2">auto-inject</code> modifier on the component 
							literal:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
module com.mycompany.Example

var child = SampleClass {}

SampleClass auto-inject {
}</pre>
							<p>
						</p>
						<p>
							This example will implicitly assign the value of the property
							<code class="prettyprint lang-mwe2">child</code> to the feature <code class="prettyprint lang-mwe2">child</code> of the root component. This is especially
							useful for highly configurable workflows that expose dozens of optional
							parameters each of which can be assigned to one or more components.
						</p>
						<p>
							The <code class="prettyprint lang-mwe2">auto-inject</code> modifier can be used for a subset of the available
							features as well. It will suppressed for the explicitly set values
							of a component.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="MWE2SyntaxReference" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Syntax Reference</h2>
						<p>
							The following chapter serves as a reference for the concrete syntax of 
							MWE2. The building blocks of a module will be described in a few words.
						</p>
						<p>
							MWE2 is not sensitive to white space and allows to define line-comments
							and block comments everywhere. The syntax is the same as one is used 
							to from the Java language:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
// This is a comment
/* 
  This is another one.
*/</pre>
							<p>
						</p>
						<p>
							Every name in MWE2 can be a fully qualified identifier and must follow 
							the Java conventions. However, in contrast to Java identifiers it is 
							not allowed to use German umlauts or Unicode escape sequences in 
							identifiers. A valid ID-segment in MWE2 starts with a letter or an 
							underscore and is followed by any number of letters, numbers or underscores.
							An identifier is composed from one or more segments which are delimited
							by a '.' dot.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
Name: ID ('.' ID)*;
ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;</pre>
							<p>
						</p>
						<p>
							MWE2 does not use a semicolon as a statement delimiter at any place.
						</p>
						<!-- subsection -->
						<section id="MWE2ModuleSyntax" style="padding-top: 68px; margin-top: -68px;">
						<h3>Module</h3>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/mwe2/module.png" alt="" width="693" height="70">
							</div>
							<p>
						</p>
						<p>
							A <code class="prettyprint lang-mwe2">module</code> consists of four parts. The very first statement in a 
							<strong>*.mwe2</strong> file is the module declaration. The name of the module must 
							follow the naming convention for Java classes. That MWE2 file's name 
							must therefore be the same as the last segment of the module-name 
							and it has to be placed in the appropriate package of a Java source 
							path.
						</p>
						<p>
							It is allowed to define any number of import statements in a module.
							Imports are either suffixed by a wildcard or they import a concrete class 
							or module. MWE2 can handle relative imports in case one uses the 
							wildcard notation:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtext linenums">
'import' name '.*'?</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2PropertySyntax" style="padding-top: 68px; margin-top: -68px;">
						<h3>Property</h3>
						<p>
							The list of declared properties follows the optional import section.
							It is allowed to define modules without any properties.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/mwe2/property.png" alt="" width="524" height="144">
							</div>
							<p>
						</p>
						<p>
							Each declared property is locally visible in the module. It 
							furthermore defines an assignable feature of the module in case one 
							refers to it from another module. Properties may either have a 
							default value or they are considered to be <strong>mandatory</strong>. If the type
							of property is omitted it will be inferred from the default value. The
							default type of a property is <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>. That is, if no
							 default value is available, the property is <strong>mandatory</strong> and of type <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html"><abbr title="java.lang.String">String</abbr></a>.
						</p>
						<p>
							There are four types of values available in MWE2. One may either
							define a string, boolean or component literal or a reference to a
							previously defined property.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2ComponentSyntax" style="padding-top: 68px; margin-top: -68px;">
						<h3>Component</h3>
						<p>
							The building block of a module is the root component. It defines the externally
							visible type of the module and may either be created from a Java 
							type or from another module.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/mwe2/component.png" alt="" width="877" height="98">
							</div>
							<p>
						</p>
						<p>
							The type of the component can be derived in many cases except for 
							the root component. That's why it's optional in the component literal.
							If no type is given, it will be inferred from the left side of the
							assignment. The assigned feature can either be a declared property
							of the module or a <code class="prettyprint lang-java">set</code>- or <code class="prettyprint lang-java">add</code>-method of a Java class.
						</p>
						<p>
							Components can be named to make them referable in subsequent assignments.
							Following the <code class="prettyprint lang-xtext">':'</code> keyword, one can define an identifier for the 
							instantiated component. The identifier is locally visible in the module
							and any assignment that is defined after the named component can refer
							to this identifier and thereby exactly point to the instantiated object.
						</p>
						<p>
							The next option for a component is <code class="prettyprint lang-mwe2">auto-inject</code>. If this modifier
							is set on a component, any available feature of the component that has
							the same name as a property or previously created named component will
							be automatically assigned.
						</p>
						<p>
							The core of a component is the list of assignments between the curly 
							braces. An arbitrary number of values can be set on the component by
							means of feature-to-value pairs.
						</p>
						<p>
							</p>
							<div class="thumbnail">
								<img src="images/mwe2/assignment.png" alt="" width="320" height="132">
							</div>
							<p>
						</p>
						<p>
							The available constructs on the right hand side of the assignment
							are the same as for default values for properties.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2StringLiteralsSyntax" style="padding-top: 68px; margin-top: -68px;">
						<h3>String Literals</h3>
						<p>
							String values are likely to be the most used literals in MWE2. There 
							is a convenient syntax for string concatenation available due to
							the high relevance in a descriptive object composition and configuration 
							language. MWE2 strings are multi-line strings and can be composed of
							several parts.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-mwe2 linenums">
var aString = 'a value'
var anotherString = 'It is possible to embed ${aString} into
 a multi-line string'</pre>
							<p>
						</p>
						<p>
							This is especially convenient for path-substitution if one defines
							e.g. a common root directory and wants to specify other paths relative
							to the base.
						</p>
						<p>
							There are two different delimiters available for strings. Users 
							are free to either use single- or double-quotes to start and end strings. 
							If a certain string contains a lot of single-quotes one would better
							choose double-quotes as delimiter and vice versa. There is no semantic 
							difference between both notations.
						</p>
						<p>
							The escape character in MWE2 is the back-slash <code class="prettyprint lang-mwe2">"\\"</code>. It can be used
							to write line-breaks or tabular characters explicitly and to escape
							the beginning of substitution variables <code class="prettyprint lang-mwe2">${</code> and the quotes itself. Allowed
							escape sequences are:
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>\n</td>
							<td>..</td>
							<td>line break</td>
							</tr>
							<tr><td>\r</td>
							<td>..</td>
							<td>carriage return</td>
							</tr>
							<tr><td>\t</td>
							<td>..</td>
							<td>tabular character</td>
							</tr>
							<tr><td>\'</td>
							<td>..</td>
							<td>single-quote (can be omitted in double-quoted strings)</td>
							</tr>
							<tr><td>\"</td>
							<td>..</td>
							<td>double-quote (can be omitted in single-quoted strings)</td>
							</tr>
							<tr><td>\${</td>
							<td>..</td>
							<td>escape the substitution variable start ${</td>
							</tr>
							<tr><td>\\</td>
							<td>..</td>
							<td>the back-slash itself</td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							Other escape sequence are illegal in MWE2 strings.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2BooleanLiterals" style="padding-top: 68px; margin-top: -68px;">
						<h3>Boolean Literals</h3>
						<p>
							MWE2 has native support for the boolean type. The literals are <code class="prettyprint lang-mwe2">true</code> and <code class="prettyprint lang-mwe2">false</code>.
						</p>
						</section>
						<!-- subsection -->
						<section id="MWE2References" style="padding-top: 68px; margin-top: -68px;">
						<h3>References</h3>
						<p>
							Each assigned value in MWE2 either as default for properties or in a
							component assignment can be a reference to a previously declared property
							or named component. The can be referenced intuitively by their name.
						</p>
						</section>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3>Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">Xtext</a> on Twitter</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
	<script type="text/javascript" src="google-code-prettify/lang-common.js"></script><script type="text/javascript">
		registerLanguage('grammar|import|generate|terminal|enum|returns|with|hidden|as|current|fragment|EOF', 'xtext');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'xbase');
		registerLanguage('module|var|auto-inject|auto|inject|import|true|false', 'mwe2');
		registerLanguage('IMPORT|EXTENSION|FILE|ENDFILE|DEFINE|ENDDEFINE|FOR|ENDFOR|FOREACH|ENDFOREACH|AS|SEPARATOR|ITERATOR|EXPAND|REM|ENDREM|PROTECT|ENDPROTECT|this|IF|ENDIF|ELSE|null', 'xpand');
		registerLanguage('import|extension|this|create|cached|true|false|let|switch|case|if|then|else|context|WARNING|ERROR', 'check');
		registerLanguage('Hello', 'mydsl');
		registerLanguage('package|entity|datatype|many|import|extends|public|op|return|mapped-to', 'domainexample');
		registerLanguage('datatype|mapped-to', 'javatypesexample');
		registerLanguage('events|commands|state|actions|end|resetEvents', 'fowlerexample');
		registerLanguage('ref', 'linkingexample');
	</script>
</body>
</html>
