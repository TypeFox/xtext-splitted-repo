<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Xtext - Language Development Made Easy!</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description"
		content="The website of Eclipse Xtext, an open-source framework for development of programming langauges and domain-specific languages">
	<meta name="author" content="Sven Efftinge">
	<style>
		#header_wrapper {
			padding-top: 10px;
			/* 60px to make the container go all the way to the bottom of the topbar */
		}
		
		code.prettyprint {
	        padding: 0px;
	        background-color: white;
			border: none;
	    }
	</style>
	<!--  styles -->
	<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Le fav and touch icons -->
	
	<link rel="shortcut icon" href="images/favicon.png">
	
	<link href="css/bootstrap.css" rel="stylesheet" type='text/css'>
	<link href="css/bootstrap-responsive.css" rel="stylesheet" type='text/css'>
	<link href="css/style.css" rel="stylesheet" type='text/css'>
	<link href="css/shield-responsive.css" rel="stylesheet" type='text/css'>
	<link href='css/fonts.css' rel='stylesheet' type='text/css'>
	<link href="css/prettyPhoto.css" rel="stylesheet" media="screen" type='text/css'>
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
	<!--[if lt IE 9]>
	<link href="css/iebugs.css" rel="stylesheet" type='text/css'>
	<![endif]-->
	<script src="js/twitter.js" type="text/javascript"></script>
	<script src="js/jquery-1.7.1.min.js"></script>
	<script src="js/jquery.prettyPhoto.js" type="text/javascript"></script>
		<script type="text/javascript">
	     $(document).ready(function() {
					prettyPrint();
	         
					 $('a[data-rel]').each(function() {
	             $(this).attr('rel', $(this).data('rel'));
	         });
	        
					 $("a[rel^='prettyPhoto']").prettyPhoto({
	             animation_speed: 'fast',
	             slideshow: 5000,
	             autoplay_slideshow: false,
	             opacity: 0.80,
	             show_title: true,
	             theme: 'ligh_square',
	             overlay_gallery: false,
	             social_tools: false
	       
	         });
	         
					$('#nav-outline > li > a').live('click', function() {        
						$(this).parent().find('ul').slideToggle();      
					});
	         
					$('.has-popover').popover();
		 	     
		 	     getTwitters('tweet', { 
			        id: 'xtext', 
			        count: 5,
			        includeRT: true,
			        enableLinks: true, 
			        clearContents: true,
			        template : '"%text%" - %time% by <a href="http://twitter.com/%user_screen_name%/statuses/%id_str%/">@%user_screen_name%</a><br/><br/>'
			     });
	         
	         var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		 	     po.src = 'https://apis.google.com/js/plusone.js';
		 	     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	     });
		</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];	
	  	_gaq.push([ '_setAccount', 'UA-2429174-4' ]);
		_gaq.push([ '_trackPageview' ]);
		(function() {
			var ga = document.createElement('script');
			ga.type = 'text/javascript';
			ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl'
					: 'http://www')
					+ '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>
<body>
	<!-- Navbar -->
	<div class="navbar navbar-fixed-top"
		style="border-bottom: 1px solid #000;">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="icon-bar"></span> <span
					class="icon-bar"></span> <span class="icon-bar"></span>
				</a> <a class="brand" href="index.html"></a>
	
	
				<div class="nav-collapse collapse" style="height: 0px;">
					<ul class="nav">
						<li ><a href="download.html">Download</a></li>
						<li class="dropdown">
							<a href="examples.html" class="dropdown-toggle" data-toggle="dropdown">Examples<b class="caret"></b></a>
							<ul class="dropdown-menu">
								<li><a href="examples.html#introduction">Seven Languages by Seven Geeks</a></li>
								<li><a href="examples1.html#simple">A Simple Language</a></li>
								<li><a href="examples2.html#mongo">MongoBeans</a></li>
								<li><a href="examples3.html#routing">Http Routing</a></li>
								<li><a href="examples4.html#templates">Templates</a></li>
								<li><a href="examples5.html#guice">Guice Modules</a></li>
								<li><a href="examples6.html#cradle">Cradle</a></li>
								<li><a href="examples7.html#tortoise">Tortoise Shell</a></li>
							</ul>
						</li>
						<li ><a href="documentation.html">Documentation</a></li>
						<li ><a href="community.html">Community</a></li>
						<li><a href="http://www.eclipse.org">Eclipse.org</a></li>
					</ul>
	
				</div>
				<!--/.nav-collapse -->
	
			</div>
		</div>
	</div>
	<!-- Navbar End -->
<!--Container-->
<div id="header_wrapper" class="container" >
	<div class="inner">
		<div class="container">
			<div class="page-heading"><h1>Documentation</h1></div>
		</div> <!-- /.container -->
	</div> <!-- /inner -->
</div>
<div id="page">  
	<div class="inner">
		<div id="maincontainer" class="container">
			<!-- chapter -->
			<section id="routing" style="padding-top: 68px; margin-top: -68px;">
				<div class="row">
					<div class="span10 offset1">
						<h1>
							Http Routing
						</h1>
						<hr style="margin-top: 5px; margin-bottom: 5px;">
						<!--  section -->
						<section id="examples3.html#routing_motivation" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">The Problem</h2>
						<p>
							There are several different frameworks out there like <a href="https://github.com/playframework/Play20/wiki/ScalaRouting">Play</a>
							to support HttpRoutes.
							Normally they are defined in a special format in a separated central file. In most of the cases there is no tooling except a normal text/XML editor. 
							The only way to decide which route matches is the URL with different wildcards and placeholders. 
							The order of the routes defined in the file is important to decide which matches first. There is no support to access parts of the URL while the mapping is done.
							In most of the cases you might want to have full control via expressions to decide which action should be called. 
							Normally concrete classes are used directly in the route definition to point to an action that should be triggered. That's not really reusable in different scenarios and dependency injection is what you would really like to use.
						</p>
						</section>
						<!--  section -->
						<section id="examples3.html#routing_solution" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">A Solution With Xtext</h2>
						<p>
							In this project, we have created a small DSL base on <a href="http://www.xtext.org">Xtext</a> that allows to create routing with full support of expressions and access to the URL while the routing is done.
							The result is a javax.servlet.http.HttpServlet that has methods for the different routes with optional conditions and <a href="http://code.google.com/p/google-guice">Guice</a> bindings. Depending on the order in the file, the pattern and the conditions the respective method is called. 
							Eventually, we do only have a single <code class="prettyprint lang-xtend">javax.servlet.http.HttpServlet</code> containing the logic for routing implemented in Java. 
							To define routes you'll have to create a file with the extension '.route'. The first part of a route defines the type (GET, POST, PUT, DELETE or HEAD) of the route and the pattern.
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* ...</code>
							</p>
							<ul>
								<li><code class="prettyprint lang-xtend">:id</code> means a placeholder for a word</li>
								<li><code class="prettyprint lang-xtend">:rest*</code> means match everything to the rest of the url</li>
							</ul>
							<p>
							
							Then you have the possibility to define a condition like:
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ...</code>
							Here you have access to id and rest statically typed to String. The servlet will provide the value of the placeholder or wildcard when the mapping takes place. 
							An optional annotated Guice-key could be used after the condition or pattern to get an instance of that type/interface and trigger an operation. 
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass-&gt;doSomething(Integer::parseInt(id))</code>
							You'll see that there is access to all features of the bound type/interface with access to the placeholders or wildcard values from the URL.
							If you want to call static methods there is no need for a Guice-key. 
							<code class="prettyprint lang-routing">GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass::doSomethingStatic(id)</code>
							In both cases you have the possibility to feed the methods with an expression.
						</p>
						<p>
							To map that to Java we have to clarify what concepts we have and where we should hook in.
							First of all a <code class="prettyprint lang-xtend">javax.servlet.http.HttpServlet</code> has exactly one method for each request type (GET,
							POST, ...). Within these methods we'll have to call our routing logic. A route describes a pattern, a condition, a guice-key and a call of an action. So a pattern should be translated to a field as regular expression. This helps to match the URL and extract the values out of
							the given URL from the request. A condition should be a method with a boolean returntype where the request and the values of the variables from the URL-pattern are handled in as parameters. 
							The guice-key should be a field annotated with whatever is specified by
							the user and @Inject to tell Guice to inject an implementation here. 
							There is one more need for a method to wrap the action call with same parameters as the condition.
							Now we have everything to fill in our logic inside of the global method of the HttpServlet. First of
							all we have to match the URL, extract the values for the variables and establish local variables for
							that. If there is a condition we have to establish a guard for the action call. Only when the pattern
							matches the URL and the condition is true the call should be triggered. Otherwise a following route should
							be evaluated in the same way.
						</p>
						<!-- subsection -->
						<section id="routing_statistics" style="padding-top: 68px; margin-top: -68px;">
						<h3>Some Stats</h3>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>Language name</td>
							<td>HttpRouting</td>
							</tr>
							<tr><td>Xtext Grammar</td>
							<td>39 LOC, 8 rules, 1 Enum</td>
							</tr>
							<tr><td>Xtext extensions</td>
							<td>6 classes</td>
							</tr>
							<tr><td>Execution</td>
							<td>Java code generator</td>
							</tr>
							<tr><td>Hardest Part</td>
							<td>Handle regular expressions :-)</td>
							</tr>
							</table>
							<p>
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="examples3.html#routing_running" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Running the Example</h2>
						<p>
							You'll need Eclipse 3.5 or higher, Xtext 2.3 and Xtend 2.3. The Servlet-API on the class path of your project.
							Import the projects into an Eclipse workspace and run the launch config
							<strong>Run (org.eclipse.xtext.httprouting)</strong>. Now you may start with a new JavaProject or just import the project
							org.eclipse.httprouting.example. You'll see that the Servlet-API ist already included in the example.
						</p>
						</section>
						<!--  section -->
						<section id="examples3.html#routing_details" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">The Solution in Detail</h2>
						<!-- subsection -->
						<section id="routing_grammar" style="padding-top: 68px; margin-top: -68px;">
						<h3>Grammar</h3>
						<p>
							The Routing DSL extends org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations to make use of expressions
							predefined by <a href="http://www.eclipse.org/Xtext/#xbase">Xbase</a> plus support for Annotations.
							<code class="prettyprint lang-xtext">grammar org.xtext.httprouting.Route with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations</code>
							</p>
							<pre class="prettyprint lang-xtext linenums">
Import:
	'import' importedType=[types::JvmType|QualifiedName];</pre>
							<p>
							
							The Route DSL defines imports by using crossreferences. This makes it possible to use contentassist here
							and it is clear that the imported type exist.
							</p>
							<pre class="prettyprint lang-xtext linenums">
Route:
	requestType=RequestType url=URL condition=Condition? (key=Key call=RouteFeatureCall | call=XFeatureCall);
	
URL:
	{URL} "/" (ID ("." ID)? | variables+=Variable) ("/" (ID ("." ID)? | variables+=Variable))*;
	
Variable:
	":" name=ID (wildcard?="*")?;
	
Condition:
	"when" expression=XExpression;
	
Key:
	annotations+=XAnnotation? type=JvmTypeReference;</pre>
							<p>
							
							A Route has a type followed by an URL-pattern that can define variables. A variable could be a placeholder
							':id' or a wildcard ':name*'. After the URL-pattern matches an optional condition can point out if the
							route matches. Here you'll have the full support Xbase offers with access to the defined variables.
						</p>
						<p>
							One special thing here is that we can point to an action-implementation in different ways. 
							One is to define a guice-key with an optinal annotation to specialize a
							binding and access an available feature of the type directly after that. The other is to have a static
							method call on a type. The difference between RouteFeatureCall and XFeatureCall is that RouteFeatureCall
							does not allow a static method call.If you would like to see the difference on a grammar level please
							compare XFeatureCall and RouteFeatureCall with each other.
						</p>
						</section>
						<!-- subsection -->
						<section id="routing_inferrer" style="padding-top: 68px; margin-top: -68px;">
						<h3>Translation to Java</h3>
						<p>
							For each <strong>RouteFile</strong>, we create a Java class extending the class <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a>.
							The generated Java classes rely on the Servelet-API to work, so it has to be on the classpath.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td><code class="prettyprint lang-routing"></code></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
package org.xtext.httpRouting;
...
@SuppressWarnings("serial")
public class HttpMapperServlet extends HttpServlet {
 ...</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code responsible for this section looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
				superTypes += model.newTypeRef("javax.servlet.http.HttpServlet")
   				annotations += model.toAnnotation(typeof(SuppressWarnings), "serial")
		... // calling various methods to create Java members with from the Routes
         ])
}</pre>
							<p>
						</p>
						<p>
							For each Route a URL-pattern should end in a compiled regular expression pattern stored in a field.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td><code class="prettyprint lang-routing">GET /client/foo/:id</code></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
private static Pattern pattern0 = Pattern.compile("/client/foo/(\\w+)");</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							The inferrer code responsible for this section looks like this:
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		val routes = model.routes
   				var routeCounter = 0
   				for (route : routes) {
   					if (route.url != null) {
		   				addRoutePatternField(route, routeCounter)
		   				...
	   				}
					routeCounter = routeCounter + 1
   				}
		... //
         ])
}

def protected addRoutePatternField(JvmDeclaredType servlet, Route route, int routeCounter) {
		val patternField = route.url.toField("_pattern" + routeCounter , route.newTypeRef(typeof(Pattern))) [
			setStatic(true)
			setInitializer [
				append('Pattern.compile("')
				append(getRegExPattern(NodeModelUtils::getNode(route.url).text.trim, route.url.variables))
				append('")')
			]
		]
		servlet.members += patternField
   	}
...
def getRegExPattern(String originalPattern, List&lt;Variable&gt; variables) {
	var pattern = originalPattern
	for(variable : variables){
		if(variable.wildcard)
			pattern = pattern.replaceAll("(:" + variable.name + "\\*)", "(.+)")
		else
			pattern = originalPattern.replaceAll("(:" + variable.name + ")", "(\\\\\\\\w+)")
	}
	pattern
}
...</pre>
							<p>
						</p>
						<p>
							As we know the name of each variable we can replace the variable from the URL with a regualr expression
							with the same meaning to match the URL that has be routed. As we do not have a element in our model where
							the complete URL-pattern is stored we have to use the NodeModel to get the text behind the URL-pattern.
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td><code class="prettyprint lang-routing">GET /client/foo/:id when id=='42'</code></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public boolean doGet0Condition(final HttpServletRequest request, final String id) {
   boolean _equals = Objects.equal(id, "42");
   return _equals;
 }</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							For each Route a condition should end in a method with a boolean return type. Each variable value should
							be handled in as a parameter. Same is true for the <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html"><abbr title="javax.servlet.http.HttpServletRequest">HttpServletRequest</abbr></a>.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...

def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		val routes = model.routes
   				var routeCounter = 0
   				for (route : routes) {
   					if (route.url != null) {
   						...
		   				addRouteConditionMethod(route, routeCounter)
		   				...
	   				}
					routeCounter = routeCounter + 1
   				}
		... //
         ])
}

def protected addRouteConditionMethod(JvmDeclaredType servlet, Route route, int routeCounter) {
	if (route.condition != null &amp;&amp; route.condition.expression != null) {
	   	val name = route.nameOfRouteMethod(routeCounter)
		servlet.members += route.toMethod(name + "Condition", route.newTypeRef(Boolean::TYPE)) [
			parameters += route.toParameter("request", route.newTypeRef(HTTP_REQUEST))
			for (variable : route.url.variables){
				parameters += variable.toParameter(variable.name, route.newTypeRef(typeof(String)))
			}
			body = route.condition.expression
		]
	}
}

def nameOfRouteMethod(Route route, int i) {
		"_do" + route.type.literal.toLowerCase.toFirstUpper + i
	}</pre>
							<p>
						</p>
						<p>
							The expression defined in the condition ends up in the body of the new create method. That implies that
							all things sourrounding the method (fields, methods and parameters) are accessable within the expression.
							Isn't that cool. ;-)
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
@Inject
@Named(value = "ActionClassName")
private ActionClass key0;</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							For each Route a guice-key should end in a field with the defined annotations on it plus @Inject. As a guice-key is optional we have to make sure that route has a key. Now we create a field and add the
							annotations to it.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
			val routes = model.routes
			var routeCounter = 0
			for (route : routes) {
				if (route.url != null) {
	   				...
   					addRouteKeyField(route, routeCounter)
	   				...
   				}
				routeCounter = routeCounter + 1
			}
		...
         ])
}
...
def protected addRouteKeyField(JvmDeclaredType servlet, Route route, int routeCounter) {
		if (route.hasValidKey){
			servlet.members += route.key.toField("_key" + routeCounter, route.key.type) =&gt; [
				annotations += route.toAnnotation(typeof(Inject))
				route.key.annotations.translateAnnotationsTo(it)
			]
		}
   	}
...
def hasValidKey(Route route){
	route.key != null &amp;&amp; route.key.type != null &amp;&amp; !(route.key.type instanceof JvmVoid)
}</pre>
							<p>
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass-&gt;doSomething(Integer::parseInt(id))</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public boolean doGet0Condition(final HttpServletRequest request, final String id) {
    boolean _equals = Objects.equal(id, "42");
    return _equals;
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							For each Route an action call should end in a method where the guice-key (if there is one) and the variables
							should be handle in as parameters. The only special thing here is that the parameter that represents
							the guice-key is named 'it'. That implies that 'it' becomes the implicite reciever and the features of
							the type behind the guice-key are accessable without pointing out that 'it' is the reciever. Wow that's
							so easy...
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...
		val routes = model.routes
		var routeCounter = 0
		for (route : routes) {
			if (route.url != null) {
   				...
   				addRouteMethod(route, routeCounter)
			}
			routeCounter = routeCounter + 1
   		}
		... //
         ])
}
...
def protected addRouteMethod(JvmDeclaredType servlet, Route route, int routeCounter) {
   		val name = route.nameOfRouteMethod(routeCounter)
		servlet.members += route.toMethod(name, route.newTypeRef(Void::TYPE)) [
			documentation = route.documentation
			if (route.hasValidKey)
				parameters += route.key.toParameter("it", route.key.type)
			parameters += route.toParameter("request", route.newTypeRef(HTTP_REQUEST))
			for (variable : route.url.variables) {
				parameters += variable.toParameter(variable.name, route.newTypeRef(typeof(String)))
			}
			body = route.call
		]
   	}
...
def hasValidKey(Route route){
	route.key != null &amp;&amp; route.key.type != null &amp;&amp; !(route.key.type instanceof JvmVoid)
}</pre>
							<p>
						</p>
						<p>
							</p>
							<table class="table table-bordered table-condensed">
							<tr><td>DSL</td>
							<td></p>
							<pre class="prettyprint lang-routing linenums">
import com.google.inject.name.Named
import org.xtext.example.actionclasses.ActionClass

GET /client/foo/:id  when id=="42" @Named("ActionClassName") ActionClass-&gt;doSomething(Integer::parseInt(id))</pre>
							<p></td>
							</tr>
							<tr><td>Java</td>
							<td></p>
							<pre class="prettyprint lang-java linenums">
public void doGet(final HttpServletRequest request, final HttpServletResponse response) {
	String url =  request.getRequestURI();
	Matcher matcher0 = pattern0.matcher(url);
	if(matcher0.find()){
			String id =matcher0.group(1);
			if(doGet0Condition(request, id))
			doGet0(key0,request, id);
    }
}</pre>
							<p></td>
							</tr>
							</table>
							<p>
						</p>
						<p>
							Now we have to put our logic in the global methods of <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a>. First
							of all we have to establish several methods for the corresponding request types. As an example for GET
							the method <code class="prettyprint lang-java">public void doGet(final HttpServletRequest request, final HttpServletResponse response)</code>
							is responsible to handle such requests. So we have two challanges: estalish a method for each request
							type and put the logic in there for the routes that fits for that type.
							Inside of the method we'll have to match the URL from the request to the pattern and extract the values
							for the variables from the URL-pattern. Then we'll have to establish a guard to respect the condition.
							After that we'll finally call the action with the given values of the variables.
						</p>
						<p>
							</p>
							<pre class="prettyprint lang-xtend linenums">
@Inject extension JvmTypesBuilder
...
private static String REQUEST = "javax.servlet.http.HttpServletRequest"
...
def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(model.toClass("org.xtext.httpRouting.HttpMapperServlet"))
			.initializeLater([
			...	
			addMethod("doGet", model, routes,RequestType::GET)
			addMethod("doPost", model, routes,RequestType::POST)
			addMethod("doPut", model, routes,RequestType::PUT)
			addMethod("doDelete", model, routes,RequestType::DELETE)
			addMethod("doHead", model, routes,RequestType::HEAD)
			])
}
def protected addMethod(JvmDeclaredType servlet, String name, EObject element, Iterable&lt;Route&gt; routes, RequestType filterType) {
   		servlet.members += element.toMethod(name,element.newTypeRef(Void::TYPE)) [
			parameters += element.toParameter("request", element.newTypeRef(HTTP_REQUEST))
			parameters += element.toParameter("response", element.newTypeRef("javax.servlet.http.HttpServletResponse"))
			body = [
				var x = 0
				if (routes.exists[e | e.requestType == filterType])
					append('String url =  request.getRequestURL().toString();').newLine
				for (route : routes) {
					if (route.requestType == filterType) {
						if (route.url != null) {
							append(element.newTypeRef(typeof(Matcher)).type)
							append(''' _matcher&laquo;x&raquo; = _pattern&laquo;x&raquo;.matcher(url);''')
							newLine
							val variables = route.url.variables
						    append('''if (_matcher&laquo;x&raquo;.find()) {''').newLine
					    	for (variable : variables) {
								append('''		String &laquo;variable.name&raquo; = _matcher&laquo;x&raquo;.group(&laquo;variables.indexOf(variable) + 1&raquo;);''')
								newLine
							}
							if (route.condition != null) {
								append('''		if (&laquo;route.nameOfRouteMethod(x)&raquo;Condition(request''')
				   				append('''&laquo;FOR v : route.url.variables BEFORE ", " SEPARATOR ", "&raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;''')
				   				append('''))''')
				   				newLine
				   			}
							append('''			&laquo;route.nameOfRouteMethod(x)&raquo;(''')
							if(route.hasValidKey)
								append('''_key&laquo;x&raquo;,''')
							append('''request''')
			   				append('''&laquo;FOR v : route.url.variables BEFORE ", " SEPARATOR ", " &raquo;&laquo;v.name&raquo;&laquo;ENDFOR&raquo;''')
			   				append(''');''')
			   				newLine
							append('''}''')
							newLine
						}
					}
					x = x + 1
				}
			]
		]
   	}</pre>
							<p>
						</p>
						</section>
						<!-- subsection -->
						<section id="routing_additons" style="padding-top: 68px; margin-top: -68px;">
						<h3>Additional Aspects</h3>
						<p>
							With the Grammar and the inferrer mentioned in the sections above the DSL is funtional and does excatly
							what we want but there are several things we should customize to have a nice tool-support.
							</p>
							<ul>
								<li>First of all there are several things we do not want to have in the contentassist</li>
								<li>The outline is really ugly when the elements do not have a name</li>
								<li>There is a need for validation in the URL-pattern defintion</li>
							</ul>
							<p>
							
							So lets concentrate on the things in the contentassist. The inferred methods and fields have syntetic names
							and from the context of a condition or an action call we do not want to see the inferred things at all.
							So for that reason we have to customize the code and tweak the <abbr title="org.xtext.httprouting.jvmmodel.RouteJvmModelInferrer">RouteJvmModelInferrer</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/httprouting/org.xtext.httprouting.jvmmodel/src/org/xtext/httprouting/jvmmodel/RouteJvmModelInferrer.java">(src)</a>. All inferred fields and methods
							that we don't wanna see in the contentassist are prefixed with an underscore. Now we have the possibility
							to filter out proposals with this prefix in <abbr title="org.xtext.httprouting.ui.contentassist.RouteProposalProvider">RouteProposalProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/httprouting/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/contentassist/RouteProposalProvider.java">(src)</a>.
							The other thing is that in case of a guice-Key we introduce a parameter with the name 'it'. This means that
							all features of the type behind it are visible without writing it in front of the call. Good thing but
							we do not want 'it' as itself in the contentassist. Let's just filter that one out in <abbr title="org.xtext.httprouting.ui.contentassist.RouteProposalProvider">RouteProposalProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/httprouting/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/contentassist/RouteProposalProvider.java">(src)</a>.
						</p>
						<p>
							To tweak the outline for the routes you'll some customized labels in <abbr title="org.xtext.httprouting.ui.labeling.RouteLabelProvider">RouteLabelProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/httprouting/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/labeling/RouteLabelProvider.java">(src)</a>.
							For some objects we do not wanna see a node in the outline at all so there is a need fo a custom <abbr title="org.xtext.httprouting.ui.outline.RouteOutlineTreeProvider">RouteOutlineTreeProvider</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/httprouting/org.xtext.httprouting.ui/src/org/xtext/httprouting/ui/outline/RouteOutlineTreeProvider.java">(src)</a>.
						</p>
						<p>
							To give the user feedback while the routes are defined we can establish validation. You'll find a validation
							in <abbr title="org.xtext.httprouting.validation.RouteJavaValidator">RouteJavaValidator</abbr> <a href="https://github.com/xtext-dev/seven-languages-xtext/blob/master/httprouting/org.xtext.httprouting.validation/src/org/xtext/httprouting/validation/RouteJavaValidator.java">(src)</a> where we raise an error when a placeholder
							is defined after a wildcard in the URL.
						</p>
						</section>
						</section>
						<!--  section -->
						<section id="examples3.html#routing_beyond" style="padding-top: 68px; margin-top: -68px;">
						<h2 style="padding-top: 15px;">Beyond This Example</h2>
						<p>
							Of course the DSL is not complete and there are several types of URL-pattern variables missing but it
							should not be a hard thing to extend this example. To enable DI in the context of a <a href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServlet.html"><abbr title="javax.servlet.http.HttpServlet">HttpServlet</abbr></a>
							there has to be a wrapper or something like that to create an injector. One really cool thing would be
							to establish and <a href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.3/org/eclipse/xtext/xbase/XExpression.html"><abbr title="org.eclipse.xtext.xbase.XExpression">XExpression</abbr></a> <a href="https://github.com/eclipse/xtext/blob/v2.3.0/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/XExpression.java">(src)</a> that handles the complete guice-key and action call stuff with a corresponding
							compiler but this is fare beyond the scope of this example. ;-)
						</p>
						</section>
					</div>
				</div>
			</section>
		</div>
	</div>
</div>
	<div id="extra">
		<div class="inner">
			<div class="container">
				<div class="row">
					<div class="span6">
						<h3>Quick Links</h3>
						<ul class="footer-links clearfix">
							<li><a href="http://www.eclipse.org/legal/privacy.php">Privacy Policy</a></li>
							<li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
							<li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
							<li><a href="http://www.eclipse.org/legal/">Legal</a></li>
						</ul>
						<ul class="footer-links clearfix">
	      			<li><a href="http://www.eclipse.org">Eclipse Home</a></li>
							<li><a href="http://marketplace.eclipse.org/">Market Place</a></li>
							<li><a href="http://live.eclipse.org/">Eclipse Live</a></li>
							<li><a href="http://www.planeteclipse.org/">Eclipse Planet</a></li>
						</ul>
					</div>
					<div class="span6">
						<h3><a href="https://twitter.com/#!/xtext" style="color: white;">Xtext</a> on Twitter</h3>
						<br />
						<div id="tweet">
							<p>Please wait while my tweets load</p>
							<p>
								<a href="http://twitter.com/rem">If you can't wait - check
									out what I've been twittering</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- Le javascript
	    ================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	
	<script src="js/bootstrap-transition.js"></script>
	<script src="js/bootstrap-alert.js"></script>
	<script src="js/bootstrap-modal.js"></script>
	<script src="js/bootstrap-dropdown.js"></script>
	<script src="js/bootstrap-scrollspy.js"></script>
	<script src="js/bootstrap-tab.js"></script>
	<script src="js/bootstrap-tooltip.js"></script>
	<script src="js/bootstrap-popover.js"></script>
	<script src="js/bootstrap-button.js"></script>
	<script src="js/bootstrap-collapse.js"></script>
	<script src="js/bootstrap-carousel.js"></script>
	<script src="js/bootstrap-typeahead.js"></script>
	
	<!-- include pretty-print files -->
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="google-code-prettify/lang-xtend.js"></script>
	
	<!-- Include the plug-in -->
	<script src="js/jquery.easing.1.3.js" type="text/javascript"></script>
	<script src="js/custom.js" type="text/javascript"></script>
	<script type="text/javascript" src="google-code-prettify/lang-common.js"></script><script type="text/javascript">
		registerLanguage('grammar|import|generate|terminal|enum|returns|with|hidden|as|current|fragment|EOF', 'xtext');
		registerLanguage('extends|super|instanceof|as|new|null|false|true|val|var|if|else|switch|case|default|do|while|for|typeof|throw|try|catch|finally|this|it|int|boolean|short|char|double|float|long|byte|void|return', 'xbase');
		registerLanguage('module|var|auto-inject|auto|inject|import|true|false', 'mwe2');
		registerLanguage('package|import', 'mongobeans');
		registerLanguage('sub|begin|end', 'tortoise');
		registerLanguage('GET|POST|PUT|DELETE|HEAD|import|when', 'routing');
		registerLanguage('application', 'simple');
	</script>
</body>
</html>
